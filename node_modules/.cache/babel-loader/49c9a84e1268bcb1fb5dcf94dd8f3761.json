{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar TokenStream = require('token-stream');\n\nvar error = require('pug-error');\n\nvar inlineTags = require('./lib/inline-tags');\n\nmodule.exports = parse;\nmodule.exports.Parser = Parser;\n\nfunction parse(tokens, options) {\n  var parser = new Parser(tokens, options);\n  var ast = parser.parse();\n  return JSON.parse(JSON.stringify(ast));\n}\n\n;\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\nfunction Parser(tokens, options) {\n  options = options || {};\n\n  if (!Array.isArray(tokens)) {\n    throw new Error('Expected tokens to be an Array but got \"' + typeof tokens + '\"');\n  }\n\n  if (typeof options !== 'object') {\n    throw new Error('Expected \"options\" to be an object but got \"' + typeof options + '\"');\n  }\n\n  this.tokens = new TokenStream(tokens);\n  this.filename = options.filename;\n  this.src = options.src;\n  this.inMixin = 0;\n  this.plugins = options.plugins || [];\n}\n\n;\n/**\n * Parser prototype.\n */\n\nParser.prototype = {\n  /**\n   * Save original constructor\n   */\n  constructor: Parser,\n  error: function (code, message, token) {\n    var err = error(code, message, {\n      line: token.loc.start.line,\n      column: token.loc.start.column,\n      filename: this.filename,\n      src: this.src\n    });\n    throw err;\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n  advance: function () {\n    return this.tokens.advance();\n  },\n\n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n  peek: function () {\n    return this.tokens.peek();\n  },\n\n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  lookahead: function (n) {\n    return this.tokens.lookahead(n);\n  },\n\n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n  parse: function () {\n    var block = this.emptyBlock(0);\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n\n        if (expr) {\n          if (expr.type === 'Block') {\n            block.nodes = block.nodes.concat(expr.nodes);\n          } else {\n            block.nodes.push(expr);\n          }\n        }\n      }\n    }\n\n    return block;\n  },\n\n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n  expect: function (type) {\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      this.error('INVALID_TOKEN', 'expected \"' + type + '\", but got \"' + this.peek().type + '\"', this.peek());\n    }\n  },\n\n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n  accept: function (type) {\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n  initBlock: function (line, nodes) {\n    /* istanbul ignore if */\n    if ((line | 0) !== line) throw new Error('`line` is not an integer');\n    /* istanbul ignore if */\n\n    if (!Array.isArray(nodes)) throw new Error('`nodes` is not an array');\n    return {\n      type: 'Block',\n      nodes: nodes,\n      line: line,\n      filename: this.filename\n    };\n  },\n  emptyBlock: function (line) {\n    return this.initBlock(line, []);\n  },\n  runPlugin: function (context, tok) {\n    var rest = [this];\n\n    for (var i = 2; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n\n    var pluginContext;\n\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n\n      if (plugin[context] && plugin[context][tok.type]) {\n        if (pluginContext) throw new Error('Multiple plugin handlers found for context ' + JSON.stringify(context) + ', token type ' + JSON.stringify(tok.type));\n        pluginContext = plugin[context];\n      }\n    }\n\n    if (pluginContext) return pluginContext[tok.type].apply(pluginContext, rest);\n  },\n\n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | text-html\n   * | dot\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n  parseExpr: function () {\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n\n      case 'mixin':\n        return this.parseMixin();\n\n      case 'block':\n        return this.parseBlock();\n\n      case 'mixin-block':\n        return this.parseMixinBlock();\n\n      case 'case':\n        return this.parseCase();\n\n      case 'extends':\n        return this.parseExtends();\n\n      case 'include':\n        return this.parseInclude();\n\n      case 'doctype':\n        return this.parseDoctype();\n\n      case 'filter':\n        return this.parseFilter();\n\n      case 'comment':\n        return this.parseComment();\n\n      case 'text':\n      case 'interpolated-code':\n      case 'start-pug-interpolation':\n        return this.parseText({\n          block: true\n        });\n\n      case 'text-html':\n        return this.initBlock(this.peek().loc.start.line, this.parseTextHtml());\n\n      case 'dot':\n        return this.parseDot();\n\n      case 'each':\n        return this.parseEach();\n\n      case 'code':\n        return this.parseCode();\n\n      case 'blockcode':\n        return this.parseBlockCode();\n\n      case 'if':\n        return this.parseConditional();\n\n      case 'while':\n        return this.parseWhile();\n\n      case 'call':\n        return this.parseCall();\n\n      case 'interpolation':\n        return this.parseInterpolation();\n\n      case 'yield':\n        return this.parseYield();\n\n      case 'id':\n      case 'class':\n        if (!this.peek().loc.start) debugger;\n        this.tokens.defer({\n          type: 'tag',\n          val: 'div',\n          loc: this.peek().loc,\n          filename: this.filename\n        });\n        return this.parseExpr();\n\n      default:\n        var pluginResult = this.runPlugin('expressionTokens', this.peek());\n        if (pluginResult) return pluginResult;\n        this.error('INVALID_TOKEN', 'unexpected token \"' + this.peek().type + '\"', this.peek());\n    }\n  },\n  parseDot: function () {\n    this.advance();\n    return this.parseTextBlock();\n  },\n\n  /**\n   * Text\n   */\n  parseText: function (options) {\n    var tags = [];\n    var lineno = this.peek().loc.start.line;\n    var nextTok = this.peek();\n\n    loop: while (true) {\n      switch (nextTok.type) {\n        case 'text':\n          var tok = this.advance();\n          tags.push({\n            type: 'Text',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'interpolated-code':\n          var tok = this.advance();\n          tags.push({\n            type: 'Code',\n            val: tok.val,\n            buffer: tok.buffer,\n            mustEscape: tok.mustEscape !== false,\n            isInline: true,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'newline':\n          if (!options || !options.block) break loop;\n          var tok = this.advance();\n          var nextType = this.peek().type;\n\n          if (nextType === 'text' || nextType === 'interpolated-code') {\n            tags.push({\n              type: 'Text',\n              val: '\\n',\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename\n            });\n          }\n\n          break;\n\n        case 'start-pug-interpolation':\n          this.advance();\n          tags.push(this.parseExpr());\n          this.expect('end-pug-interpolation');\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('textTokens', nextTok, tags);\n          if (pluginResult) break;\n          break loop;\n      }\n\n      nextTok = this.peek();\n    }\n\n    if (tags.length === 1) return tags[0];else return this.initBlock(lineno, tags);\n  },\n  parseTextHtml: function () {\n    var nodes = [];\n    var currentNode = null;\n\n    loop: while (true) {\n      switch (this.peek().type) {\n        case 'text-html':\n          var text = this.advance();\n\n          if (!currentNode) {\n            currentNode = {\n              type: 'Text',\n              val: text.val,\n              filename: this.filename,\n              line: text.loc.start.line,\n              column: text.loc.start.column,\n              isHtml: true\n            };\n            nodes.push(currentNode);\n          } else {\n            currentNode.val += '\\n' + text.val;\n          }\n\n          break;\n\n        case 'indent':\n          var block = this.block();\n          block.nodes.forEach(function (node) {\n            if (node.isHtml) {\n              if (!currentNode) {\n                currentNode = node;\n                nodes.push(currentNode);\n              } else {\n                currentNode.val += '\\n' + node.val;\n              }\n            } else {\n              currentNode = null;\n              nodes.push(node);\n            }\n          });\n          break;\n\n        case 'code':\n          currentNode = null;\n          nodes.push(this.parseCode(true));\n          break;\n\n        case 'newline':\n          this.advance();\n          break;\n\n        default:\n          break loop;\n      }\n    }\n\n    return nodes;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n  parseBlockExpansion: function () {\n    var tok = this.accept(':');\n\n    if (tok) {\n      var expr = this.parseExpr();\n      return expr.type === 'Block' ? expr : this.initBlock(tok.loc.start.line, [expr]);\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n  parseCase: function () {\n    var tok = this.expect('case');\n    var node = {\n      type: 'Case',\n      expr: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    var block = this.emptyBlock(tok.loc.start.line + 1);\n    this.expect('indent');\n\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'comment':\n        case 'newline':\n          this.advance();\n          break;\n\n        case 'when':\n          block.nodes.push(this.parseWhen());\n          break;\n\n        case 'default':\n          block.nodes.push(this.parseDefault());\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('caseTokens', this.peek(), block);\n          if (pluginResult) break;\n          this.error('INVALID_TOKEN', 'Unexpected token \"' + this.peek().type + '\", expected \"when\", \"default\" or \"newline\"', this.peek());\n      }\n    }\n\n    this.expect('outdent');\n    node.block = block;\n    return node;\n  },\n\n  /**\n   * when\n   */\n  parseWhen: function () {\n    var tok = this.expect('when');\n\n    if (this.peek().type !== 'newline') {\n      return {\n        type: 'When',\n        expr: tok.val,\n        block: this.parseBlockExpansion(),\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    } else {\n      return {\n        type: 'When',\n        expr: tok.val,\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    }\n  },\n\n  /**\n   * default\n   */\n  parseDefault: function () {\n    var tok = this.expect('default');\n    return {\n      type: 'When',\n      expr: 'default',\n      block: this.parseBlockExpansion(),\n      debug: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * code\n   */\n  parseCode: function (noBlock) {\n    var tok = this.expect('code');\n    assert(typeof tok.mustEscape === 'boolean', 'Please update to the newest version of pug-lexer.');\n    var node = {\n      type: 'Code',\n      val: tok.val,\n      buffer: tok.buffer,\n      mustEscape: tok.mustEscape !== false,\n      isInline: !!noBlock,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    }; // todo: why is this here?  It seems like a hacky workaround\n\n    if (node.val.match(/^ *else/)) node.debug = false;\n    if (noBlock) return node;\n    var block; // handle block\n\n    block = 'indent' == this.peek().type;\n\n    if (block) {\n      if (tok.buffer) {\n        this.error('BLOCK_IN_BUFFERED_CODE', 'Buffered code cannot have a block attached to it', this.peek());\n      }\n\n      node.block = this.block();\n    }\n\n    return node;\n  },\n  parseConditional: function () {\n    var tok = this.expect('if');\n    var node = {\n      type: 'Conditional',\n      test: tok.val,\n      consequent: this.emptyBlock(tok.loc.start.line),\n      alternate: null,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    }; // handle block\n\n    if ('indent' == this.peek().type) {\n      node.consequent = this.block();\n    }\n\n    var currentNode = node;\n\n    while (true) {\n      if (this.peek().type === 'newline') {\n        this.expect('newline');\n      } else if (this.peek().type === 'else-if') {\n        tok = this.expect('else-if');\n        currentNode = currentNode.alternate = {\n          type: 'Conditional',\n          test: tok.val,\n          consequent: this.emptyBlock(tok.loc.start.line),\n          alternate: null,\n          line: tok.loc.start.line,\n          column: tok.loc.start.column,\n          filename: this.filename\n        };\n\n        if ('indent' == this.peek().type) {\n          currentNode.consequent = this.block();\n        }\n      } else if (this.peek().type === 'else') {\n        this.expect('else');\n\n        if (this.peek().type === 'indent') {\n          currentNode.alternate = this.block();\n        }\n\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  },\n  parseWhile: function () {\n    var tok = this.expect('while');\n    var node = {\n      type: 'While',\n      test: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    }; // handle block\n\n    if ('indent' == this.peek().type) {\n      node.block = this.block();\n    } else {\n      node.block = this.emptyBlock(tok.loc.start.line);\n    }\n\n    return node;\n  },\n\n  /**\n   * block code\n   */\n  parseBlockCode: function () {\n    var tok = this.expect('blockcode');\n    var line = tok.loc.start.line;\n    var column = tok.loc.start.column;\n    var body = this.peek();\n    var text = '';\n\n    if (body.type === 'start-pipeless-text') {\n      this.advance();\n\n      while (this.peek().type !== 'end-pipeless-text') {\n        tok = this.advance();\n\n        switch (tok.type) {\n          case 'text':\n            text += tok.val;\n            break;\n\n          case 'newline':\n            text += '\\n';\n            break;\n\n          default:\n            var pluginResult = this.runPlugin('blockCodeTokens', tok, tok);\n\n            if (pluginResult) {\n              text += pluginResult;\n              break;\n            }\n\n            this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);\n        }\n      }\n\n      this.advance();\n    }\n\n    return {\n      type: 'Code',\n      val: text,\n      buffer: false,\n      mustEscape: false,\n      isInline: false,\n      line: line,\n      column: column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * comment\n   */\n  parseComment: function () {\n    var tok = this.expect('comment');\n    var block;\n\n    if (block = this.parseTextBlock()) {\n      return {\n        type: 'BlockComment',\n        val: tok.val,\n        block: block,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    } else {\n      return {\n        type: 'Comment',\n        val: tok.val,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    }\n  },\n\n  /**\n   * doctype\n   */\n  parseDoctype: function () {\n    var tok = this.expect('doctype');\n    return {\n      type: 'Doctype',\n      val: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n  parseIncludeFilter: function () {\n    var tok = this.expect('filter');\n    var attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    return {\n      type: 'IncludeFilter',\n      name: tok.val,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * filter attrs? text-block\n   */\n  parseFilter: function () {\n    var tok = this.expect('filter');\n    var block,\n        attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    if (this.peek().type === 'text') {\n      var textToken = this.advance();\n      block = this.initBlock(textToken.loc.start.line, [{\n        type: 'Text',\n        val: textToken.val,\n        line: textToken.loc.start.line,\n        column: textToken.loc.start.column,\n        filename: this.filename\n      }]);\n    } else if (this.peek().type === 'filter') {\n      block = this.initBlock(tok.loc.start.line, [this.parseFilter()]);\n    } else {\n      block = this.parseTextBlock() || this.emptyBlock(tok.loc.start.line);\n    }\n\n    return {\n      type: 'Filter',\n      name: tok.val,\n      block: block,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * each block\n   */\n  parseEach: function () {\n    var tok = this.expect('each');\n    var node = {\n      type: 'Each',\n      obj: tok.code,\n      val: tok.val,\n      key: tok.key,\n      block: this.block(),\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n\n    if (this.peek().type == 'else') {\n      this.advance();\n      node.alternate = this.block();\n    }\n\n    return node;\n  },\n\n  /**\n   * 'extends' name\n   */\n  parseExtends: function () {\n    var tok = this.expect('extends');\n    var path = this.expect('path');\n    return {\n      type: 'Extends',\n      file: {\n        type: 'FileReference',\n        path: path.val.trim(),\n        line: path.loc.start.line,\n        column: path.loc.start.column,\n        filename: this.filename\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * 'block' name block\n   */\n  parseBlock: function () {\n    var tok = this.expect('block');\n    var node = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);\n    node.type = 'NamedBlock';\n    node.name = tok.val.trim();\n    node.mode = tok.mode;\n    node.line = tok.loc.start.line;\n    node.column = tok.loc.start.column;\n    return node;\n  },\n  parseMixinBlock: function () {\n    var tok = this.expect('mixin-block');\n\n    if (!this.inMixin) {\n      this.error('BLOCK_OUTISDE_MIXIN', 'Anonymous blocks are not allowed unless they are part of a mixin.', tok);\n    }\n\n    return {\n      type: 'MixinBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n  parseYield: function () {\n    var tok = this.expect('yield');\n    return {\n      type: 'YieldBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * include block?\n   */\n  parseInclude: function () {\n    var tok = this.expect('include');\n    var node = {\n      type: 'Include',\n      file: {\n        type: 'FileReference',\n        filename: this.filename\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    var filters = [];\n\n    while (this.peek().type === 'filter') {\n      filters.push(this.parseIncludeFilter());\n    }\n\n    var path = this.expect('path');\n    node.file.path = path.val.trim();\n    node.file.line = path.loc.start.line;\n    node.file.column = path.loc.start.column;\n\n    if ((/\\.jade$/.test(node.file.path) || /\\.pug$/.test(node.file.path)) && !filters.length) {\n      node.block = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);\n\n      if (/\\.jade$/.test(node.file.path)) {\n        console.warn(this.filename + ', line ' + tok.loc.start.line + ':\\nThe .jade extension is deprecated, use .pug for \"' + node.file.path + '\".');\n      }\n    } else {\n      node.type = 'RawInclude';\n      node.filters = filters;\n\n      if (this.peek().type === 'indent') {\n        this.error('RAW_INCLUDE_BLOCK', 'Raw inclusion cannot contain a block', this.peek());\n      }\n    }\n\n    return node;\n  },\n\n  /**\n   * call ident block\n   */\n  parseCall: function () {\n    var tok = this.expect('call');\n    var name = tok.val;\n    var args = tok.args;\n    var mixin = {\n      type: 'Mixin',\n      name: name,\n      args: args,\n      block: this.emptyBlock(tok.loc.start.line),\n      call: true,\n      attrs: [],\n      attributeBlocks: [],\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    this.tag(mixin);\n\n    if (mixin.code) {\n      mixin.block.nodes.push(mixin.code);\n      delete mixin.code;\n    }\n\n    if (mixin.block.nodes.length === 0) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n  parseMixin: function () {\n    var tok = this.expect('mixin');\n    var name = tok.val;\n    var args = tok.args;\n\n    if ('indent' == this.peek().type) {\n      this.inMixin++;\n      var mixin = {\n        type: 'Mixin',\n        name: name,\n        args: args,\n        block: this.block(),\n        call: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n      this.inMixin--;\n      return mixin;\n    } else {\n      this.error('MIXIN_WITHOUT_BODY', 'Mixin ' + name + ' declared without body', tok);\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n  parseTextBlock: function () {\n    var tok = this.accept('start-pipeless-text');\n    if (!tok) return;\n    var block = this.emptyBlock(tok.loc.start.line);\n\n    while (this.peek().type !== 'end-pipeless-text') {\n      var tok = this.advance();\n\n      switch (tok.type) {\n        case 'text':\n          block.nodes.push({\n            type: 'Text',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'newline':\n          block.nodes.push({\n            type: 'Text',\n            val: '\\n',\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'start-pug-interpolation':\n          block.nodes.push(this.parseExpr());\n          this.expect('end-pug-interpolation');\n          break;\n\n        case 'interpolated-code':\n          block.nodes.push({\n            type: 'Code',\n            val: tok.val,\n            buffer: tok.buffer,\n            mustEscape: tok.mustEscape !== false,\n            isInline: true,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('textBlockTokens', tok, block, tok);\n          if (pluginResult) break;\n          this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);\n      }\n    }\n\n    this.advance();\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n  block: function () {\n    var tok = this.expect('indent');\n    var block = this.emptyBlock(tok.loc.start.line);\n\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n\n        if (expr.type === 'Block') {\n          block.nodes = block.nodes.concat(expr.nodes);\n        } else {\n          block.nodes.push(expr);\n        }\n      }\n    }\n\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  parseInterpolation: function () {\n    var tok = this.advance();\n    var tag = {\n      type: 'InterpolatedTag',\n      expr: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    return this.tag(tag, {\n      selfClosingAllowed: true\n    });\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  parseTag: function () {\n    var tok = this.advance();\n    var tag = {\n      type: 'Tag',\n      name: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: inlineTags.indexOf(tok.val) !== -1,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    return this.tag(tag, {\n      selfClosingAllowed: true\n    });\n  },\n\n  /**\n   * Parse tag.\n   */\n  tag: function (tag, options) {\n    var seenAttrs = false;\n    var attributeNames = [];\n    var selfClosingAllowed = options && options.selfClosingAllowed; // (attrs | class | id)*\n\n    out: while (true) {\n      switch (this.peek().type) {\n        case 'id':\n        case 'class':\n          var tok = this.advance();\n\n          if (tok.type === 'id') {\n            if (attributeNames.indexOf('id') !== -1) {\n              this.error('DUPLICATE_ID', 'Duplicate attribute \"id\" is not allowed.', tok);\n            }\n\n            attributeNames.push('id');\n          }\n\n          tag.attrs.push({\n            name: tok.type,\n            val: \"'\" + tok.val + \"'\",\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n            mustEscape: false\n          });\n          continue;\n\n        case 'start-attributes':\n          if (seenAttrs) {\n            console.warn(this.filename + ', line ' + this.peek().loc.start.line + ':\\nYou should not have pug tags with multiple attributes.');\n          }\n\n          seenAttrs = true;\n          tag.attrs = tag.attrs.concat(this.attrs(attributeNames));\n          continue;\n\n        case '&attributes':\n          var tok = this.advance();\n          tag.attributeBlocks.push({\n            type: 'AttributeBlock',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('tagAttributeTokens', this.peek(), tag, attributeNames);\n          if (pluginResult) break;\n          break out;\n      }\n    } // check immediate '.'\n\n\n    if ('dot' == this.peek().type) {\n      tag.textOnly = true;\n      this.advance();\n    } // (text | code | ':')?\n\n\n    switch (this.peek().type) {\n      case 'text':\n      case 'interpolated-code':\n        var text = this.parseText();\n\n        if (text.type === 'Block') {\n          tag.block.nodes.push.apply(tag.block.nodes, text.nodes);\n        } else {\n          tag.block.nodes.push(text);\n        }\n\n        break;\n\n      case 'code':\n        tag.block.nodes.push(this.parseCode(true));\n        break;\n\n      case ':':\n        this.advance();\n        var expr = this.parseExpr();\n        tag.block = expr.type === 'Block' ? expr : this.initBlock(tag.line, [expr]);\n        break;\n\n      case 'newline':\n      case 'indent':\n      case 'outdent':\n      case 'eos':\n      case 'start-pipeless-text':\n      case 'end-pug-interpolation':\n        break;\n\n      case 'slash':\n        if (selfClosingAllowed) {\n          this.advance();\n          tag.selfClosing = true;\n          break;\n        }\n\n      default:\n        var pluginResult = this.runPlugin('tagTokens', this.peek(), tag, options);\n        if (pluginResult) break;\n        this.error('INVALID_TOKEN', 'Unexpected token `' + this.peek().type + '` expected `text`, `interpolated-code`, `code`, `:`' + (selfClosingAllowed ? ', `slash`' : '') + ', `newline` or `eos`', this.peek());\n    } // newline*\n\n\n    while ('newline' == this.peek().type) this.advance(); // block?\n\n\n    if (tag.textOnly) {\n      tag.block = this.parseTextBlock() || this.emptyBlock(tag.line);\n    } else if ('indent' == this.peek().type) {\n      var block = this.block();\n\n      for (var i = 0, len = block.nodes.length; i < len; ++i) {\n        tag.block.nodes.push(block.nodes[i]);\n      }\n    }\n\n    return tag;\n  },\n  attrs: function (attributeNames) {\n    this.expect('start-attributes');\n    var attrs = [];\n    var tok = this.advance();\n\n    while (tok.type === 'attribute') {\n      if (tok.name !== 'class' && attributeNames) {\n        if (attributeNames.indexOf(tok.name) !== -1) {\n          this.error('DUPLICATE_ATTRIBUTE', 'Duplicate attribute \"' + tok.name + '\" is not allowed.', tok);\n        }\n\n        attributeNames.push(tok.name);\n      }\n\n      attrs.push({\n        name: tok.name,\n        val: tok.val,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n        mustEscape: tok.mustEscape !== false\n      });\n      tok = this.advance();\n    }\n\n    this.tokens.defer(tok);\n    this.expect('end-attributes');\n    return attrs;\n  }\n};","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/babel-plugin-transform-react-pug/node_modules/pug-parser/index.js"],"names":["assert","require","TokenStream","error","inlineTags","module","exports","parse","Parser","tokens","options","parser","ast","JSON","stringify","Array","isArray","Error","filename","src","inMixin","plugins","prototype","constructor","code","message","token","err","line","loc","start","column","advance","peek","lookahead","n","block","emptyBlock","type","nodes","concat","parseTextHtml","expr","parseExpr","push","expect","accept","initBlock","runPlugin","context","tok","rest","i","arguments","length","pluginContext","plugin","apply","parseTag","parseMixin","parseBlock","parseMixinBlock","parseCase","parseExtends","parseInclude","parseDoctype","parseFilter","parseComment","parseText","parseDot","parseEach","parseCode","parseBlockCode","parseConditional","parseWhile","parseCall","parseInterpolation","parseYield","defer","val","pluginResult","parseTextBlock","tags","lineno","nextTok","loop","buffer","mustEscape","isInline","nextType","currentNode","text","isHtml","forEach","node","parseBlockExpansion","parseWhen","parseDefault","debug","noBlock","match","test","consequent","alternate","body","parseIncludeFilter","attrs","name","textToken","obj","key","path","file","trim","mode","filters","console","warn","args","mixin","call","attributeBlocks","tag","selfClosing","selfClosingAllowed","indexOf","seenAttrs","attributeNames","out","textOnly","len"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,cAAD,CAAzB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,WAAD,CAAnB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,mBAAD,CAAxB;;AAEAI,MAAM,CAACC,OAAP,GAAiBC,KAAjB;AACAF,MAAM,CAACC,OAAP,CAAeE,MAAf,GAAwBA,MAAxB;;AACA,SAASD,KAAT,CAAeE,MAAf,EAAuBC,OAAvB,EAAgC;AAC9B,MAAIC,MAAM,GAAG,IAAIH,MAAJ,CAAWC,MAAX,EAAmBC,OAAnB,CAAb;AACA,MAAIE,GAAG,GAAGD,MAAM,CAACJ,KAAP,EAAV;AACA,SAAOM,IAAI,CAACN,KAAL,CAAWM,IAAI,CAACC,SAAL,CAAeF,GAAf,CAAX,CAAP;AACD;;AAAA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASJ,MAAT,CAAgBC,MAAhB,EAAwBC,OAAxB,EAAiC;AAC/BA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,MAAI,CAACK,KAAK,CAACC,OAAN,CAAcP,MAAd,CAAL,EAA4B;AAC1B,UAAM,IAAIQ,KAAJ,CAAU,6CAA8C,OAAOR,MAArD,GAA+D,GAAzE,CAAN;AACD;;AACD,MAAI,OAAOC,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAIO,KAAJ,CAAU,iDAAkD,OAAOP,OAAzD,GAAoE,GAA9E,CAAN;AACD;;AACD,OAAKD,MAAL,GAAc,IAAIP,WAAJ,CAAgBO,MAAhB,CAAd;AACA,OAAKS,QAAL,GAAgBR,OAAO,CAACQ,QAAxB;AACA,OAAKC,GAAL,GAAWT,OAAO,CAACS,GAAnB;AACA,OAAKC,OAAL,GAAe,CAAf;AACA,OAAKC,OAAL,GAAeX,OAAO,CAACW,OAAR,IAAmB,EAAlC;AACD;;AAAA;AAED;AACA;AACA;;AAEAb,MAAM,CAACc,SAAP,GAAmB;AAEjB;AACF;AACA;AAEEC,EAAAA,WAAW,EAAEf,MANI;AAQjBL,EAAAA,KAAK,EAAE,UAAUqB,IAAV,EAAgBC,OAAhB,EAAyBC,KAAzB,EAAgC;AACrC,QAAIC,GAAG,GAAGxB,KAAK,CAACqB,IAAD,EAAOC,OAAP,EAAgB;AAC7BG,MAAAA,IAAI,EAAEF,KAAK,CAACG,GAAN,CAAUC,KAAV,CAAgBF,IADO;AAE7BG,MAAAA,MAAM,EAAEL,KAAK,CAACG,GAAN,CAAUC,KAAV,CAAgBC,MAFK;AAG7Bb,MAAAA,QAAQ,EAAE,KAAKA,QAHc;AAI7BC,MAAAA,GAAG,EAAE,KAAKA;AAJmB,KAAhB,CAAf;AAMA,UAAMQ,GAAN;AACD,GAhBgB;;AAkBjB;AACF;AACA;AACA;AACA;AACA;AAEEK,EAAAA,OAAO,EAAE,YAAU;AACjB,WAAO,KAAKvB,MAAL,CAAYuB,OAAZ,EAAP;AACD,GA3BgB;;AA6BjB;AACF;AACA;AACA;AACA;AACA;AAEEC,EAAAA,IAAI,EAAE,YAAW;AACf,WAAO,KAAKxB,MAAL,CAAYwB,IAAZ,EAAP;AACD,GAtCgB;;AAwCjB;AACF;AACA;AACA;AACA;AACA;AACA;AAEEC,EAAAA,SAAS,EAAE,UAASC,CAAT,EAAW;AACpB,WAAO,KAAK1B,MAAL,CAAYyB,SAAZ,CAAsBC,CAAtB,CAAP;AACD,GAlDgB;;AAoDjB;AACF;AACA;AACA;AACA;AACA;AAEE5B,EAAAA,KAAK,EAAE,YAAU;AACf,QAAI6B,KAAK,GAAG,KAAKC,UAAL,CAAgB,CAAhB,CAAZ;;AAEA,WAAO,SAAS,KAAKJ,IAAL,GAAYK,IAA5B,EAAkC;AAChC,UAAI,aAAa,KAAKL,IAAL,GAAYK,IAA7B,EAAmC;AACjC,aAAKN,OAAL;AACD,OAFD,MAEO,IAAI,eAAe,KAAKC,IAAL,GAAYK,IAA/B,EAAqC;AAC1CF,QAAAA,KAAK,CAACG,KAAN,GAAcH,KAAK,CAACG,KAAN,CAAYC,MAAZ,CAAmB,KAAKC,aAAL,EAAnB,CAAd;AACD,OAFM,MAEA;AACL,YAAIC,IAAI,GAAG,KAAKC,SAAL,EAAX;;AACA,YAAID,IAAJ,EAAU;AACR,cAAIA,IAAI,CAACJ,IAAL,KAAc,OAAlB,EAA2B;AACzBF,YAAAA,KAAK,CAACG,KAAN,GAAcH,KAAK,CAACG,KAAN,CAAYC,MAAZ,CAAmBE,IAAI,CAACH,KAAxB,CAAd;AACD,WAFD,MAEO;AACLH,YAAAA,KAAK,CAACG,KAAN,CAAYK,IAAZ,CAAiBF,IAAjB;AACD;AACF;AACF;AACF;;AAED,WAAON,KAAP;AACD,GAhFgB;;AAkFjB;AACF;AACA;AACA;AACA;AACA;AAEES,EAAAA,MAAM,EAAE,UAASP,IAAT,EAAc;AACpB,QAAI,KAAKL,IAAL,GAAYK,IAAZ,KAAqBA,IAAzB,EAA+B;AAC7B,aAAO,KAAKN,OAAL,EAAP;AACD,KAFD,MAEO;AACL,WAAK7B,KAAL,CAAW,eAAX,EAA4B,eAAemC,IAAf,GAAsB,cAAtB,GAAuC,KAAKL,IAAL,GAAYK,IAAnD,GAA0D,GAAtF,EAA2F,KAAKL,IAAL,EAA3F;AACD;AACF,GA/FgB;;AAiGjB;AACF;AACA;AACA;AACA;AACA;AAEEa,EAAAA,MAAM,EAAE,UAASR,IAAT,EAAc;AACpB,QAAI,KAAKL,IAAL,GAAYK,IAAZ,KAAqBA,IAAzB,EAA+B;AAC7B,aAAO,KAAKN,OAAL,EAAP;AACD;AACF,GA5GgB;AA8GjBe,EAAAA,SAAS,EAAE,UAASnB,IAAT,EAAeW,KAAf,EAAsB;AAC/B;AACA,QAAI,CAACX,IAAI,GAAG,CAAR,MAAeA,IAAnB,EAAyB,MAAM,IAAIX,KAAJ,CAAU,0BAAV,CAAN;AACzB;;AACA,QAAI,CAACF,KAAK,CAACC,OAAN,CAAcuB,KAAd,CAAL,EAA2B,MAAM,IAAItB,KAAJ,CAAU,yBAAV,CAAN;AAC3B,WAAO;AACLqB,MAAAA,IAAI,EAAE,OADD;AAELC,MAAAA,KAAK,EAAEA,KAFF;AAGLX,MAAAA,IAAI,EAAEA,IAHD;AAILV,MAAAA,QAAQ,EAAE,KAAKA;AAJV,KAAP;AAMD,GAzHgB;AA2HjBmB,EAAAA,UAAU,EAAE,UAAST,IAAT,EAAe;AACzB,WAAO,KAAKmB,SAAL,CAAenB,IAAf,EAAqB,EAArB,CAAP;AACD,GA7HgB;AA+HjBoB,EAAAA,SAAS,EAAE,UAASC,OAAT,EAAkBC,GAAlB,EAAuB;AAChC,QAAIC,IAAI,GAAG,CAAC,IAAD,CAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AACzCD,MAAAA,IAAI,CAACP,IAAL,CAAUS,SAAS,CAACD,CAAD,CAAnB;AACD;;AACD,QAAIG,aAAJ;;AACA,SAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK/B,OAAL,CAAaiC,MAAjC,EAAyCF,CAAC,EAA1C,EAA8C;AAC5C,UAAII,MAAM,GAAG,KAAKnC,OAAL,CAAa+B,CAAb,CAAb;;AACA,UAAII,MAAM,CAACP,OAAD,CAAN,IAAmBO,MAAM,CAACP,OAAD,CAAN,CAAgBC,GAAG,CAACZ,IAApB,CAAvB,EAAkD;AAChD,YAAIiB,aAAJ,EAAmB,MAAM,IAAItC,KAAJ,CAAU,gDAAgDJ,IAAI,CAACC,SAAL,CAAemC,OAAf,CAAhD,GAA0E,eAA1E,GAA4FpC,IAAI,CAACC,SAAL,CAAeoC,GAAG,CAACZ,IAAnB,CAAtG,CAAN;AACnBiB,QAAAA,aAAa,GAAGC,MAAM,CAACP,OAAD,CAAtB;AACD;AACF;;AACD,QAAIM,aAAJ,EAAmB,OAAOA,aAAa,CAACL,GAAG,CAACZ,IAAL,CAAb,CAAwBmB,KAAxB,CAA8BF,aAA9B,EAA6CJ,IAA7C,CAAP;AACpB,GA7IgB;;AA+IjB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEER,EAAAA,SAAS,EAAE,YAAU;AACnB,YAAQ,KAAKV,IAAL,GAAYK,IAApB;AACE,WAAK,KAAL;AACE,eAAO,KAAKoB,QAAL,EAAP;;AACF,WAAK,OAAL;AACE,eAAO,KAAKC,UAAL,EAAP;;AACF,WAAK,OAAL;AACE,eAAO,KAAKC,UAAL,EAAP;;AACF,WAAK,aAAL;AACE,eAAO,KAAKC,eAAL,EAAP;;AACF,WAAK,MAAL;AACE,eAAO,KAAKC,SAAL,EAAP;;AACF,WAAK,SAAL;AACE,eAAO,KAAKC,YAAL,EAAP;;AACF,WAAK,SAAL;AACE,eAAO,KAAKC,YAAL,EAAP;;AACF,WAAK,SAAL;AACE,eAAO,KAAKC,YAAL,EAAP;;AACF,WAAK,QAAL;AACE,eAAO,KAAKC,WAAL,EAAP;;AACF,WAAK,SAAL;AACE,eAAO,KAAKC,YAAL,EAAP;;AACF,WAAK,MAAL;AACA,WAAK,mBAAL;AACA,WAAK,yBAAL;AACE,eAAO,KAAKC,SAAL,CAAe;AAAChC,UAAAA,KAAK,EAAE;AAAR,SAAf,CAAP;;AACF,WAAK,WAAL;AACE,eAAO,KAAKW,SAAL,CAAe,KAAKd,IAAL,GAAYJ,GAAZ,CAAgBC,KAAhB,CAAsBF,IAArC,EAA2C,KAAKa,aAAL,EAA3C,CAAP;;AACF,WAAK,KAAL;AACE,eAAO,KAAK4B,QAAL,EAAP;;AACF,WAAK,MAAL;AACE,eAAO,KAAKC,SAAL,EAAP;;AACF,WAAK,MAAL;AACE,eAAO,KAAKC,SAAL,EAAP;;AACF,WAAK,WAAL;AACE,eAAO,KAAKC,cAAL,EAAP;;AACF,WAAK,IAAL;AACE,eAAO,KAAKC,gBAAL,EAAP;;AACF,WAAK,OAAL;AACE,eAAO,KAAKC,UAAL,EAAP;;AACF,WAAK,MAAL;AACE,eAAO,KAAKC,SAAL,EAAP;;AACF,WAAK,eAAL;AACE,eAAO,KAAKC,kBAAL,EAAP;;AACF,WAAK,OAAL;AACE,eAAO,KAAKC,UAAL,EAAP;;AACF,WAAK,IAAL;AACA,WAAK,OAAL;AACE,YAAI,CAAC,KAAK5C,IAAL,GAAYJ,GAAZ,CAAgBC,KAArB,EAA4B;AAC5B,aAAKrB,MAAL,CAAYqE,KAAZ,CAAkB;AAChBxC,UAAAA,IAAI,EAAE,KADU;AAEhByC,UAAAA,GAAG,EAAE,KAFW;AAGhBlD,UAAAA,GAAG,EAAE,KAAKI,IAAL,GAAYJ,GAHD;AAIhBX,UAAAA,QAAQ,EAAE,KAAKA;AAJC,SAAlB;AAMA,eAAO,KAAKyB,SAAL,EAAP;;AACF;AACE,YAAIqC,YAAY,GAAG,KAAKhC,SAAL,CAAe,kBAAf,EAAmC,KAAKf,IAAL,EAAnC,CAAnB;AACA,YAAI+C,YAAJ,EAAkB,OAAOA,YAAP;AAClB,aAAK7E,KAAL,CAAW,eAAX,EAA4B,uBAAuB,KAAK8B,IAAL,GAAYK,IAAnC,GAA0C,GAAtE,EAA2E,KAAKL,IAAL,EAA3E;AA1DJ;AA4DD,GA9NgB;AAgOjBoC,EAAAA,QAAQ,EAAE,YAAW;AACnB,SAAKrC,OAAL;AACA,WAAO,KAAKiD,cAAL,EAAP;AACD,GAnOgB;;AAqOjB;AACF;AACA;AAEEb,EAAAA,SAAS,EAAE,UAAS1D,OAAT,EAAiB;AAC1B,QAAIwE,IAAI,GAAG,EAAX;AACA,QAAIC,MAAM,GAAG,KAAKlD,IAAL,GAAYJ,GAAZ,CAAgBC,KAAhB,CAAsBF,IAAnC;AACA,QAAIwD,OAAO,GAAG,KAAKnD,IAAL,EAAd;;AACAoD,IAAAA,IAAI,EACF,OAAO,IAAP,EAAa;AACX,cAAQD,OAAO,CAAC9C,IAAhB;AACE,aAAK,MAAL;AACE,cAAIY,GAAG,GAAG,KAAKlB,OAAL,EAAV;AACAkD,UAAAA,IAAI,CAACtC,IAAL,CAAU;AACRN,YAAAA,IAAI,EAAE,MADE;AAERyC,YAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFD;AAGRnD,YAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHZ;AAIRG,YAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJd;AAKRb,YAAAA,QAAQ,EAAE,KAAKA;AALP,WAAV;AAOA;;AACF,aAAK,mBAAL;AACE,cAAIgC,GAAG,GAAG,KAAKlB,OAAL,EAAV;AACAkD,UAAAA,IAAI,CAACtC,IAAL,CAAU;AACRN,YAAAA,IAAI,EAAE,MADE;AAERyC,YAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFD;AAGRO,YAAAA,MAAM,EAAEpC,GAAG,CAACoC,MAHJ;AAIRC,YAAAA,UAAU,EAAErC,GAAG,CAACqC,UAAJ,KAAmB,KAJvB;AAKRC,YAAAA,QAAQ,EAAE,IALF;AAMR5D,YAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IANZ;AAORG,YAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAPd;AAQRb,YAAAA,QAAQ,EAAE,KAAKA;AARP,WAAV;AAUA;;AACF,aAAK,SAAL;AACE,cAAI,CAACR,OAAD,IAAY,CAACA,OAAO,CAAC0B,KAAzB,EAAgC,MAAMiD,IAAN;AAChC,cAAInC,GAAG,GAAG,KAAKlB,OAAL,EAAV;AACA,cAAIyD,QAAQ,GAAG,KAAKxD,IAAL,GAAYK,IAA3B;;AACA,cAAImD,QAAQ,KAAK,MAAb,IAAuBA,QAAQ,KAAK,mBAAxC,EAA6D;AAC3DP,YAAAA,IAAI,CAACtC,IAAL,CAAU;AACRN,cAAAA,IAAI,EAAE,MADE;AAERyC,cAAAA,GAAG,EAAE,IAFG;AAGRnD,cAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHZ;AAIRG,cAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJd;AAKRb,cAAAA,QAAQ,EAAE,KAAKA;AALP,aAAV;AAOD;;AACD;;AACF,aAAK,yBAAL;AACE,eAAKc,OAAL;AACAkD,UAAAA,IAAI,CAACtC,IAAL,CAAU,KAAKD,SAAL,EAAV;AACA,eAAKE,MAAL,CAAY,uBAAZ;AACA;;AACF;AACE,cAAImC,YAAY,GAAG,KAAKhC,SAAL,CAAe,YAAf,EAA6BoC,OAA7B,EAAsCF,IAAtC,CAAnB;AACA,cAAIF,YAAJ,EAAkB;AAClB,gBAAMK,IAAN;AA9CJ;;AAgDAD,MAAAA,OAAO,GAAG,KAAKnD,IAAL,EAAV;AACD;;AACH,QAAIiD,IAAI,CAAC5B,MAAL,KAAgB,CAApB,EAAuB,OAAO4B,IAAI,CAAC,CAAD,CAAX,CAAvB,KACK,OAAO,KAAKnC,SAAL,CAAeoC,MAAf,EAAuBD,IAAvB,CAAP;AACN,GAnSgB;AAqSjBzC,EAAAA,aAAa,EAAE,YAAY;AACzB,QAAIF,KAAK,GAAG,EAAZ;AACA,QAAImD,WAAW,GAAG,IAAlB;;AACJL,IAAAA,IAAI,EACA,OAAO,IAAP,EAAa;AACX,cAAQ,KAAKpD,IAAL,GAAYK,IAApB;AACE,aAAK,WAAL;AACE,cAAIqD,IAAI,GAAG,KAAK3D,OAAL,EAAX;;AACA,cAAI,CAAC0D,WAAL,EAAkB;AAChBA,YAAAA,WAAW,GAAG;AACZpD,cAAAA,IAAI,EAAE,MADM;AAEZyC,cAAAA,GAAG,EAAEY,IAAI,CAACZ,GAFE;AAGZ7D,cAAAA,QAAQ,EAAE,KAAKA,QAHH;AAIZU,cAAAA,IAAI,EAAE+D,IAAI,CAAC9D,GAAL,CAASC,KAAT,CAAeF,IAJT;AAKZG,cAAAA,MAAM,EAAE4D,IAAI,CAAC9D,GAAL,CAASC,KAAT,CAAeC,MALX;AAMZ6D,cAAAA,MAAM,EAAE;AANI,aAAd;AAQArD,YAAAA,KAAK,CAACK,IAAN,CAAW8C,WAAX;AACD,WAVD,MAUO;AACLA,YAAAA,WAAW,CAACX,GAAZ,IAAmB,OAAOY,IAAI,CAACZ,GAA/B;AACD;;AACD;;AACF,aAAK,QAAL;AACE,cAAI3C,KAAK,GAAG,KAAKA,KAAL,EAAZ;AACAA,UAAAA,KAAK,CAACG,KAAN,CAAYsD,OAAZ,CAAoB,UAAUC,IAAV,EAAgB;AAClC,gBAAIA,IAAI,CAACF,MAAT,EAAiB;AACf,kBAAI,CAACF,WAAL,EAAkB;AAChBA,gBAAAA,WAAW,GAAGI,IAAd;AACAvD,gBAAAA,KAAK,CAACK,IAAN,CAAW8C,WAAX;AACD,eAHD,MAGO;AACLA,gBAAAA,WAAW,CAACX,GAAZ,IAAmB,OAAOe,IAAI,CAACf,GAA/B;AACD;AACF,aAPD,MAOO;AACLW,cAAAA,WAAW,GAAG,IAAd;AACAnD,cAAAA,KAAK,CAACK,IAAN,CAAWkD,IAAX;AACD;AACF,WAZD;AAaA;;AACF,aAAK,MAAL;AACEJ,UAAAA,WAAW,GAAG,IAAd;AACAnD,UAAAA,KAAK,CAACK,IAAN,CAAW,KAAK2B,SAAL,CAAe,IAAf,CAAX;AACA;;AACF,aAAK,SAAL;AACE,eAAKvC,OAAL;AACA;;AACF;AACE,gBAAMqD,IAAN;AAzCJ;AA2CD;;AACD,WAAO9C,KAAP;AACD,GAvVgB;;AAyVjB;AACF;AACA;AACA;AAEEwD,EAAAA,mBAAmB,EAAE,YAAU;AAC7B,QAAI7C,GAAG,GAAG,KAAKJ,MAAL,CAAY,GAAZ,CAAV;;AACA,QAAII,GAAJ,EAAS;AACP,UAAIR,IAAI,GAAG,KAAKC,SAAL,EAAX;AACA,aAAOD,IAAI,CAACJ,IAAL,KAAc,OAAd,GAAwBI,IAAxB,GAA+B,KAAKK,SAAL,CAAeG,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA7B,EAAmC,CAACc,IAAD,CAAnC,CAAtC;AACD,KAHD,MAGO;AACL,aAAO,KAAKN,KAAL,EAAP;AACD;AACF,GAtWgB;;AAwWjB;AACF;AACA;AAEE0B,EAAAA,SAAS,EAAE,YAAU;AACnB,QAAIZ,GAAG,GAAG,KAAKL,MAAL,CAAY,MAAZ,CAAV;AACA,QAAIiD,IAAI,GAAG;AACTxD,MAAAA,IAAI,EAAE,MADG;AAETI,MAAAA,IAAI,EAAEQ,GAAG,CAAC6B,GAFD;AAGTnD,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHX;AAITG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJb;AAKTb,MAAAA,QAAQ,EAAE,KAAKA;AALN,KAAX;AAQA,QAAIkB,KAAK,GAAG,KAAKC,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAAd,GAAqB,CAArC,CAAZ;AACA,SAAKiB,MAAL,CAAY,QAAZ;;AACA,WAAO,aAAa,KAAKZ,IAAL,GAAYK,IAAhC,EAAsC;AACpC,cAAQ,KAAKL,IAAL,GAAYK,IAApB;AACE,aAAK,SAAL;AACA,aAAK,SAAL;AACE,eAAKN,OAAL;AACA;;AACF,aAAK,MAAL;AACEI,UAAAA,KAAK,CAACG,KAAN,CAAYK,IAAZ,CAAiB,KAAKoD,SAAL,EAAjB;AACA;;AACF,aAAK,SAAL;AACE5D,UAAAA,KAAK,CAACG,KAAN,CAAYK,IAAZ,CAAiB,KAAKqD,YAAL,EAAjB;AACA;;AACF;AACE,cAAIjB,YAAY,GAAG,KAAKhC,SAAL,CAAe,YAAf,EAA6B,KAAKf,IAAL,EAA7B,EAA0CG,KAA1C,CAAnB;AACA,cAAI4C,YAAJ,EAAkB;AAClB,eAAK7E,KAAL,CAAW,eAAX,EAA4B,uBAAuB,KAAK8B,IAAL,GAAYK,IAAnC,GACV,4CADlB,EACgE,KAAKL,IAAL,EADhE;AAdJ;AAiBD;;AACD,SAAKY,MAAL,CAAY,SAAZ;AAEAiD,IAAAA,IAAI,CAAC1D,KAAL,GAAaA,KAAb;AAEA,WAAO0D,IAAP;AACD,GAhZgB;;AAkZjB;AACF;AACA;AAEEE,EAAAA,SAAS,EAAE,YAAU;AACnB,QAAI9C,GAAG,GAAG,KAAKL,MAAL,CAAY,MAAZ,CAAV;;AACA,QAAI,KAAKZ,IAAL,GAAYK,IAAZ,KAAqB,SAAzB,EAAoC;AAClC,aAAO;AACLA,QAAAA,IAAI,EAAE,MADD;AAELI,QAAAA,IAAI,EAAEQ,GAAG,CAAC6B,GAFL;AAGL3C,QAAAA,KAAK,EAAE,KAAK2D,mBAAL,EAHF;AAILG,QAAAA,KAAK,EAAE,KAJF;AAKLtE,QAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IALf;AAMLG,QAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MANjB;AAOLb,QAAAA,QAAQ,EAAE,KAAKA;AAPV,OAAP;AASD,KAVD,MAUO;AACL,aAAO;AACLoB,QAAAA,IAAI,EAAE,MADD;AAELI,QAAAA,IAAI,EAAEQ,GAAG,CAAC6B,GAFL;AAGLmB,QAAAA,KAAK,EAAE,KAHF;AAILtE,QAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAJf;AAKLG,QAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MALjB;AAMLb,QAAAA,QAAQ,EAAE,KAAKA;AANV,OAAP;AAQD;AACF,GA5agB;;AA8ajB;AACF;AACA;AAEE+E,EAAAA,YAAY,EAAE,YAAU;AACtB,QAAI/C,GAAG,GAAG,KAAKL,MAAL,CAAY,SAAZ,CAAV;AACA,WAAO;AACLP,MAAAA,IAAI,EAAE,MADD;AAELI,MAAAA,IAAI,EAAE,SAFD;AAGLN,MAAAA,KAAK,EAAE,KAAK2D,mBAAL,EAHF;AAILG,MAAAA,KAAK,EAAE,KAJF;AAKLtE,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IALf;AAMLG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MANjB;AAOLb,MAAAA,QAAQ,EAAE,KAAKA;AAPV,KAAP;AASD,GA7bgB;;AA+bjB;AACF;AACA;AAEEqD,EAAAA,SAAS,EAAE,UAAS4B,OAAT,EAAiB;AAC1B,QAAIjD,GAAG,GAAG,KAAKL,MAAL,CAAY,MAAZ,CAAV;AACA7C,IAAAA,MAAM,CAAC,OAAOkD,GAAG,CAACqC,UAAX,KAA0B,SAA3B,EAAsC,mDAAtC,CAAN;AACA,QAAIO,IAAI,GAAG;AACTxD,MAAAA,IAAI,EAAE,MADG;AAETyC,MAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFA;AAGTO,MAAAA,MAAM,EAAEpC,GAAG,CAACoC,MAHH;AAITC,MAAAA,UAAU,EAAErC,GAAG,CAACqC,UAAJ,KAAmB,KAJtB;AAKTC,MAAAA,QAAQ,EAAE,CAAC,CAACW,OALH;AAMTvE,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IANX;AAOTG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAPb;AAQTb,MAAAA,QAAQ,EAAE,KAAKA;AARN,KAAX,CAH0B,CAa1B;;AACA,QAAI4E,IAAI,CAACf,GAAL,CAASqB,KAAT,CAAe,SAAf,CAAJ,EAA+BN,IAAI,CAACI,KAAL,GAAa,KAAb;AAE/B,QAAIC,OAAJ,EAAa,OAAOL,IAAP;AAEb,QAAI1D,KAAJ,CAlB0B,CAoB1B;;AACAA,IAAAA,KAAK,GAAG,YAAY,KAAKH,IAAL,GAAYK,IAAhC;;AACA,QAAIF,KAAJ,EAAW;AACT,UAAIc,GAAG,CAACoC,MAAR,EAAgB;AACd,aAAKnF,KAAL,CAAW,wBAAX,EAAqC,kDAArC,EAAyF,KAAK8B,IAAL,EAAzF;AACD;;AACD6D,MAAAA,IAAI,CAAC1D,KAAL,GAAa,KAAKA,KAAL,EAAb;AACD;;AAED,WAAO0D,IAAP;AACD,GAjegB;AAkejBrB,EAAAA,gBAAgB,EAAE,YAAU;AAC1B,QAAIvB,GAAG,GAAG,KAAKL,MAAL,CAAY,IAAZ,CAAV;AACA,QAAIiD,IAAI,GAAG;AACTxD,MAAAA,IAAI,EAAE,aADG;AAET+D,MAAAA,IAAI,EAAEnD,GAAG,CAAC6B,GAFD;AAGTuB,MAAAA,UAAU,EAAE,KAAKjE,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAHH;AAIT2E,MAAAA,SAAS,EAAE,IAJF;AAKT3E,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IALX;AAMTG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MANb;AAOTb,MAAAA,QAAQ,EAAE,KAAKA;AAPN,KAAX,CAF0B,CAY1B;;AACA,QAAI,YAAY,KAAKe,IAAL,GAAYK,IAA5B,EAAkC;AAChCwD,MAAAA,IAAI,CAACQ,UAAL,GAAkB,KAAKlE,KAAL,EAAlB;AACD;;AAED,QAAIsD,WAAW,GAAGI,IAAlB;;AACA,WAAO,IAAP,EAAa;AACX,UAAI,KAAK7D,IAAL,GAAYK,IAAZ,KAAqB,SAAzB,EAAoC;AAClC,aAAKO,MAAL,CAAY,SAAZ;AACD,OAFD,MAEO,IAAI,KAAKZ,IAAL,GAAYK,IAAZ,KAAqB,SAAzB,EAAoC;AACzCY,QAAAA,GAAG,GAAG,KAAKL,MAAL,CAAY,SAAZ,CAAN;AACA6C,QAAAA,WAAW,GACTA,WAAW,CAACa,SAAZ,GAAwB;AACtBjE,UAAAA,IAAI,EAAE,aADgB;AAEtB+D,UAAAA,IAAI,EAAEnD,GAAG,CAAC6B,GAFY;AAGtBuB,UAAAA,UAAU,EAAE,KAAKjE,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAHU;AAItB2E,UAAAA,SAAS,EAAE,IAJW;AAKtB3E,UAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IALE;AAMtBG,UAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MANA;AAOtBb,UAAAA,QAAQ,EAAE,KAAKA;AAPO,SAD1B;;AAWA,YAAI,YAAY,KAAKe,IAAL,GAAYK,IAA5B,EAAkC;AAChCoD,UAAAA,WAAW,CAACY,UAAZ,GAAyB,KAAKlE,KAAL,EAAzB;AACD;AACF,OAhBM,MAgBA,IAAI,KAAKH,IAAL,GAAYK,IAAZ,KAAqB,MAAzB,EAAiC;AACtC,aAAKO,MAAL,CAAY,MAAZ;;AACA,YAAI,KAAKZ,IAAL,GAAYK,IAAZ,KAAqB,QAAzB,EAAmC;AACjCoD,UAAAA,WAAW,CAACa,SAAZ,GAAwB,KAAKnE,KAAL,EAAxB;AACD;;AACD;AACD,OANM,MAMA;AACL;AACD;AACF;;AAED,WAAO0D,IAAP;AACD,GAnhBgB;AAohBjBpB,EAAAA,UAAU,EAAE,YAAU;AACpB,QAAIxB,GAAG,GAAG,KAAKL,MAAL,CAAY,OAAZ,CAAV;AACA,QAAIiD,IAAI,GAAG;AACTxD,MAAAA,IAAI,EAAE,OADG;AAET+D,MAAAA,IAAI,EAAEnD,GAAG,CAAC6B,GAFD;AAGTnD,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHX;AAITG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJb;AAKTb,MAAAA,QAAQ,EAAE,KAAKA;AALN,KAAX,CAFoB,CAUpB;;AACA,QAAI,YAAY,KAAKe,IAAL,GAAYK,IAA5B,EAAkC;AAChCwD,MAAAA,IAAI,CAAC1D,KAAL,GAAa,KAAKA,KAAL,EAAb;AACD,KAFD,MAEO;AACL0D,MAAAA,IAAI,CAAC1D,KAAL,GAAa,KAAKC,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAAb;AACD;;AAED,WAAOkE,IAAP;AACD,GAtiBgB;;AAwiBjB;AACF;AACA;AAEEtB,EAAAA,cAAc,EAAE,YAAU;AACxB,QAAItB,GAAG,GAAG,KAAKL,MAAL,CAAY,WAAZ,CAAV;AACA,QAAIjB,IAAI,GAAGsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAAzB;AACA,QAAIG,MAAM,GAAGmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAA3B;AACA,QAAIyE,IAAI,GAAG,KAAKvE,IAAL,EAAX;AACA,QAAI0D,IAAI,GAAG,EAAX;;AACA,QAAIa,IAAI,CAAClE,IAAL,KAAc,qBAAlB,EAAyC;AACvC,WAAKN,OAAL;;AACA,aAAO,KAAKC,IAAL,GAAYK,IAAZ,KAAqB,mBAA5B,EAAiD;AAC/CY,QAAAA,GAAG,GAAG,KAAKlB,OAAL,EAAN;;AACA,gBAAQkB,GAAG,CAACZ,IAAZ;AACE,eAAK,MAAL;AACEqD,YAAAA,IAAI,IAAIzC,GAAG,CAAC6B,GAAZ;AACA;;AACF,eAAK,SAAL;AACEY,YAAAA,IAAI,IAAI,IAAR;AACA;;AACF;AACE,gBAAIX,YAAY,GAAG,KAAKhC,SAAL,CAAe,iBAAf,EAAkCE,GAAlC,EAAuCA,GAAvC,CAAnB;;AACA,gBAAI8B,YAAJ,EAAkB;AAChBW,cAAAA,IAAI,IAAIX,YAAR;AACA;AACD;;AACD,iBAAK7E,KAAL,CAAW,eAAX,EAA4B,4BAA4B+C,GAAG,CAACZ,IAA5D,EAAkEY,GAAlE;AAbJ;AAeD;;AACD,WAAKlB,OAAL;AACD;;AACD,WAAO;AACLM,MAAAA,IAAI,EAAE,MADD;AAELyC,MAAAA,GAAG,EAAEY,IAFA;AAGLL,MAAAA,MAAM,EAAE,KAHH;AAILC,MAAAA,UAAU,EAAE,KAJP;AAKLC,MAAAA,QAAQ,EAAE,KALL;AAML5D,MAAAA,IAAI,EAAEA,IAND;AAOLG,MAAAA,MAAM,EAAEA,MAPH;AAQLb,MAAAA,QAAQ,EAAE,KAAKA;AARV,KAAP;AAUD,GAllBgB;;AAmlBjB;AACF;AACA;AAEEiD,EAAAA,YAAY,EAAE,YAAU;AACtB,QAAIjB,GAAG,GAAG,KAAKL,MAAL,CAAY,SAAZ,CAAV;AACA,QAAIT,KAAJ;;AACA,QAAIA,KAAK,GAAG,KAAK6C,cAAL,EAAZ,EAAmC;AACjC,aAAO;AACL3C,QAAAA,IAAI,EAAE,cADD;AAELyC,QAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFJ;AAGL3C,QAAAA,KAAK,EAAEA,KAHF;AAILkD,QAAAA,MAAM,EAAEpC,GAAG,CAACoC,MAJP;AAKL1D,QAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IALf;AAMLG,QAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MANjB;AAOLb,QAAAA,QAAQ,EAAE,KAAKA;AAPV,OAAP;AASD,KAVD,MAUO;AACL,aAAO;AACLoB,QAAAA,IAAI,EAAE,SADD;AAELyC,QAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFJ;AAGLO,QAAAA,MAAM,EAAEpC,GAAG,CAACoC,MAHP;AAIL1D,QAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAJf;AAKLG,QAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MALjB;AAMLb,QAAAA,QAAQ,EAAE,KAAKA;AANV,OAAP;AAQD;AACF,GA9mBgB;;AAgnBjB;AACF;AACA;AAEE+C,EAAAA,YAAY,EAAE,YAAU;AACtB,QAAIf,GAAG,GAAG,KAAKL,MAAL,CAAY,SAAZ,CAAV;AACA,WAAO;AACLP,MAAAA,IAAI,EAAE,SADD;AAELyC,MAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFJ;AAGLnD,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHf;AAILG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJjB;AAKLb,MAAAA,QAAQ,EAAE,KAAKA;AALV,KAAP;AAOD,GA7nBgB;AA+nBjBuF,EAAAA,kBAAkB,EAAE,YAAW;AAC7B,QAAIvD,GAAG,GAAG,KAAKL,MAAL,CAAY,QAAZ,CAAV;AACA,QAAI6D,KAAK,GAAG,EAAZ;;AAEA,QAAI,KAAKzE,IAAL,GAAYK,IAAZ,KAAqB,kBAAzB,EAA6C;AAC3CoE,MAAAA,KAAK,GAAG,KAAKA,KAAL,EAAR;AACD;;AAED,WAAO;AACLpE,MAAAA,IAAI,EAAE,eADD;AAELqE,MAAAA,IAAI,EAAEzD,GAAG,CAAC6B,GAFL;AAGL2B,MAAAA,KAAK,EAAEA,KAHF;AAIL9E,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAJf;AAKLG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MALjB;AAMLb,MAAAA,QAAQ,EAAE,KAAKA;AANV,KAAP;AAQD,GA/oBgB;;AAipBjB;AACF;AACA;AAEEgD,EAAAA,WAAW,EAAE,YAAU;AACrB,QAAIhB,GAAG,GAAG,KAAKL,MAAL,CAAY,QAAZ,CAAV;AACA,QAAIT,KAAJ;AAAA,QAAWsE,KAAK,GAAG,EAAnB;;AAEA,QAAI,KAAKzE,IAAL,GAAYK,IAAZ,KAAqB,kBAAzB,EAA6C;AAC3CoE,MAAAA,KAAK,GAAG,KAAKA,KAAL,EAAR;AACD;;AAED,QAAI,KAAKzE,IAAL,GAAYK,IAAZ,KAAqB,MAAzB,EAAiC;AAC/B,UAAIsE,SAAS,GAAG,KAAK5E,OAAL,EAAhB;AACAI,MAAAA,KAAK,GAAG,KAAKW,SAAL,CAAe6D,SAAS,CAAC/E,GAAV,CAAcC,KAAd,CAAoBF,IAAnC,EAAyC,CAC/C;AACEU,QAAAA,IAAI,EAAE,MADR;AAEEyC,QAAAA,GAAG,EAAE6B,SAAS,CAAC7B,GAFjB;AAGEnD,QAAAA,IAAI,EAAEgF,SAAS,CAAC/E,GAAV,CAAcC,KAAd,CAAoBF,IAH5B;AAIEG,QAAAA,MAAM,EAAE6E,SAAS,CAAC/E,GAAV,CAAcC,KAAd,CAAoBC,MAJ9B;AAKEb,QAAAA,QAAQ,EAAE,KAAKA;AALjB,OAD+C,CAAzC,CAAR;AASD,KAXD,MAWO,IAAI,KAAKe,IAAL,GAAYK,IAAZ,KAAqB,QAAzB,EAAmC;AACxCF,MAAAA,KAAK,GAAG,KAAKW,SAAL,CAAeG,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA7B,EAAmC,CAAC,KAAKsC,WAAL,EAAD,CAAnC,CAAR;AACD,KAFM,MAEA;AACL9B,MAAAA,KAAK,GAAG,KAAK6C,cAAL,MAAyB,KAAK5C,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAAjC;AACD;;AAED,WAAO;AACLU,MAAAA,IAAI,EAAE,QADD;AAELqE,MAAAA,IAAI,EAAEzD,GAAG,CAAC6B,GAFL;AAGL3C,MAAAA,KAAK,EAAEA,KAHF;AAILsE,MAAAA,KAAK,EAAEA,KAJF;AAKL9E,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IALf;AAMLG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MANjB;AAOLb,MAAAA,QAAQ,EAAE,KAAKA;AAPV,KAAP;AASD,GAvrBgB;;AAyrBjB;AACF;AACA;AAEEoD,EAAAA,SAAS,EAAE,YAAU;AACnB,QAAIpB,GAAG,GAAG,KAAKL,MAAL,CAAY,MAAZ,CAAV;AACA,QAAIiD,IAAI,GAAG;AACTxD,MAAAA,IAAI,EAAE,MADG;AAETuE,MAAAA,GAAG,EAAE3D,GAAG,CAAC1B,IAFA;AAGTuD,MAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAHA;AAIT+B,MAAAA,GAAG,EAAE5D,GAAG,CAAC4D,GAJA;AAKT1E,MAAAA,KAAK,EAAE,KAAKA,KAAL,EALE;AAMTR,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IANX;AAOTG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAPb;AAQTb,MAAAA,QAAQ,EAAE,KAAKA;AARN,KAAX;;AAUA,QAAI,KAAKe,IAAL,GAAYK,IAAZ,IAAoB,MAAxB,EAAgC;AAC9B,WAAKN,OAAL;AACA8D,MAAAA,IAAI,CAACS,SAAL,GAAiB,KAAKnE,KAAL,EAAjB;AACD;;AACD,WAAO0D,IAAP;AACD,GA9sBgB;;AAgtBjB;AACF;AACA;AAEE/B,EAAAA,YAAY,EAAE,YAAU;AACtB,QAAIb,GAAG,GAAG,KAAKL,MAAL,CAAY,SAAZ,CAAV;AACA,QAAIkE,IAAI,GAAG,KAAKlE,MAAL,CAAY,MAAZ,CAAX;AACA,WAAO;AACLP,MAAAA,IAAI,EAAE,SADD;AAEL0E,MAAAA,IAAI,EAAE;AACJ1E,QAAAA,IAAI,EAAE,eADF;AAEJyE,QAAAA,IAAI,EAAEA,IAAI,CAAChC,GAAL,CAASkC,IAAT,EAFF;AAGJrF,QAAAA,IAAI,EAAEmF,IAAI,CAAClF,GAAL,CAASC,KAAT,CAAeF,IAHjB;AAIJG,QAAAA,MAAM,EAAEgF,IAAI,CAAClF,GAAL,CAASC,KAAT,CAAeC,MAJnB;AAKJb,QAAAA,QAAQ,EAAE,KAAKA;AALX,OAFD;AASLU,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IATf;AAULG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAVjB;AAWLb,MAAAA,QAAQ,EAAE,KAAKA;AAXV,KAAP;AAaD,GApuBgB;;AAsuBjB;AACF;AACA;AAEE0C,EAAAA,UAAU,EAAE,YAAU;AACpB,QAAIV,GAAG,GAAG,KAAKL,MAAL,CAAY,OAAZ,CAAV;AAEA,QAAIiD,IAAI,GAAG,YAAY,KAAK7D,IAAL,GAAYK,IAAxB,GAA+B,KAAKF,KAAL,EAA/B,GAA8C,KAAKC,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAAzD;AACAkE,IAAAA,IAAI,CAACxD,IAAL,GAAY,YAAZ;AACAwD,IAAAA,IAAI,CAACa,IAAL,GAAYzD,GAAG,CAAC6B,GAAJ,CAAQkC,IAAR,EAAZ;AACAnB,IAAAA,IAAI,CAACoB,IAAL,GAAYhE,GAAG,CAACgE,IAAhB;AACApB,IAAAA,IAAI,CAAClE,IAAL,GAAYsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA1B;AACAkE,IAAAA,IAAI,CAAC/D,MAAL,GAAcmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAA5B;AAEA,WAAO+D,IAAP;AACD,GArvBgB;AAuvBjBjC,EAAAA,eAAe,EAAE,YAAY;AAC3B,QAAIX,GAAG,GAAG,KAAKL,MAAL,CAAY,aAAZ,CAAV;;AACA,QAAI,CAAC,KAAKzB,OAAV,EAAmB;AACjB,WAAKjB,KAAL,CAAW,qBAAX,EAAkC,mEAAlC,EAAuG+C,GAAvG;AACD;;AACD,WAAO;AACLZ,MAAAA,IAAI,EAAE,YADD;AAELV,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAFf;AAGLG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAHjB;AAILb,MAAAA,QAAQ,EAAE,KAAKA;AAJV,KAAP;AAMD,GAlwBgB;AAowBjB2D,EAAAA,UAAU,EAAE,YAAW;AACrB,QAAI3B,GAAG,GAAG,KAAKL,MAAL,CAAY,OAAZ,CAAV;AACA,WAAO;AACLP,MAAAA,IAAI,EAAE,YADD;AAELV,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAFf;AAGLG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAHjB;AAILb,MAAAA,QAAQ,EAAE,KAAKA;AAJV,KAAP;AAMD,GA5wBgB;;AA8wBjB;AACF;AACA;AAEE8C,EAAAA,YAAY,EAAE,YAAU;AACtB,QAAId,GAAG,GAAG,KAAKL,MAAL,CAAY,SAAZ,CAAV;AACA,QAAIiD,IAAI,GAAG;AACTxD,MAAAA,IAAI,EAAE,SADG;AAET0E,MAAAA,IAAI,EAAE;AACJ1E,QAAAA,IAAI,EAAE,eADF;AAEJpB,QAAAA,QAAQ,EAAE,KAAKA;AAFX,OAFG;AAMTU,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IANX;AAOTG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAPb;AAQTb,MAAAA,QAAQ,EAAE,KAAKA;AARN,KAAX;AAUA,QAAIiG,OAAO,GAAG,EAAd;;AACA,WAAO,KAAKlF,IAAL,GAAYK,IAAZ,KAAqB,QAA5B,EAAsC;AACpC6E,MAAAA,OAAO,CAACvE,IAAR,CAAa,KAAK6D,kBAAL,EAAb;AACD;;AACD,QAAIM,IAAI,GAAG,KAAKlE,MAAL,CAAY,MAAZ,CAAX;AAEAiD,IAAAA,IAAI,CAACkB,IAAL,CAAUD,IAAV,GAAiBA,IAAI,CAAChC,GAAL,CAASkC,IAAT,EAAjB;AACAnB,IAAAA,IAAI,CAACkB,IAAL,CAAUpF,IAAV,GAAiBmF,IAAI,CAAClF,GAAL,CAASC,KAAT,CAAeF,IAAhC;AACAkE,IAAAA,IAAI,CAACkB,IAAL,CAAUjF,MAAV,GAAmBgF,IAAI,CAAClF,GAAL,CAASC,KAAT,CAAeC,MAAlC;;AAEA,QAAI,CAAC,UAAUsE,IAAV,CAAeP,IAAI,CAACkB,IAAL,CAAUD,IAAzB,KAAkC,SAASV,IAAT,CAAcP,IAAI,CAACkB,IAAL,CAAUD,IAAxB,CAAnC,KAAqE,CAACI,OAAO,CAAC7D,MAAlF,EAA0F;AACxFwC,MAAAA,IAAI,CAAC1D,KAAL,GAAa,YAAY,KAAKH,IAAL,GAAYK,IAAxB,GAA+B,KAAKF,KAAL,EAA/B,GAA8C,KAAKC,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAA3D;;AACA,UAAI,UAAUyE,IAAV,CAAeP,IAAI,CAACkB,IAAL,CAAUD,IAAzB,CAAJ,EAAoC;AAClCK,QAAAA,OAAO,CAACC,IAAR,CACE,KAAKnG,QAAL,GAAgB,SAAhB,GAA4BgC,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA1C,GACA,sDADA,GACyDkE,IAAI,CAACkB,IAAL,CAAUD,IADnE,GACyE,IAF3E;AAID;AACF,KARD,MAQO;AACLjB,MAAAA,IAAI,CAACxD,IAAL,GAAY,YAAZ;AACAwD,MAAAA,IAAI,CAACqB,OAAL,GAAeA,OAAf;;AACA,UAAI,KAAKlF,IAAL,GAAYK,IAAZ,KAAqB,QAAzB,EAAmC;AACjC,aAAKnC,KAAL,CAAW,mBAAX,EAAgC,sCAAhC,EAAwE,KAAK8B,IAAL,EAAxE;AACD;AACF;;AACD,WAAO6D,IAAP;AACD,GAxzBgB;;AA0zBjB;AACF;AACA;AAEEnB,EAAAA,SAAS,EAAE,YAAU;AACnB,QAAIzB,GAAG,GAAG,KAAKL,MAAL,CAAY,MAAZ,CAAV;AACA,QAAI8D,IAAI,GAAGzD,GAAG,CAAC6B,GAAf;AACA,QAAIuC,IAAI,GAAGpE,GAAG,CAACoE,IAAf;AACA,QAAIC,KAAK,GAAG;AACVjF,MAAAA,IAAI,EAAE,OADI;AAEVqE,MAAAA,IAAI,EAAEA,IAFI;AAGVW,MAAAA,IAAI,EAAEA,IAHI;AAIVlF,MAAAA,KAAK,EAAE,KAAKC,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAJG;AAKV4F,MAAAA,IAAI,EAAE,IALI;AAMVd,MAAAA,KAAK,EAAE,EANG;AAOVe,MAAAA,eAAe,EAAE,EAPP;AAQV7F,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IARV;AASVG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MATZ;AAUVb,MAAAA,QAAQ,EAAE,KAAKA;AAVL,KAAZ;AAaA,SAAKwG,GAAL,CAASH,KAAT;;AACA,QAAIA,KAAK,CAAC/F,IAAV,EAAgB;AACd+F,MAAAA,KAAK,CAACnF,KAAN,CAAYG,KAAZ,CAAkBK,IAAlB,CAAuB2E,KAAK,CAAC/F,IAA7B;AACA,aAAO+F,KAAK,CAAC/F,IAAb;AACD;;AACD,QAAI+F,KAAK,CAACnF,KAAN,CAAYG,KAAZ,CAAkBe,MAAlB,KAA6B,CAAjC,EAAoCiE,KAAK,CAACnF,KAAN,GAAc,IAAd;AACpC,WAAOmF,KAAP;AACD,GAt1BgB;;AAw1BjB;AACF;AACA;AAEE5D,EAAAA,UAAU,EAAE,YAAU;AACpB,QAAIT,GAAG,GAAG,KAAKL,MAAL,CAAY,OAAZ,CAAV;AACA,QAAI8D,IAAI,GAAGzD,GAAG,CAAC6B,GAAf;AACA,QAAIuC,IAAI,GAAGpE,GAAG,CAACoE,IAAf;;AAEA,QAAI,YAAY,KAAKrF,IAAL,GAAYK,IAA5B,EAAkC;AAChC,WAAKlB,OAAL;AACA,UAAImG,KAAK,GAAG;AACVjF,QAAAA,IAAI,EAAE,OADI;AAEVqE,QAAAA,IAAI,EAAEA,IAFI;AAGVW,QAAAA,IAAI,EAAEA,IAHI;AAIVlF,QAAAA,KAAK,EAAE,KAAKA,KAAL,EAJG;AAKVoF,QAAAA,IAAI,EAAE,KALI;AAMV5F,QAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IANV;AAOVG,QAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAPZ;AAQVb,QAAAA,QAAQ,EAAE,KAAKA;AARL,OAAZ;AAUA,WAAKE,OAAL;AACA,aAAOmG,KAAP;AACD,KAdD,MAcO;AACL,WAAKpH,KAAL,CAAW,oBAAX,EAAiC,WAAWwG,IAAX,GAAkB,wBAAnD,EAA6EzD,GAA7E;AACD;AACF,GAl3BgB;;AAo3BjB;AACF;AACA;AAEE+B,EAAAA,cAAc,EAAE,YAAU;AACxB,QAAI/B,GAAG,GAAG,KAAKJ,MAAL,CAAY,qBAAZ,CAAV;AACA,QAAI,CAACI,GAAL,EAAU;AACV,QAAId,KAAK,GAAG,KAAKC,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAAZ;;AACA,WAAO,KAAKK,IAAL,GAAYK,IAAZ,KAAqB,mBAA5B,EAAiD;AAC/C,UAAIY,GAAG,GAAG,KAAKlB,OAAL,EAAV;;AACA,cAAQkB,GAAG,CAACZ,IAAZ;AACE,aAAK,MAAL;AACEF,UAAAA,KAAK,CAACG,KAAN,CAAYK,IAAZ,CAAiB;AACfN,YAAAA,IAAI,EAAE,MADS;AAEfyC,YAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFM;AAGfnD,YAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHL;AAIfG,YAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJP;AAKfb,YAAAA,QAAQ,EAAE,KAAKA;AALA,WAAjB;AAOA;;AACF,aAAK,SAAL;AACEkB,UAAAA,KAAK,CAACG,KAAN,CAAYK,IAAZ,CAAiB;AACfN,YAAAA,IAAI,EAAE,MADS;AAEfyC,YAAAA,GAAG,EAAE,IAFU;AAGfnD,YAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHL;AAIfG,YAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJP;AAKfb,YAAAA,QAAQ,EAAE,KAAKA;AALA,WAAjB;AAOA;;AACF,aAAK,yBAAL;AACEkB,UAAAA,KAAK,CAACG,KAAN,CAAYK,IAAZ,CAAiB,KAAKD,SAAL,EAAjB;AACA,eAAKE,MAAL,CAAY,uBAAZ;AACA;;AACF,aAAK,mBAAL;AACET,UAAAA,KAAK,CAACG,KAAN,CAAYK,IAAZ,CAAiB;AACfN,YAAAA,IAAI,EAAE,MADS;AAEfyC,YAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFM;AAGfO,YAAAA,MAAM,EAAEpC,GAAG,CAACoC,MAHG;AAIfC,YAAAA,UAAU,EAAErC,GAAG,CAACqC,UAAJ,KAAmB,KAJhB;AAKfC,YAAAA,QAAQ,EAAE,IALK;AAMf5D,YAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IANL;AAOfG,YAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAPP;AAQfb,YAAAA,QAAQ,EAAE,KAAKA;AARA,WAAjB;AAUA;;AACF;AACE,cAAI8D,YAAY,GAAG,KAAKhC,SAAL,CAAe,iBAAf,EAAkCE,GAAlC,EAAuCd,KAAvC,EAA8Cc,GAA9C,CAAnB;AACA,cAAI8B,YAAJ,EAAkB;AAClB,eAAK7E,KAAL,CAAW,eAAX,EAA4B,4BAA4B+C,GAAG,CAACZ,IAA5D,EAAkEY,GAAlE;AAtCJ;AAwCD;;AACD,SAAKlB,OAAL;AACA,WAAOI,KAAP;AACD,GAz6BgB;;AA26BjB;AACF;AACA;AAEEA,EAAAA,KAAK,EAAE,YAAU;AACf,QAAIc,GAAG,GAAG,KAAKL,MAAL,CAAY,QAAZ,CAAV;AACA,QAAIT,KAAK,GAAG,KAAKC,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAAZ;;AACA,WAAO,aAAa,KAAKK,IAAL,GAAYK,IAAhC,EAAsC;AACpC,UAAI,aAAa,KAAKL,IAAL,GAAYK,IAA7B,EAAmC;AACjC,aAAKN,OAAL;AACD,OAFD,MAEO,IAAI,eAAe,KAAKC,IAAL,GAAYK,IAA/B,EAAqC;AAC1CF,QAAAA,KAAK,CAACG,KAAN,GAAcH,KAAK,CAACG,KAAN,CAAYC,MAAZ,CAAmB,KAAKC,aAAL,EAAnB,CAAd;AACD,OAFM,MAEA;AACL,YAAIC,IAAI,GAAG,KAAKC,SAAL,EAAX;;AACA,YAAID,IAAI,CAACJ,IAAL,KAAc,OAAlB,EAA2B;AACzBF,UAAAA,KAAK,CAACG,KAAN,GAAcH,KAAK,CAACG,KAAN,CAAYC,MAAZ,CAAmBE,IAAI,CAACH,KAAxB,CAAd;AACD,SAFD,MAEO;AACLH,UAAAA,KAAK,CAACG,KAAN,CAAYK,IAAZ,CAAiBF,IAAjB;AACD;AACF;AACF;;AACD,SAAKG,MAAL,CAAY,SAAZ;AACA,WAAOT,KAAP;AACD,GAl8BgB;;AAo8BjB;AACF;AACA;AAEEwC,EAAAA,kBAAkB,EAAE,YAAU;AAC5B,QAAI1B,GAAG,GAAG,KAAKlB,OAAL,EAAV;AACA,QAAI0F,GAAG,GAAG;AACRpF,MAAAA,IAAI,EAAE,iBADE;AAERI,MAAAA,IAAI,EAAEQ,GAAG,CAAC6B,GAFF;AAGR4C,MAAAA,WAAW,EAAE,KAHL;AAIRvF,MAAAA,KAAK,EAAE,KAAKC,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAJC;AAKR8E,MAAAA,KAAK,EAAE,EALC;AAMRe,MAAAA,eAAe,EAAE,EANT;AAORjC,MAAAA,QAAQ,EAAE,KAPF;AAQR5D,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IARZ;AASRG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MATd;AAURb,MAAAA,QAAQ,EAAE,KAAKA;AAVP,KAAV;AAaA,WAAO,KAAKwG,GAAL,CAASA,GAAT,EAAc;AAACE,MAAAA,kBAAkB,EAAE;AAArB,KAAd,CAAP;AACD,GAx9BgB;;AA09BjB;AACF;AACA;AAEElE,EAAAA,QAAQ,EAAE,YAAU;AAClB,QAAIR,GAAG,GAAG,KAAKlB,OAAL,EAAV;AACA,QAAI0F,GAAG,GAAG;AACRpF,MAAAA,IAAI,EAAE,KADE;AAERqE,MAAAA,IAAI,EAAEzD,GAAG,CAAC6B,GAFF;AAGR4C,MAAAA,WAAW,EAAE,KAHL;AAIRvF,MAAAA,KAAK,EAAE,KAAKC,UAAL,CAAgBa,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAA9B,CAJC;AAKR8E,MAAAA,KAAK,EAAE,EALC;AAMRe,MAAAA,eAAe,EAAE,EANT;AAORjC,MAAAA,QAAQ,EAAEpF,UAAU,CAACyH,OAAX,CAAmB3E,GAAG,CAAC6B,GAAvB,MAAgC,CAAC,CAPnC;AAQRnD,MAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IARZ;AASRG,MAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MATd;AAURb,MAAAA,QAAQ,EAAE,KAAKA;AAVP,KAAV;AAaA,WAAO,KAAKwG,GAAL,CAASA,GAAT,EAAc;AAACE,MAAAA,kBAAkB,EAAE;AAArB,KAAd,CAAP;AACD,GA9+BgB;;AAg/BjB;AACF;AACA;AAEEF,EAAAA,GAAG,EAAE,UAASA,GAAT,EAAchH,OAAd,EAAuB;AAC1B,QAAIoH,SAAS,GAAG,KAAhB;AACA,QAAIC,cAAc,GAAG,EAArB;AACA,QAAIH,kBAAkB,GAAGlH,OAAO,IAAIA,OAAO,CAACkH,kBAA5C,CAH0B,CAI1B;;AACAI,IAAAA,GAAG,EACD,OAAO,IAAP,EAAa;AACX,cAAQ,KAAK/F,IAAL,GAAYK,IAApB;AACE,aAAK,IAAL;AACA,aAAK,OAAL;AACE,cAAIY,GAAG,GAAG,KAAKlB,OAAL,EAAV;;AACA,cAAIkB,GAAG,CAACZ,IAAJ,KAAa,IAAjB,EAAuB;AACrB,gBAAIyF,cAAc,CAACF,OAAf,CAAuB,IAAvB,MAAiC,CAAC,CAAtC,EAAyC;AACvC,mBAAK1H,KAAL,CAAW,cAAX,EAA2B,0CAA3B,EAAuE+C,GAAvE;AACD;;AACD6E,YAAAA,cAAc,CAACnF,IAAf,CAAoB,IAApB;AACD;;AACD8E,UAAAA,GAAG,CAAChB,KAAJ,CAAU9D,IAAV,CAAe;AACb+D,YAAAA,IAAI,EAAEzD,GAAG,CAACZ,IADG;AAEbyC,YAAAA,GAAG,EAAE,MAAM7B,GAAG,CAAC6B,GAAV,GAAgB,GAFR;AAGbnD,YAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHP;AAIbG,YAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJT;AAKbb,YAAAA,QAAQ,EAAE,KAAKA,QALF;AAMbqE,YAAAA,UAAU,EAAE;AANC,WAAf;AAQA;;AACF,aAAK,kBAAL;AACE,cAAIuC,SAAJ,EAAe;AACbV,YAAAA,OAAO,CAACC,IAAR,CAAa,KAAKnG,QAAL,GAAgB,SAAhB,GAA4B,KAAKe,IAAL,GAAYJ,GAAZ,CAAgBC,KAAhB,CAAsBF,IAAlD,GAAyD,2DAAtE;AACD;;AACDkG,UAAAA,SAAS,GAAG,IAAZ;AACAJ,UAAAA,GAAG,CAAChB,KAAJ,GAAYgB,GAAG,CAAChB,KAAJ,CAAUlE,MAAV,CAAiB,KAAKkE,KAAL,CAAWqB,cAAX,CAAjB,CAAZ;AACA;;AACF,aAAK,aAAL;AACE,cAAI7E,GAAG,GAAG,KAAKlB,OAAL,EAAV;AACA0F,UAAAA,GAAG,CAACD,eAAJ,CAAoB7E,IAApB,CAAyB;AACvBN,YAAAA,IAAI,EAAE,gBADiB;AAEvByC,YAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFc;AAGvBnD,YAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHG;AAIvBG,YAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJC;AAKvBb,YAAAA,QAAQ,EAAE,KAAKA;AALQ,WAAzB;AAOA;;AACF;AACE,cAAI8D,YAAY,GAAG,KAAKhC,SAAL,CAAe,oBAAf,EAAqC,KAAKf,IAAL,EAArC,EAAkDyF,GAAlD,EAAuDK,cAAvD,CAAnB;AACA,cAAI/C,YAAJ,EAAkB;AAClB,gBAAMgD,GAAN;AAvCJ;AAyCD,KAhDuB,CAkD1B;;;AACA,QAAI,SAAS,KAAK/F,IAAL,GAAYK,IAAzB,EAA+B;AAC7BoF,MAAAA,GAAG,CAACO,QAAJ,GAAe,IAAf;AACA,WAAKjG,OAAL;AACD,KAtDyB,CAwD1B;;;AACA,YAAQ,KAAKC,IAAL,GAAYK,IAApB;AACE,WAAK,MAAL;AACA,WAAK,mBAAL;AACE,YAAIqD,IAAI,GAAG,KAAKvB,SAAL,EAAX;;AACA,YAAIuB,IAAI,CAACrD,IAAL,KAAc,OAAlB,EAA2B;AACzBoF,UAAAA,GAAG,CAACtF,KAAJ,CAAUG,KAAV,CAAgBK,IAAhB,CAAqBa,KAArB,CAA2BiE,GAAG,CAACtF,KAAJ,CAAUG,KAArC,EAA4CoD,IAAI,CAACpD,KAAjD;AACD,SAFD,MAEO;AACLmF,UAAAA,GAAG,CAACtF,KAAJ,CAAUG,KAAV,CAAgBK,IAAhB,CAAqB+C,IAArB;AACD;;AACD;;AACF,WAAK,MAAL;AACE+B,QAAAA,GAAG,CAACtF,KAAJ,CAAUG,KAAV,CAAgBK,IAAhB,CAAqB,KAAK2B,SAAL,CAAe,IAAf,CAArB;AACA;;AACF,WAAK,GAAL;AACE,aAAKvC,OAAL;AACA,YAAIU,IAAI,GAAG,KAAKC,SAAL,EAAX;AACA+E,QAAAA,GAAG,CAACtF,KAAJ,GAAYM,IAAI,CAACJ,IAAL,KAAc,OAAd,GAAwBI,IAAxB,GAA+B,KAAKK,SAAL,CAAe2E,GAAG,CAAC9F,IAAnB,EAAyB,CAACc,IAAD,CAAzB,CAA3C;AACA;;AACF,WAAK,SAAL;AACA,WAAK,QAAL;AACA,WAAK,SAAL;AACA,WAAK,KAAL;AACA,WAAK,qBAAL;AACA,WAAK,uBAAL;AACE;;AACF,WAAK,OAAL;AACE,YAAIkF,kBAAJ,EAAwB;AACtB,eAAK5F,OAAL;AACA0F,UAAAA,GAAG,CAACC,WAAJ,GAAkB,IAAlB;AACA;AACD;;AACH;AACE,YAAI3C,YAAY,GAAG,KAAKhC,SAAL,CAAe,WAAf,EAA4B,KAAKf,IAAL,EAA5B,EAAyCyF,GAAzC,EAA8ChH,OAA9C,CAAnB;AACA,YAAIsE,YAAJ,EAAkB;AAClB,aAAK7E,KAAL,CAAW,eAAX,EAA4B,uBAAuB,KAAK8B,IAAL,GAAYK,IAAnC,GAA0C,qDAA1C,IAAmGsF,kBAAkB,GAAG,WAAH,GAAiB,EAAtI,IAA4I,sBAAxK,EAAgM,KAAK3F,IAAL,EAAhM;AAlCJ,KAzD0B,CA8F1B;;;AACA,WAAO,aAAa,KAAKA,IAAL,GAAYK,IAAhC,EAAsC,KAAKN,OAAL,GA/FZ,CAiG1B;;;AACA,QAAI0F,GAAG,CAACO,QAAR,EAAkB;AAChBP,MAAAA,GAAG,CAACtF,KAAJ,GAAY,KAAK6C,cAAL,MAAyB,KAAK5C,UAAL,CAAgBqF,GAAG,CAAC9F,IAApB,CAArC;AACD,KAFD,MAEO,IAAI,YAAY,KAAKK,IAAL,GAAYK,IAA5B,EAAkC;AACvC,UAAIF,KAAK,GAAG,KAAKA,KAAL,EAAZ;;AACA,WAAK,IAAIgB,CAAC,GAAG,CAAR,EAAW8E,GAAG,GAAG9F,KAAK,CAACG,KAAN,CAAYe,MAAlC,EAA0CF,CAAC,GAAG8E,GAA9C,EAAmD,EAAE9E,CAArD,EAAwD;AACtDsE,QAAAA,GAAG,CAACtF,KAAJ,CAAUG,KAAV,CAAgBK,IAAhB,CAAqBR,KAAK,CAACG,KAAN,CAAYa,CAAZ,CAArB;AACD;AACF;;AAED,WAAOsE,GAAP;AACD,GAhmCgB;AAkmCjBhB,EAAAA,KAAK,EAAE,UAASqB,cAAT,EAAyB;AAC9B,SAAKlF,MAAL,CAAY,kBAAZ;AAEA,QAAI6D,KAAK,GAAG,EAAZ;AACA,QAAIxD,GAAG,GAAG,KAAKlB,OAAL,EAAV;;AACA,WAAOkB,GAAG,CAACZ,IAAJ,KAAa,WAApB,EAAiC;AAC/B,UAAIY,GAAG,CAACyD,IAAJ,KAAa,OAAb,IAAwBoB,cAA5B,EAA4C;AAC1C,YAAIA,cAAc,CAACF,OAAf,CAAuB3E,GAAG,CAACyD,IAA3B,MAAqC,CAAC,CAA1C,EAA6C;AAC3C,eAAKxG,KAAL,CAAW,qBAAX,EAAkC,0BAA0B+C,GAAG,CAACyD,IAA9B,GAAqC,mBAAvE,EAA4FzD,GAA5F;AACD;;AACD6E,QAAAA,cAAc,CAACnF,IAAf,CAAoBM,GAAG,CAACyD,IAAxB;AACD;;AACDD,MAAAA,KAAK,CAAC9D,IAAN,CAAW;AACT+D,QAAAA,IAAI,EAAEzD,GAAG,CAACyD,IADD;AAET5B,QAAAA,GAAG,EAAE7B,GAAG,CAAC6B,GAFA;AAGTnD,QAAAA,IAAI,EAAEsB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcF,IAHX;AAITG,QAAAA,MAAM,EAAEmB,GAAG,CAACrB,GAAJ,CAAQC,KAAR,CAAcC,MAJb;AAKTb,QAAAA,QAAQ,EAAE,KAAKA,QALN;AAMTqE,QAAAA,UAAU,EAAErC,GAAG,CAACqC,UAAJ,KAAmB;AANtB,OAAX;AAQArC,MAAAA,GAAG,GAAG,KAAKlB,OAAL,EAAN;AACD;;AACD,SAAKvB,MAAL,CAAYqE,KAAZ,CAAkB5B,GAAlB;AACA,SAAKL,MAAL,CAAY,gBAAZ;AACA,WAAO6D,KAAP;AACD;AA3nCgB,CAAnB","sourcesContent":["'use strict';\n\nvar assert = require('assert');\nvar TokenStream = require('token-stream');\nvar error = require('pug-error');\nvar inlineTags = require('./lib/inline-tags');\n\nmodule.exports = parse;\nmodule.exports.Parser = Parser;\nfunction parse(tokens, options) {\n  var parser = new Parser(tokens, options);\n  var ast = parser.parse();\n  return JSON.parse(JSON.stringify(ast));\n};\n\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\nfunction Parser(tokens, options) {\n  options = options || {};\n  if (!Array.isArray(tokens)) {\n    throw new Error('Expected tokens to be an Array but got \"' + (typeof tokens) + '\"');\n  }\n  if (typeof options !== 'object') {\n    throw new Error('Expected \"options\" to be an object but got \"' + (typeof options) + '\"');\n  }\n  this.tokens = new TokenStream(tokens);\n  this.filename = options.filename;\n  this.src = options.src;\n  this.inMixin = 0;\n  this.plugins = options.plugins || [];\n};\n\n/**\n * Parser prototype.\n */\n\nParser.prototype = {\n\n  /**\n   * Save original constructor\n   */\n\n  constructor: Parser,\n\n  error: function (code, message, token) {\n    var err = error(code, message, {\n      line: token.loc.start.line,\n      column: token.loc.start.column,\n      filename: this.filename,\n      src: this.src\n    });\n    throw err;\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  advance: function(){\n    return this.tokens.advance();\n  },\n\n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  peek: function() {\n    return this.tokens.peek();\n  },\n\n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n\n  lookahead: function(n){\n    return this.tokens.lookahead(n);\n  },\n\n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n\n  parse: function(){\n    var block = this.emptyBlock(0);\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n        if (expr) {\n          if (expr.type === 'Block') {\n            block.nodes = block.nodes.concat(expr.nodes);\n          } else {\n            block.nodes.push(expr);\n          }\n        }\n      }\n    }\n\n    return block;\n  },\n\n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n\n  expect: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      this.error('INVALID_TOKEN', 'expected \"' + type + '\", but got \"' + this.peek().type + '\"', this.peek());\n    }\n  },\n\n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n\n  accept: function(type){\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n\n  initBlock: function(line, nodes) {\n    /* istanbul ignore if */\n    if ((line | 0) !== line) throw new Error('`line` is not an integer');\n    /* istanbul ignore if */\n    if (!Array.isArray(nodes)) throw new Error('`nodes` is not an array');\n    return {\n      type: 'Block',\n      nodes: nodes,\n      line: line,\n      filename: this.filename\n    };\n  },\n\n  emptyBlock: function(line) {\n    return this.initBlock(line, []);\n  },\n\n  runPlugin: function(context, tok) {\n    var rest = [this];\n    for (var i = 2; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n    var pluginContext;\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n      if (plugin[context] && plugin[context][tok.type]) {\n        if (pluginContext) throw new Error('Multiple plugin handlers found for context ' + JSON.stringify(context) + ', token type ' + JSON.stringify(tok.type));\n        pluginContext = plugin[context];\n      }\n    }\n    if (pluginContext) return pluginContext[tok.type].apply(pluginContext, rest);\n  },\n\n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | text-html\n   * | dot\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n\n  parseExpr: function(){\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n      case 'mixin':\n        return this.parseMixin();\n      case 'block':\n        return this.parseBlock();\n      case 'mixin-block':\n        return this.parseMixinBlock();\n      case 'case':\n        return this.parseCase();\n      case 'extends':\n        return this.parseExtends();\n      case 'include':\n        return this.parseInclude();\n      case 'doctype':\n        return this.parseDoctype();\n      case 'filter':\n        return this.parseFilter();\n      case 'comment':\n        return this.parseComment();\n      case 'text':\n      case 'interpolated-code':\n      case 'start-pug-interpolation':\n        return this.parseText({block: true});\n      case 'text-html':\n        return this.initBlock(this.peek().loc.start.line, this.parseTextHtml());\n      case 'dot':\n        return this.parseDot();\n      case 'each':\n        return this.parseEach();\n      case 'code':\n        return this.parseCode();\n      case 'blockcode':\n        return this.parseBlockCode();\n      case 'if':\n        return this.parseConditional();\n      case 'while':\n        return this.parseWhile();\n      case 'call':\n        return this.parseCall();\n      case 'interpolation':\n        return this.parseInterpolation();\n      case 'yield':\n        return this.parseYield();\n      case 'id':\n      case 'class':\n        if (!this.peek().loc.start) debugger;\n        this.tokens.defer({\n          type: 'tag',\n          val: 'div',\n          loc: this.peek().loc,\n          filename: this.filename\n        });\n        return this.parseExpr();\n      default:\n        var pluginResult = this.runPlugin('expressionTokens', this.peek());\n        if (pluginResult) return pluginResult;\n        this.error('INVALID_TOKEN', 'unexpected token \"' + this.peek().type + '\"', this.peek());\n    }\n  },\n\n  parseDot: function() {\n    this.advance();\n    return this.parseTextBlock();\n  },\n\n  /**\n   * Text\n   */\n\n  parseText: function(options){\n    var tags = [];\n    var lineno = this.peek().loc.start.line;\n    var nextTok = this.peek();\n    loop:\n      while (true) {\n        switch (nextTok.type) {\n          case 'text':\n            var tok = this.advance();\n            tags.push({\n              type: 'Text',\n              val: tok.val,\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename\n            });\n            break;\n          case 'interpolated-code':\n            var tok = this.advance();\n            tags.push({\n              type: 'Code',\n              val: tok.val,\n              buffer: tok.buffer,\n              mustEscape: tok.mustEscape !== false,\n              isInline: true,\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename\n            });\n            break;\n          case 'newline':\n            if (!options || !options.block) break loop;\n            var tok = this.advance();\n            var nextType = this.peek().type;\n            if (nextType === 'text' || nextType === 'interpolated-code') {\n              tags.push({\n                type: 'Text',\n                val: '\\n',\n                line: tok.loc.start.line,\n                column: tok.loc.start.column,\n                filename: this.filename\n              });\n            }\n            break;\n          case 'start-pug-interpolation':\n            this.advance();\n            tags.push(this.parseExpr());\n            this.expect('end-pug-interpolation');\n            break;\n          default:\n            var pluginResult = this.runPlugin('textTokens', nextTok, tags);\n            if (pluginResult) break;\n            break loop;\n        }\n        nextTok = this.peek();\n      }\n    if (tags.length === 1) return tags[0];\n    else return this.initBlock(lineno, tags);\n  },\n\n  parseTextHtml: function () {\n    var nodes = [];\n    var currentNode = null;\nloop:\n    while (true) {\n      switch (this.peek().type) {\n        case 'text-html':\n          var text = this.advance();\n          if (!currentNode) {\n            currentNode = {\n              type: 'Text',\n              val: text.val,\n              filename: this.filename,\n              line: text.loc.start.line,\n              column: text.loc.start.column,\n              isHtml: true\n            };\n            nodes.push(currentNode);\n          } else {\n            currentNode.val += '\\n' + text.val;\n          }\n          break;\n        case 'indent':\n          var block = this.block();\n          block.nodes.forEach(function (node) {\n            if (node.isHtml) {\n              if (!currentNode) {\n                currentNode = node;\n                nodes.push(currentNode);\n              } else {\n                currentNode.val += '\\n' + node.val;\n              }\n            } else {\n              currentNode = null;\n              nodes.push(node);\n            }\n          });\n          break;\n        case 'code':\n          currentNode = null;\n          nodes.push(this.parseCode(true));\n          break;\n        case 'newline':\n          this.advance();\n          break;\n        default:\n          break loop;\n      }\n    }\n    return nodes;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n\n  parseBlockExpansion: function(){\n    var tok = this.accept(':');\n    if (tok) {\n      var expr = this.parseExpr();\n      return expr.type === 'Block' ? expr : this.initBlock(tok.loc.start.line, [expr]);\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n\n  parseCase: function(){\n    var tok = this.expect('case');\n    var node = {\n      type: 'Case',\n      expr: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n\n    var block = this.emptyBlock(tok.loc.start.line + 1);\n    this.expect('indent');\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'comment':\n        case 'newline':\n          this.advance();\n          break;\n        case 'when':\n          block.nodes.push(this.parseWhen());\n          break;\n        case 'default':\n          block.nodes.push(this.parseDefault());\n          break;\n        default:\n          var pluginResult = this.runPlugin('caseTokens', this.peek(), block);\n          if (pluginResult) break;\n          this.error('INVALID_TOKEN', 'Unexpected token \"' + this.peek().type\n                          + '\", expected \"when\", \"default\" or \"newline\"', this.peek());\n      }\n    }\n    this.expect('outdent');\n\n    node.block = block;\n\n    return node;\n  },\n\n  /**\n   * when\n   */\n\n  parseWhen: function(){\n    var tok = this.expect('when');\n    if (this.peek().type !== 'newline') {\n      return {\n        type: 'When',\n        expr: tok.val,\n        block: this.parseBlockExpansion(),\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    } else {\n      return {\n        type: 'When',\n        expr: tok.val,\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    }\n  },\n\n  /**\n   * default\n   */\n\n  parseDefault: function(){\n    var tok = this.expect('default');\n    return {\n      type: 'When',\n      expr: 'default',\n      block: this.parseBlockExpansion(),\n      debug: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * code\n   */\n\n  parseCode: function(noBlock){\n    var tok = this.expect('code');\n    assert(typeof tok.mustEscape === 'boolean', 'Please update to the newest version of pug-lexer.');\n    var node = {\n      type: 'Code',\n      val: tok.val,\n      buffer: tok.buffer,\n      mustEscape: tok.mustEscape !== false,\n      isInline: !!noBlock,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    // todo: why is this here?  It seems like a hacky workaround\n    if (node.val.match(/^ *else/)) node.debug = false;\n\n    if (noBlock) return node;\n\n    var block;\n\n    // handle block\n    block = 'indent' == this.peek().type;\n    if (block) {\n      if (tok.buffer) {\n        this.error('BLOCK_IN_BUFFERED_CODE', 'Buffered code cannot have a block attached to it', this.peek());\n      }\n      node.block = this.block();\n    }\n\n    return node;\n  },\n  parseConditional: function(){\n    var tok = this.expect('if');\n    var node = {\n      type: 'Conditional',\n      test: tok.val,\n      consequent: this.emptyBlock(tok.loc.start.line),\n      alternate: null,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n\n    // handle block\n    if ('indent' == this.peek().type) {\n      node.consequent = this.block();\n    }\n\n    var currentNode = node;\n    while (true) {\n      if (this.peek().type === 'newline') {\n        this.expect('newline');\n      } else if (this.peek().type === 'else-if') {\n        tok = this.expect('else-if');\n        currentNode = (\n          currentNode.alternate = {\n            type: 'Conditional',\n            test: tok.val,\n            consequent: this.emptyBlock(tok.loc.start.line),\n            alternate: null,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          }\n        );\n        if ('indent' == this.peek().type) {\n          currentNode.consequent = this.block();\n        }\n      } else if (this.peek().type === 'else') {\n        this.expect('else');\n        if (this.peek().type === 'indent') {\n          currentNode.alternate = this.block();\n        }\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  },\n  parseWhile: function(){\n    var tok = this.expect('while');\n    var node = {\n      type: 'While',\n      test: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n\n    // handle block\n    if ('indent' == this.peek().type) {\n      node.block = this.block();\n    } else {\n      node.block = this.emptyBlock(tok.loc.start.line);\n    }\n\n    return node;\n  },\n\n  /**\n   * block code\n   */\n\n  parseBlockCode: function(){\n    var tok = this.expect('blockcode');\n    var line = tok.loc.start.line;\n    var column = tok.loc.start.column;\n    var body = this.peek();\n    var text = '';\n    if (body.type === 'start-pipeless-text') {\n      this.advance();\n      while (this.peek().type !== 'end-pipeless-text') {\n        tok = this.advance();\n        switch (tok.type) {\n          case 'text':\n            text += tok.val;\n            break;\n          case 'newline':\n            text += '\\n';\n            break;\n          default:\n            var pluginResult = this.runPlugin('blockCodeTokens', tok, tok);\n            if (pluginResult) {\n              text += pluginResult;\n              break;\n            }\n            this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);\n        }\n      }\n      this.advance();\n    }\n    return {\n      type: 'Code',\n      val: text,\n      buffer: false,\n      mustEscape: false,\n      isInline: false,\n      line: line,\n      column: column,\n      filename: this.filename\n    };\n  },\n  /**\n   * comment\n   */\n\n  parseComment: function(){\n    var tok = this.expect('comment');\n    var block;\n    if (block = this.parseTextBlock()) {\n      return {\n        type: 'BlockComment',\n        val: tok.val,\n        block: block,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    } else {\n      return {\n        type: 'Comment',\n        val: tok.val,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    }\n  },\n\n  /**\n   * doctype\n   */\n\n  parseDoctype: function(){\n    var tok = this.expect('doctype');\n    return {\n      type: 'Doctype',\n      val: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  parseIncludeFilter: function() {\n    var tok = this.expect('filter');\n    var attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    return {\n      type: 'IncludeFilter',\n      name: tok.val,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * filter attrs? text-block\n   */\n\n  parseFilter: function(){\n    var tok = this.expect('filter');\n    var block, attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    if (this.peek().type === 'text') {\n      var textToken = this.advance();\n      block = this.initBlock(textToken.loc.start.line, [\n        {\n          type: 'Text',\n          val: textToken.val,\n          line: textToken.loc.start.line,\n          column: textToken.loc.start.column,\n          filename: this.filename\n        }\n      ]);\n    } else if (this.peek().type === 'filter') {\n      block = this.initBlock(tok.loc.start.line, [this.parseFilter()]);\n    } else {\n      block = this.parseTextBlock() || this.emptyBlock(tok.loc.start.line);\n    }\n\n    return {\n      type: 'Filter',\n      name: tok.val,\n      block: block,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * each block\n   */\n\n  parseEach: function(){\n    var tok = this.expect('each');\n    var node = {\n      type: 'Each',\n      obj: tok.code,\n      val: tok.val,\n      key: tok.key,\n      block: this.block(),\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    if (this.peek().type == 'else') {\n      this.advance();\n      node.alternate = this.block();\n    }\n    return node;\n  },\n\n  /**\n   * 'extends' name\n   */\n\n  parseExtends: function(){\n    var tok = this.expect('extends');\n    var path = this.expect('path');\n    return {\n      type: 'Extends',\n      file: {\n        type: 'FileReference',\n        path: path.val.trim(),\n        line: path.loc.start.line,\n        column: path.loc.start.column,\n        filename: this.filename\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * 'block' name block\n   */\n\n  parseBlock: function(){\n    var tok = this.expect('block');\n\n    var node = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);\n    node.type = 'NamedBlock';\n    node.name = tok.val.trim();\n    node.mode = tok.mode;\n    node.line = tok.loc.start.line;\n    node.column = tok.loc.start.column;\n\n    return node;\n  },\n\n  parseMixinBlock: function () {\n    var tok = this.expect('mixin-block');\n    if (!this.inMixin) {\n      this.error('BLOCK_OUTISDE_MIXIN', 'Anonymous blocks are not allowed unless they are part of a mixin.', tok);\n    }\n    return {\n      type: 'MixinBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  parseYield: function() {\n    var tok = this.expect('yield');\n    return {\n      type: 'YieldBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * include block?\n   */\n\n  parseInclude: function(){\n    var tok = this.expect('include');\n    var node = {\n      type: 'Include',\n      file: {\n        type: 'FileReference',\n        filename: this.filename\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    var filters = [];\n    while (this.peek().type === 'filter') {\n      filters.push(this.parseIncludeFilter());\n    }\n    var path = this.expect('path');\n\n    node.file.path = path.val.trim();\n    node.file.line = path.loc.start.line;\n    node.file.column = path.loc.start.column;\n\n    if ((/\\.jade$/.test(node.file.path) || /\\.pug$/.test(node.file.path)) && !filters.length) {\n      node.block = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);\n      if (/\\.jade$/.test(node.file.path)) {\n        console.warn(\n          this.filename + ', line ' + tok.loc.start.line +\n          ':\\nThe .jade extension is deprecated, use .pug for \"' + node.file.path +'\".'\n        );\n      }\n    } else {\n      node.type = 'RawInclude';\n      node.filters = filters;\n      if (this.peek().type === 'indent') {\n        this.error('RAW_INCLUDE_BLOCK', 'Raw inclusion cannot contain a block', this.peek());\n      }\n    }\n    return node;\n  },\n\n  /**\n   * call ident block\n   */\n\n  parseCall: function(){\n    var tok = this.expect('call');\n    var name = tok.val;\n    var args = tok.args;\n    var mixin = {\n      type: 'Mixin',\n      name: name,\n      args: args,\n      block: this.emptyBlock(tok.loc.start.line),\n      call: true,\n      attrs: [],\n      attributeBlocks: [],\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n\n    this.tag(mixin);\n    if (mixin.code) {\n      mixin.block.nodes.push(mixin.code);\n      delete mixin.code;\n    }\n    if (mixin.block.nodes.length === 0) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n\n  parseMixin: function(){\n    var tok = this.expect('mixin');\n    var name = tok.val;\n    var args = tok.args;\n\n    if ('indent' == this.peek().type) {\n      this.inMixin++;\n      var mixin = {\n        type: 'Mixin',\n        name: name,\n        args: args,\n        block: this.block(),\n        call: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n      this.inMixin--;\n      return mixin;\n    } else {\n      this.error('MIXIN_WITHOUT_BODY', 'Mixin ' + name + ' declared without body', tok);\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n\n  parseTextBlock: function(){\n    var tok = this.accept('start-pipeless-text');\n    if (!tok) return;\n    var block = this.emptyBlock(tok.loc.start.line);\n    while (this.peek().type !== 'end-pipeless-text') {\n      var tok = this.advance();\n      switch (tok.type) {\n        case 'text':\n          block.nodes.push({\n            type: 'Text',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n        case 'newline':\n          block.nodes.push({\n            type: 'Text',\n            val: '\\n',\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n        case 'start-pug-interpolation':\n          block.nodes.push(this.parseExpr());\n          this.expect('end-pug-interpolation');\n          break;\n        case 'interpolated-code':\n          block.nodes.push({\n            type: 'Code',\n            val: tok.val,\n            buffer: tok.buffer,\n            mustEscape: tok.mustEscape !== false,\n            isInline: true,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n        default:\n          var pluginResult = this.runPlugin('textBlockTokens', tok, block, tok);\n          if (pluginResult) break;\n          this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);\n      }\n    }\n    this.advance();\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n\n  block: function(){\n    var tok = this.expect('indent');\n    var block = this.emptyBlock(tok.loc.start.line);\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n        if (expr.type === 'Block') {\n          block.nodes = block.nodes.concat(expr.nodes);\n        } else {\n          block.nodes.push(expr);\n        }\n      }\n    }\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n\n  parseInterpolation: function(){\n    var tok = this.advance();\n    var tag = {\n      type: 'InterpolatedTag',\n      expr: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n\n    return this.tag(tag, {selfClosingAllowed: true});\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n\n  parseTag: function(){\n    var tok = this.advance();\n    var tag = {\n      type: 'Tag',\n      name: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: inlineTags.indexOf(tok.val) !== -1,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n\n    return this.tag(tag, {selfClosingAllowed: true});\n  },\n\n  /**\n   * Parse tag.\n   */\n\n  tag: function(tag, options) {\n    var seenAttrs = false;\n    var attributeNames = [];\n    var selfClosingAllowed = options && options.selfClosingAllowed;\n    // (attrs | class | id)*\n    out:\n      while (true) {\n        switch (this.peek().type) {\n          case 'id':\n          case 'class':\n            var tok = this.advance();\n            if (tok.type === 'id') {\n              if (attributeNames.indexOf('id') !== -1) {\n                this.error('DUPLICATE_ID', 'Duplicate attribute \"id\" is not allowed.', tok);\n              }\n              attributeNames.push('id');\n            }\n            tag.attrs.push({\n              name: tok.type,\n              val: \"'\" + tok.val + \"'\",\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename,\n              mustEscape: false\n            });\n            continue;\n          case 'start-attributes':\n            if (seenAttrs) {\n              console.warn(this.filename + ', line ' + this.peek().loc.start.line + ':\\nYou should not have pug tags with multiple attributes.');\n            }\n            seenAttrs = true;\n            tag.attrs = tag.attrs.concat(this.attrs(attributeNames));\n            continue;\n          case '&attributes':\n            var tok = this.advance();\n            tag.attributeBlocks.push({\n              type: 'AttributeBlock',\n              val: tok.val,\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename\n            });\n            break;\n          default:\n            var pluginResult = this.runPlugin('tagAttributeTokens', this.peek(), tag, attributeNames);\n            if (pluginResult) break;\n            break out;\n        }\n      }\n\n    // check immediate '.'\n    if ('dot' == this.peek().type) {\n      tag.textOnly = true;\n      this.advance();\n    }\n\n    // (text | code | ':')?\n    switch (this.peek().type) {\n      case 'text':\n      case 'interpolated-code':\n        var text = this.parseText();\n        if (text.type === 'Block') {\n          tag.block.nodes.push.apply(tag.block.nodes, text.nodes);\n        } else {\n          tag.block.nodes.push(text);\n        }\n        break;\n      case 'code':\n        tag.block.nodes.push(this.parseCode(true));\n        break;\n      case ':':\n        this.advance();\n        var expr = this.parseExpr();\n        tag.block = expr.type === 'Block' ? expr : this.initBlock(tag.line, [expr]);\n        break;\n      case 'newline':\n      case 'indent':\n      case 'outdent':\n      case 'eos':\n      case 'start-pipeless-text':\n      case 'end-pug-interpolation':\n        break;\n      case 'slash':\n        if (selfClosingAllowed) {\n          this.advance();\n          tag.selfClosing = true;\n          break;\n        }\n      default:\n        var pluginResult = this.runPlugin('tagTokens', this.peek(), tag, options);\n        if (pluginResult) break;\n        this.error('INVALID_TOKEN', 'Unexpected token `' + this.peek().type + '` expected `text`, `interpolated-code`, `code`, `:`' + (selfClosingAllowed ? ', `slash`' : '') + ', `newline` or `eos`', this.peek())\n    }\n\n    // newline*\n    while ('newline' == this.peek().type) this.advance();\n\n    // block?\n    if (tag.textOnly) {\n      tag.block = this.parseTextBlock() || this.emptyBlock(tag.line);\n    } else if ('indent' == this.peek().type) {\n      var block = this.block();\n      for (var i = 0, len = block.nodes.length; i < len; ++i) {\n        tag.block.nodes.push(block.nodes[i]);\n      }\n    }\n\n    return tag;\n  },\n\n  attrs: function(attributeNames) {\n    this.expect('start-attributes');\n\n    var attrs = [];\n    var tok = this.advance();\n    while (tok.type === 'attribute') {\n      if (tok.name !== 'class' && attributeNames) {\n        if (attributeNames.indexOf(tok.name) !== -1) {\n          this.error('DUPLICATE_ATTRIBUTE', 'Duplicate attribute \"' + tok.name + '\" is not allowed.', tok);\n        }\n        attributeNames.push(tok.name);\n      }\n      attrs.push({\n        name: tok.name,\n        val: tok.val,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n        mustEscape: tok.mustEscape !== false\n      });\n      tok = this.advance();\n    }\n    this.tokens.defer(tok);\n    this.expect('end-attributes');\n    return attrs;\n  }\n};"]},"metadata":{},"sourceType":"script"}