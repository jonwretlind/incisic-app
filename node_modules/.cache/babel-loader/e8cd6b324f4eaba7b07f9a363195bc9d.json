{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar babylon_1 = require(\"babylon\");\n\nvar b = require(\"babel-types\");\n\nvar binaryOperation_1 = require(\"./binaryOperation\");\n\nfunction expressionToConstant(expression, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var constant = true;\n\n  function toConstant(expression) {\n    if (!constant) return;\n\n    if (b.isArrayExpression(expression)) {\n      var result_1 = [];\n\n      for (var i = 0; constant && i < expression.elements.length; i++) {\n        var element = expression.elements[i];\n\n        if (b.isSpreadElement(element)) {\n          var spread = toConstant(element.argument);\n\n          if (!(isSpreadable(spread) && constant)) {\n            constant = false;\n          } else {\n            result_1.push.apply(result_1, spread);\n          }\n        } else {\n          result_1.push(toConstant(element));\n        }\n      }\n\n      return result_1;\n    }\n\n    if (b.isBinaryExpression(expression)) {\n      var left = toConstant(expression.left);\n      var right = toConstant(expression.right);\n      return constant && binaryOperation_1[\"default\"](expression.operator, left, right);\n    }\n\n    if (b.isBooleanLiteral(expression)) {\n      return expression.value;\n    }\n\n    if (b.isCallExpression(expression)) {\n      var args = [];\n\n      for (var i = 0; constant && i < expression.arguments.length; i++) {\n        var arg = expression.arguments[i];\n\n        if (b.isSpreadElement(arg)) {\n          var spread = toConstant(arg.argument);\n\n          if (!(isSpreadable(spread) && constant)) {\n            constant = false;\n          } else {\n            args.push.apply(args, spread);\n          }\n        } else {\n          args.push(toConstant(arg));\n        }\n      }\n\n      if (!constant) return;\n\n      if (b.isMemberExpression(expression.callee)) {\n        var object = toConstant(expression.callee.object);\n\n        if (!object || !constant) {\n          constant = false;\n          return;\n        }\n\n        var member = expression.callee.computed ? toConstant(expression.callee.property) : b.isIdentifier(expression.callee.property) ? expression.callee.property.name : undefined;\n\n        if (member === undefined && !expression.callee.computed) {\n          constant = false;\n        }\n\n        if (!constant) return;\n\n        if (canCallMethod(object, '' + member)) {\n          return object[member].apply(object, args);\n        }\n      } else {\n        var callee = toConstant(expression.callee);\n        if (!constant) return;\n        return callee.apply(null, args);\n      }\n    }\n\n    if (b.isConditionalExpression(expression)) {\n      var test = toConstant(expression.test);\n      return test ? toConstant(expression.consequent) : toConstant(expression.alternate);\n    }\n\n    if (b.isIdentifier(expression)) {\n      if (options.constants && {}.hasOwnProperty.call(options.constants, expression.name)) {\n        return options.constants[expression.name];\n      }\n    }\n\n    if (b.isLogicalExpression(expression)) {\n      var left = toConstant(expression.left);\n      var right = toConstant(expression.right);\n\n      if (constant && expression.operator === '&&') {\n        return left && right;\n      }\n\n      if (constant && expression.operator === '||') {\n        return left || right;\n      }\n    }\n\n    if (b.isMemberExpression(expression)) {\n      var object = toConstant(expression.object);\n\n      if (!object || !constant) {\n        constant = false;\n        return;\n      }\n\n      var member = expression.computed ? toConstant(expression.property) : b.isIdentifier(expression.property) ? expression.property.name : undefined;\n\n      if (member === undefined && !expression.computed) {\n        constant = false;\n      }\n\n      if (!constant) return;\n\n      if ({}.hasOwnProperty.call(object, '' + member) && member[0] !== '_') {\n        return object[member];\n      }\n    }\n\n    if (b.isNullLiteral(expression)) {\n      return null;\n    }\n\n    if (b.isNumericLiteral(expression)) {\n      return expression.value;\n    }\n\n    if (b.isObjectExpression(expression)) {\n      var result_2 = {};\n\n      for (var i = 0; constant && i < expression.properties.length; i++) {\n        var property = expression.properties[i];\n\n        if (b.isObjectProperty(property)) {\n          if (property.shorthand) {\n            constant = false;\n            return;\n          }\n\n          var key = property.computed ? toConstant(property.key) : b.isIdentifier(property.key) ? property.key.name : b.isStringLiteral(property.key) ? property.key.value : undefined;\n\n          if (!key || key[0] === '_') {\n            constant = false;\n          }\n\n          if (!constant) return;\n          var value = toConstant(property.value);\n          if (!constant) return;\n          result_2[key] = value;\n        } else if (b.isObjectMethod(property)) {\n          constant = false;\n        } else if (b.isSpreadProperty(property)) {\n          var argument = toConstant(property.argument);\n          if (!argument) constant = false;\n          if (!constant) return;\n          Object.assign(result_2, argument);\n        }\n      }\n\n      return result_2;\n    }\n\n    if (b.isParenthesizedExpression(expression)) {\n      return toConstant(expression.expression);\n    }\n\n    if (b.isRegExpLiteral(expression)) {\n      return new RegExp(expression.pattern, expression.flags);\n    }\n\n    if (b.isSequenceExpression(expression)) {\n      for (var i = 0; i < expression.expressions.length - 1 && constant; i++) {\n        toConstant(expression.expressions[i]);\n      }\n\n      return toConstant(expression.expressions[expression.expressions.length - 1]);\n    }\n\n    if (b.isStringLiteral(expression)) {\n      return expression.value;\n    } // TODO: TaggedTemplateExpression\n\n\n    if (b.isTemplateLiteral(expression)) {\n      var result_3 = '';\n\n      for (var i = 0; i < expression.quasis.length; i++) {\n        var quasi = expression.quasis[i];\n        result_3 += quasi.value.cooked;\n\n        if (i < expression.expressions.length) {\n          result_3 += '' + toConstant(expression.expressions[i]);\n        }\n      }\n\n      return result_3;\n    }\n\n    if (b.isUnaryExpression(expression)) {\n      var argument = toConstant(expression.argument);\n\n      if (!constant) {\n        return;\n      }\n\n      switch (expression.operator) {\n        case '-':\n          return -argument;\n\n        case '+':\n          return +argument;\n\n        case '!':\n          return !argument;\n\n        case '~':\n          return ~argument;\n\n        case 'typeof':\n          return typeof argument;\n\n        case 'void':\n          return void argument;\n      }\n    }\n\n    constant = false;\n  }\n\n  var result = toConstant(expression);\n  return constant ? {\n    constant: true,\n    result: result\n  } : {\n    constant: false\n  };\n}\n\nexports.expressionToConstant = expressionToConstant;\n\nfunction isSpreadable(value) {\n  return typeof value === 'string' || Array.isArray(value) || typeof Set !== 'undefined' && value instanceof Set || typeof Map !== 'undefined' && value instanceof Map;\n}\n\nfunction shallowEqual(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    for (var key in a) {\n      if (a[key] !== b[key]) {\n        return false;\n      }\n    }\n\n    for (var key in b) {\n      if (a[key] !== b[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction canCallMethod(object, member) {\n  switch (typeof object) {\n    case 'boolean':\n      switch (member) {\n        case 'toString':\n          return true;\n\n        default:\n          return false;\n      }\n\n    case 'number':\n      switch (member) {\n        case 'toExponential':\n        case 'toFixed':\n        case 'toPrecision':\n        case 'toString':\n          return true;\n\n        default:\n          return false;\n      }\n\n    case 'string':\n      switch (member) {\n        case 'charAt':\n        case 'charCodeAt':\n        case 'codePointAt':\n        case 'concat':\n        case 'endsWith':\n        case 'includes':\n        case 'indexOf':\n        case 'lastIndexOf':\n        case 'match':\n        case 'normalize':\n        case 'padEnd':\n        case 'padStart':\n        case 'repeat':\n        case 'replace':\n        case 'search':\n        case 'slice':\n        case 'split':\n        case 'startsWith':\n        case 'substr':\n        case 'substring':\n        case 'toLowerCase':\n        case 'toUpperCase':\n        case 'trim':\n          return true;\n\n        default:\n          return false;\n      }\n\n    default:\n      if (object instanceof RegExp) {\n        switch (member) {\n          case 'test':\n          case 'exec':\n            return true;\n\n          default:\n            return false;\n        }\n      }\n\n      return {}.hasOwnProperty.call(object, member) && member[0] !== '_';\n  }\n}\n\nvar EMPTY_OBJECT = {};\nvar lastSrc = '';\nvar lastConstants = EMPTY_OBJECT;\nvar lastOptions = EMPTY_OBJECT;\nvar lastResult = null;\nvar lastWasConstant = false;\n\nfunction isConstant(src, constants, options) {\n  if (constants === void 0) {\n    constants = EMPTY_OBJECT;\n  }\n\n  if (options === void 0) {\n    options = EMPTY_OBJECT;\n  }\n\n  if (lastSrc === src && shallowEqual(lastConstants, constants) && shallowEqual(lastOptions, options)) {\n    return lastWasConstant;\n  }\n\n  lastSrc = src;\n  lastConstants = constants;\n  var ast;\n\n  try {\n    ast = babylon_1.parseExpression(src, options);\n  } catch (ex) {\n    return lastWasConstant = false;\n  }\n\n  var _a = expressionToConstant(ast, {\n    constants: constants\n  }),\n      result = _a.result,\n      constant = _a.constant;\n\n  lastResult = result;\n  return lastWasConstant = constant;\n}\n\nexports.isConstant = isConstant;\n\nfunction toConstant(src, constants, options) {\n  if (constants === void 0) {\n    constants = EMPTY_OBJECT;\n  }\n\n  if (options === void 0) {\n    options = EMPTY_OBJECT;\n  }\n\n  if (!isConstant(src, constants, options)) {\n    throw new Error(JSON.stringify(src) + ' is not constant.');\n  }\n\n  return lastResult;\n}\n\nexports.toConstant = toConstant;\nexports[\"default\"] = isConstant;\nmodule.exports = isConstant;\nmodule.exports[\"default\"] = isConstant;\nmodule.exports.expressionToConstant = expressionToConstant;\nmodule.exports.isConstant = isConstant;\nmodule.exports.toConstant = toConstant;","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/babel-plugin-transform-react-pug/node_modules/constantinople/lib/index.js"],"names":["exports","__esModule","babylon_1","require","b","binaryOperation_1","expressionToConstant","expression","options","constant","toConstant","isArrayExpression","result_1","i","elements","length","element","isSpreadElement","spread","argument","isSpreadable","push","apply","isBinaryExpression","left","right","operator","isBooleanLiteral","value","isCallExpression","args","arguments","arg","isMemberExpression","callee","object","member","computed","property","isIdentifier","name","undefined","canCallMethod","isConditionalExpression","test","consequent","alternate","constants","hasOwnProperty","call","isLogicalExpression","isNullLiteral","isNumericLiteral","isObjectExpression","result_2","properties","isObjectProperty","shorthand","key","isStringLiteral","isObjectMethod","isSpreadProperty","Object","assign","isParenthesizedExpression","isRegExpLiteral","RegExp","pattern","flags","isSequenceExpression","expressions","isTemplateLiteral","result_3","quasis","quasi","cooked","isUnaryExpression","result","Array","isArray","Set","Map","shallowEqual","a","EMPTY_OBJECT","lastSrc","lastConstants","lastOptions","lastResult","lastWasConstant","isConstant","src","ast","parseExpression","ex","_a","Error","JSON","stringify","module"],"mappings":"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","sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar babylon_1 = require(\"babylon\");\nvar b = require(\"babel-types\");\nvar binaryOperation_1 = require(\"./binaryOperation\");\nfunction expressionToConstant(expression, options) {\n    if (options === void 0) { options = {}; }\n    var constant = true;\n    function toConstant(expression) {\n        if (!constant)\n            return;\n        if (b.isArrayExpression(expression)) {\n            var result_1 = [];\n            for (var i = 0; constant && i < expression.elements.length; i++) {\n                var element = expression.elements[i];\n                if (b.isSpreadElement(element)) {\n                    var spread = toConstant(element.argument);\n                    if (!(isSpreadable(spread) && constant)) {\n                        constant = false;\n                    }\n                    else {\n                        result_1.push.apply(result_1, spread);\n                    }\n                }\n                else {\n                    result_1.push(toConstant(element));\n                }\n            }\n            return result_1;\n        }\n        if (b.isBinaryExpression(expression)) {\n            var left = toConstant(expression.left);\n            var right = toConstant(expression.right);\n            return constant && binaryOperation_1[\"default\"](expression.operator, left, right);\n        }\n        if (b.isBooleanLiteral(expression)) {\n            return expression.value;\n        }\n        if (b.isCallExpression(expression)) {\n            var args = [];\n            for (var i = 0; constant && i < expression.arguments.length; i++) {\n                var arg = expression.arguments[i];\n                if (b.isSpreadElement(arg)) {\n                    var spread = toConstant(arg.argument);\n                    if (!(isSpreadable(spread) && constant)) {\n                        constant = false;\n                    }\n                    else {\n                        args.push.apply(args, spread);\n                    }\n                }\n                else {\n                    args.push(toConstant(arg));\n                }\n            }\n            if (!constant)\n                return;\n            if (b.isMemberExpression(expression.callee)) {\n                var object = toConstant(expression.callee.object);\n                if (!object || !constant) {\n                    constant = false;\n                    return;\n                }\n                var member = expression.callee.computed\n                    ? toConstant(expression.callee.property)\n                    : b.isIdentifier(expression.callee.property)\n                        ? expression.callee.property.name\n                        : undefined;\n                if (member === undefined && !expression.callee.computed) {\n                    constant = false;\n                }\n                if (!constant)\n                    return;\n                if (canCallMethod(object, '' + member)) {\n                    return object[member].apply(object, args);\n                }\n            }\n            else {\n                var callee = toConstant(expression.callee);\n                if (!constant)\n                    return;\n                return callee.apply(null, args);\n            }\n        }\n        if (b.isConditionalExpression(expression)) {\n            var test = toConstant(expression.test);\n            return test\n                ? toConstant(expression.consequent)\n                : toConstant(expression.alternate);\n        }\n        if (b.isIdentifier(expression)) {\n            if (options.constants &&\n                {}.hasOwnProperty.call(options.constants, expression.name)) {\n                return options.constants[expression.name];\n            }\n        }\n        if (b.isLogicalExpression(expression)) {\n            var left = toConstant(expression.left);\n            var right = toConstant(expression.right);\n            if (constant && expression.operator === '&&') {\n                return left && right;\n            }\n            if (constant && expression.operator === '||') {\n                return left || right;\n            }\n        }\n        if (b.isMemberExpression(expression)) {\n            var object = toConstant(expression.object);\n            if (!object || !constant) {\n                constant = false;\n                return;\n            }\n            var member = expression.computed\n                ? toConstant(expression.property)\n                : b.isIdentifier(expression.property)\n                    ? expression.property.name\n                    : undefined;\n            if (member === undefined && !expression.computed) {\n                constant = false;\n            }\n            if (!constant)\n                return;\n            if ({}.hasOwnProperty.call(object, '' + member) && member[0] !== '_') {\n                return object[member];\n            }\n        }\n        if (b.isNullLiteral(expression)) {\n            return null;\n        }\n        if (b.isNumericLiteral(expression)) {\n            return expression.value;\n        }\n        if (b.isObjectExpression(expression)) {\n            var result_2 = {};\n            for (var i = 0; constant && i < expression.properties.length; i++) {\n                var property = expression.properties[i];\n                if (b.isObjectProperty(property)) {\n                    if (property.shorthand) {\n                        constant = false;\n                        return;\n                    }\n                    var key = property.computed\n                        ? toConstant(property.key)\n                        : b.isIdentifier(property.key)\n                            ? property.key.name\n                            : b.isStringLiteral(property.key)\n                                ? property.key.value\n                                : undefined;\n                    if (!key || key[0] === '_') {\n                        constant = false;\n                    }\n                    if (!constant)\n                        return;\n                    var value = toConstant(property.value);\n                    if (!constant)\n                        return;\n                    result_2[key] = value;\n                }\n                else if (b.isObjectMethod(property)) {\n                    constant = false;\n                }\n                else if (b.isSpreadProperty(property)) {\n                    var argument = toConstant(property.argument);\n                    if (!argument)\n                        constant = false;\n                    if (!constant)\n                        return;\n                    Object.assign(result_2, argument);\n                }\n            }\n            return result_2;\n        }\n        if (b.isParenthesizedExpression(expression)) {\n            return toConstant(expression.expression);\n        }\n        if (b.isRegExpLiteral(expression)) {\n            return new RegExp(expression.pattern, expression.flags);\n        }\n        if (b.isSequenceExpression(expression)) {\n            for (var i = 0; i < expression.expressions.length - 1 && constant; i++) {\n                toConstant(expression.expressions[i]);\n            }\n            return toConstant(expression.expressions[expression.expressions.length - 1]);\n        }\n        if (b.isStringLiteral(expression)) {\n            return expression.value;\n        }\n        // TODO: TaggedTemplateExpression\n        if (b.isTemplateLiteral(expression)) {\n            var result_3 = '';\n            for (var i = 0; i < expression.quasis.length; i++) {\n                var quasi = expression.quasis[i];\n                result_3 += quasi.value.cooked;\n                if (i < expression.expressions.length) {\n                    result_3 += '' + toConstant(expression.expressions[i]);\n                }\n            }\n            return result_3;\n        }\n        if (b.isUnaryExpression(expression)) {\n            var argument = toConstant(expression.argument);\n            if (!constant) {\n                return;\n            }\n            switch (expression.operator) {\n                case '-':\n                    return -argument;\n                case '+':\n                    return +argument;\n                case '!':\n                    return !argument;\n                case '~':\n                    return ~argument;\n                case 'typeof':\n                    return typeof argument;\n                case 'void':\n                    return void argument;\n            }\n        }\n        constant = false;\n    }\n    var result = toConstant(expression);\n    return constant ? { constant: true, result: result } : { constant: false };\n}\nexports.expressionToConstant = expressionToConstant;\nfunction isSpreadable(value) {\n    return (typeof value === 'string' ||\n        Array.isArray(value) ||\n        (typeof Set !== 'undefined' && value instanceof Set) ||\n        (typeof Map !== 'undefined' && value instanceof Map));\n}\nfunction shallowEqual(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n        for (var key in a) {\n            if (a[key] !== b[key]) {\n                return false;\n            }\n        }\n        for (var key in b) {\n            if (a[key] !== b[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction canCallMethod(object, member) {\n    switch (typeof object) {\n        case 'boolean':\n            switch (member) {\n                case 'toString':\n                    return true;\n                default:\n                    return false;\n            }\n        case 'number':\n            switch (member) {\n                case 'toExponential':\n                case 'toFixed':\n                case 'toPrecision':\n                case 'toString':\n                    return true;\n                default:\n                    return false;\n            }\n        case 'string':\n            switch (member) {\n                case 'charAt':\n                case 'charCodeAt':\n                case 'codePointAt':\n                case 'concat':\n                case 'endsWith':\n                case 'includes':\n                case 'indexOf':\n                case 'lastIndexOf':\n                case 'match':\n                case 'normalize':\n                case 'padEnd':\n                case 'padStart':\n                case 'repeat':\n                case 'replace':\n                case 'search':\n                case 'slice':\n                case 'split':\n                case 'startsWith':\n                case 'substr':\n                case 'substring':\n                case 'toLowerCase':\n                case 'toUpperCase':\n                case 'trim':\n                    return true;\n                default:\n                    return false;\n            }\n        default:\n            if (object instanceof RegExp) {\n                switch (member) {\n                    case 'test':\n                    case 'exec':\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n            return {}.hasOwnProperty.call(object, member) && member[0] !== '_';\n    }\n}\nvar EMPTY_OBJECT = {};\nvar lastSrc = '';\nvar lastConstants = EMPTY_OBJECT;\nvar lastOptions = EMPTY_OBJECT;\nvar lastResult = null;\nvar lastWasConstant = false;\nfunction isConstant(src, constants, options) {\n    if (constants === void 0) { constants = EMPTY_OBJECT; }\n    if (options === void 0) { options = EMPTY_OBJECT; }\n    if (lastSrc === src &&\n        shallowEqual(lastConstants, constants) &&\n        shallowEqual(lastOptions, options)) {\n        return lastWasConstant;\n    }\n    lastSrc = src;\n    lastConstants = constants;\n    var ast;\n    try {\n        ast = babylon_1.parseExpression(src, options);\n    }\n    catch (ex) {\n        return (lastWasConstant = false);\n    }\n    var _a = expressionToConstant(ast, { constants: constants }), result = _a.result, constant = _a.constant;\n    lastResult = result;\n    return (lastWasConstant = constant);\n}\nexports.isConstant = isConstant;\nfunction toConstant(src, constants, options) {\n    if (constants === void 0) { constants = EMPTY_OBJECT; }\n    if (options === void 0) { options = EMPTY_OBJECT; }\n    if (!isConstant(src, constants, options)) {\n        throw new Error(JSON.stringify(src) + ' is not constant.');\n    }\n    return lastResult;\n}\nexports.toConstant = toConstant;\nexports[\"default\"] = isConstant;\nmodule.exports = isConstant;\nmodule.exports[\"default\"] = isConstant;\nmodule.exports.expressionToConstant = expressionToConstant;\nmodule.exports.isConstant = isConstant;\nmodule.exports.toConstant = toConstant;\n"]},"metadata":{},"sourceType":"script"}