{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapRegExp = exports.typeof = exports.objectSpread2 = exports.jsx = exports.asyncIterator = void 0;\n\nvar _template = require(\"@babel/template\");\n\nconst asyncIterator = {\n  minVersion: \"7.15.9\",\n  ast: () => _template.default.program.ast('\\nexport default function _asyncIterator(iterable) {\\n  var method,\\n    async,\\n    sync,\\n    retry = 2;\\n  if (typeof Symbol !== \"undefined\") {\\n    async = Symbol.asyncIterator;\\n    sync = Symbol.iterator;\\n  }\\n  while (retry--) {\\n    if (async && (method = iterable[async]) != null) {\\n      return method.call(iterable);\\n    }\\n    if (sync && (method = iterable[sync]) != null) {\\n      return new AsyncFromSyncIterator(method.call(iterable));\\n    }\\n    async = \"@@asyncIterator\";\\n    sync = \"@@iterator\";\\n  }\\n  throw new TypeError(\"Object is not async iterable\");\\n}\\nfunction AsyncFromSyncIterator(s) {\\n  AsyncFromSyncIterator = function (s) {\\n    this.s = s;\\n    this.n = s.next;\\n  };\\n  AsyncFromSyncIterator.prototype = {\\n     s: null,\\n     n: null,\\n    next: function () {\\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\\n    },\\n    return: function (value) {\\n      var ret = this.s.return;\\n      if (ret === undefined) {\\n        return Promise.resolve({ value: value, done: true });\\n      }\\n      return AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));\\n    },\\n    throw: function (value) {\\n      var thr = this.s.return;\\n      if (thr === undefined) return Promise.reject(value);\\n      return AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));\\n    },\\n  };\\n  function AsyncFromSyncIteratorContinuation(r) {\\n    \\n    if (Object(r) !== r) {\\n      return Promise.reject(new TypeError(r + \" is not an object.\"));\\n    }\\n    var done = r.done;\\n    return Promise.resolve(r.value).then(function (value) {\\n      return { value: value, done: done };\\n    });\\n  }\\n  return new AsyncFromSyncIterator(s);\\n}\\n')\n};\nexports.asyncIterator = asyncIterator;\nconst jsx = {\n  minVersion: \"7.0.0-beta.0\",\n  ast: () => _template.default.program.ast('\\nvar REACT_ELEMENT_TYPE;\\nexport default function _createRawReactElement(type, props, key, children) {\\n  if (!REACT_ELEMENT_TYPE) {\\n    REACT_ELEMENT_TYPE =\\n      (typeof Symbol === \"function\" &&\\n        \\n        Symbol[\"for\"] &&\\n        Symbol[\"for\"](\"react.element\")) ||\\n      0xeac7;\\n  }\\n  var defaultProps = type && type.defaultProps;\\n  var childrenLength = arguments.length - 3;\\n  if (!props && childrenLength !== 0) {\\n    \\n    \\n    props = { children: void 0 };\\n  }\\n  if (childrenLength === 1) {\\n    props.children = children;\\n  } else if (childrenLength > 1) {\\n    var childArray = new Array(childrenLength);\\n    for (var i = 0; i < childrenLength; i++) {\\n      childArray[i] = arguments[i + 3];\\n    }\\n    props.children = childArray;\\n  }\\n  if (props && defaultProps) {\\n    for (var propName in defaultProps) {\\n      if (props[propName] === void 0) {\\n        props[propName] = defaultProps[propName];\\n      }\\n    }\\n  } else if (!props) {\\n    props = defaultProps || {};\\n  }\\n  return {\\n    $$typeof: REACT_ELEMENT_TYPE,\\n    type: type,\\n    key: key === undefined ? null : \"\" + key,\\n    ref: null,\\n    props: props,\\n    _owner: null,\\n  };\\n}\\n')\n};\nexports.jsx = jsx;\nconst objectSpread2 = {\n  minVersion: \"7.5.0\",\n  ast: () => _template.default.program.ast('\\nimport defineProperty from \"defineProperty\";\\nfunction ownKeys(object, enumerableOnly) {\\n  var keys = Object.keys(object);\\n  if (Object.getOwnPropertySymbols) {\\n    var symbols = Object.getOwnPropertySymbols(object);\\n    if (enumerableOnly) {\\n      symbols = symbols.filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\\n      });\\n    }\\n    keys.push.apply(keys, symbols);\\n  }\\n  return keys;\\n}\\nexport default function _objectSpread2(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    if (i % 2) {\\n      ownKeys(Object(source), true).forEach(function (key) {\\n        defineProperty(target, key, source[key]);\\n      });\\n    } else if (Object.getOwnPropertyDescriptors) {\\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\\n    } else {\\n      ownKeys(Object(source)).forEach(function (key) {\\n        Object.defineProperty(\\n          target,\\n          key,\\n          Object.getOwnPropertyDescriptor(source, key)\\n        );\\n      });\\n    }\\n  }\\n  return target;\\n}\\n')\n};\nexports.objectSpread2 = objectSpread2;\nconst _typeof = {\n  minVersion: \"7.0.0-beta.0\",\n  ast: () => _template.default.program.ast('\\nexport default function _typeof(obj) {\\n  \"@babel/helpers - typeof\";\\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\\n    _typeof = function (obj) {\\n      return typeof obj;\\n    };\\n  } else {\\n    _typeof = function (obj) {\\n      return obj &&\\n        typeof Symbol === \"function\" &&\\n        obj.constructor === Symbol &&\\n        obj !== Symbol.prototype\\n        ? \"symbol\"\\n        : typeof obj;\\n    };\\n  }\\n  return _typeof(obj);\\n}\\n')\n};\nexports.typeof = _typeof;\nconst wrapRegExp = {\n  minVersion: \"7.2.6\",\n  ast: () => _template.default.program.ast('\\nimport setPrototypeOf from \"setPrototypeOf\";\\nimport inherits from \"inherits\";\\nexport default function _wrapRegExp() {\\n  _wrapRegExp = function (re, groups) {\\n    return new BabelRegExp(re, undefined, groups);\\n  };\\n  var _super = RegExp.prototype;\\n  var _groups = new WeakMap();\\n  function BabelRegExp(re, flags, groups) {\\n    var _this = new RegExp(re, flags);\\n    \\n    _groups.set(_this, groups || _groups.get(re));\\n    return setPrototypeOf(_this, BabelRegExp.prototype);\\n  }\\n  inherits(BabelRegExp, RegExp);\\n  BabelRegExp.prototype.exec = function (str) {\\n    var result = _super.exec.call(this, str);\\n    if (result) result.groups = buildGroups(result, this);\\n    return result;\\n  };\\n  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\\n    if (typeof substitution === \"string\") {\\n      var groups = _groups.get(this);\\n      return _super[Symbol.replace].call(\\n        this,\\n        str,\\n        substitution.replace(/\\\\$<([^>]+)>/g, function (_, name) {\\n          return \"$\" + groups[name];\\n        })\\n      );\\n    } else if (typeof substitution === \"function\") {\\n      var _this = this;\\n      return _super[Symbol.replace].call(this, str, function () {\\n        var args = arguments;\\n        \\n        if (typeof args[args.length - 1] !== \"object\") {\\n          args = [].slice.call(args);\\n          args.push(buildGroups(args, _this));\\n        }\\n        return substitution.apply(this, args);\\n      });\\n    } else {\\n      return _super[Symbol.replace].call(this, str, substitution);\\n    }\\n  };\\n  function buildGroups(result, re) {\\n    \\n    \\n    var g = _groups.get(re);\\n    return Object.keys(g).reduce(function (groups, name) {\\n      groups[name] = result[g[name]];\\n      return groups;\\n    }, Object.create(null));\\n  }\\n  return _wrapRegExp.apply(this, arguments);\\n}\\n')\n};\nexports.wrapRegExp = wrapRegExp;","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/@babel/helpers/lib/helpers-generated.js"],"names":["Object","defineProperty","exports","value","wrapRegExp","typeof","objectSpread2","jsx","asyncIterator","_template","require","minVersion","ast","default","program","_typeof"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,UAAR,GAAqBF,OAAO,CAACG,MAAR,GAAiBH,OAAO,CAACI,aAAR,GAAwBJ,OAAO,CAACK,GAAR,GAAcL,OAAO,CAACM,aAAR,GAAwB,KAAK,CAAzG;;AAEA,IAAIC,SAAS,GAAGC,OAAO,CAAC,iBAAD,CAAvB;;AAEA,MAAMF,aAAa,GAAG;AACpBG,EAAAA,UAAU,EAAE,QADQ;AAEpBC,EAAAA,GAAG,EAAE,MAAMH,SAAS,CAACI,OAAV,CAAkBC,OAAlB,CAA0BF,GAA1B,CAA8B,mrDAA9B;AAFS,CAAtB;AAIAV,OAAO,CAACM,aAAR,GAAwBA,aAAxB;AACA,MAAMD,GAAG,GAAG;AACVI,EAAAA,UAAU,EAAE,cADF;AAEVC,EAAAA,GAAG,EAAE,MAAMH,SAAS,CAACI,OAAV,CAAkBC,OAAlB,CAA0BF,GAA1B,CAA8B,wqCAA9B;AAFD,CAAZ;AAIAV,OAAO,CAACK,GAAR,GAAcA,GAAd;AACA,MAAMD,aAAa,GAAG;AACpBK,EAAAA,UAAU,EAAE,OADQ;AAEpBC,EAAAA,GAAG,EAAE,MAAMH,SAAS,CAACI,OAAV,CAAkBC,OAAlB,CAA0BF,GAA1B,CAA8B,gnCAA9B;AAFS,CAAtB;AAIAV,OAAO,CAACI,aAAR,GAAwBA,aAAxB;AACA,MAAMS,OAAO,GAAG;AACdJ,EAAAA,UAAU,EAAE,cADE;AAEdC,EAAAA,GAAG,EAAE,MAAMH,SAAS,CAACI,OAAV,CAAkBC,OAAlB,CAA0BF,GAA1B,CAA8B,geAA9B;AAFG,CAAhB;AAIAV,OAAO,CAACG,MAAR,GAAiBU,OAAjB;AACA,MAAMX,UAAU,GAAG;AACjBO,EAAAA,UAAU,EAAE,OADK;AAEjBC,EAAAA,GAAG,EAAE,MAAMH,SAAS,CAACI,OAAV,CAAkBC,OAAlB,CAA0BF,GAA1B,CAA8B,4zDAA9B;AAFM,CAAnB;AAIAV,OAAO,CAACE,UAAR,GAAqBA,UAArB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapRegExp = exports.typeof = exports.objectSpread2 = exports.jsx = exports.asyncIterator = void 0;\n\nvar _template = require(\"@babel/template\");\n\nconst asyncIterator = {\n  minVersion: \"7.15.9\",\n  ast: () => _template.default.program.ast('\\nexport default function _asyncIterator(iterable) {\\n  var method,\\n    async,\\n    sync,\\n    retry = 2;\\n  if (typeof Symbol !== \"undefined\") {\\n    async = Symbol.asyncIterator;\\n    sync = Symbol.iterator;\\n  }\\n  while (retry--) {\\n    if (async && (method = iterable[async]) != null) {\\n      return method.call(iterable);\\n    }\\n    if (sync && (method = iterable[sync]) != null) {\\n      return new AsyncFromSyncIterator(method.call(iterable));\\n    }\\n    async = \"@@asyncIterator\";\\n    sync = \"@@iterator\";\\n  }\\n  throw new TypeError(\"Object is not async iterable\");\\n}\\nfunction AsyncFromSyncIterator(s) {\\n  AsyncFromSyncIterator = function (s) {\\n    this.s = s;\\n    this.n = s.next;\\n  };\\n  AsyncFromSyncIterator.prototype = {\\n     s: null,\\n     n: null,\\n    next: function () {\\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\\n    },\\n    return: function (value) {\\n      var ret = this.s.return;\\n      if (ret === undefined) {\\n        return Promise.resolve({ value: value, done: true });\\n      }\\n      return AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));\\n    },\\n    throw: function (value) {\\n      var thr = this.s.return;\\n      if (thr === undefined) return Promise.reject(value);\\n      return AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));\\n    },\\n  };\\n  function AsyncFromSyncIteratorContinuation(r) {\\n    \\n    if (Object(r) !== r) {\\n      return Promise.reject(new TypeError(r + \" is not an object.\"));\\n    }\\n    var done = r.done;\\n    return Promise.resolve(r.value).then(function (value) {\\n      return { value: value, done: done };\\n    });\\n  }\\n  return new AsyncFromSyncIterator(s);\\n}\\n')\n};\nexports.asyncIterator = asyncIterator;\nconst jsx = {\n  minVersion: \"7.0.0-beta.0\",\n  ast: () => _template.default.program.ast('\\nvar REACT_ELEMENT_TYPE;\\nexport default function _createRawReactElement(type, props, key, children) {\\n  if (!REACT_ELEMENT_TYPE) {\\n    REACT_ELEMENT_TYPE =\\n      (typeof Symbol === \"function\" &&\\n        \\n        Symbol[\"for\"] &&\\n        Symbol[\"for\"](\"react.element\")) ||\\n      0xeac7;\\n  }\\n  var defaultProps = type && type.defaultProps;\\n  var childrenLength = arguments.length - 3;\\n  if (!props && childrenLength !== 0) {\\n    \\n    \\n    props = { children: void 0 };\\n  }\\n  if (childrenLength === 1) {\\n    props.children = children;\\n  } else if (childrenLength > 1) {\\n    var childArray = new Array(childrenLength);\\n    for (var i = 0; i < childrenLength; i++) {\\n      childArray[i] = arguments[i + 3];\\n    }\\n    props.children = childArray;\\n  }\\n  if (props && defaultProps) {\\n    for (var propName in defaultProps) {\\n      if (props[propName] === void 0) {\\n        props[propName] = defaultProps[propName];\\n      }\\n    }\\n  } else if (!props) {\\n    props = defaultProps || {};\\n  }\\n  return {\\n    $$typeof: REACT_ELEMENT_TYPE,\\n    type: type,\\n    key: key === undefined ? null : \"\" + key,\\n    ref: null,\\n    props: props,\\n    _owner: null,\\n  };\\n}\\n')\n};\nexports.jsx = jsx;\nconst objectSpread2 = {\n  minVersion: \"7.5.0\",\n  ast: () => _template.default.program.ast('\\nimport defineProperty from \"defineProperty\";\\nfunction ownKeys(object, enumerableOnly) {\\n  var keys = Object.keys(object);\\n  if (Object.getOwnPropertySymbols) {\\n    var symbols = Object.getOwnPropertySymbols(object);\\n    if (enumerableOnly) {\\n      symbols = symbols.filter(function (sym) {\\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\\n      });\\n    }\\n    keys.push.apply(keys, symbols);\\n  }\\n  return keys;\\n}\\nexport default function _objectSpread2(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i] != null ? arguments[i] : {};\\n    if (i % 2) {\\n      ownKeys(Object(source), true).forEach(function (key) {\\n        defineProperty(target, key, source[key]);\\n      });\\n    } else if (Object.getOwnPropertyDescriptors) {\\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\\n    } else {\\n      ownKeys(Object(source)).forEach(function (key) {\\n        Object.defineProperty(\\n          target,\\n          key,\\n          Object.getOwnPropertyDescriptor(source, key)\\n        );\\n      });\\n    }\\n  }\\n  return target;\\n}\\n')\n};\nexports.objectSpread2 = objectSpread2;\nconst _typeof = {\n  minVersion: \"7.0.0-beta.0\",\n  ast: () => _template.default.program.ast('\\nexport default function _typeof(obj) {\\n  \"@babel/helpers - typeof\";\\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\\n    _typeof = function (obj) {\\n      return typeof obj;\\n    };\\n  } else {\\n    _typeof = function (obj) {\\n      return obj &&\\n        typeof Symbol === \"function\" &&\\n        obj.constructor === Symbol &&\\n        obj !== Symbol.prototype\\n        ? \"symbol\"\\n        : typeof obj;\\n    };\\n  }\\n  return _typeof(obj);\\n}\\n')\n};\nexports.typeof = _typeof;\nconst wrapRegExp = {\n  minVersion: \"7.2.6\",\n  ast: () => _template.default.program.ast('\\nimport setPrototypeOf from \"setPrototypeOf\";\\nimport inherits from \"inherits\";\\nexport default function _wrapRegExp() {\\n  _wrapRegExp = function (re, groups) {\\n    return new BabelRegExp(re, undefined, groups);\\n  };\\n  var _super = RegExp.prototype;\\n  var _groups = new WeakMap();\\n  function BabelRegExp(re, flags, groups) {\\n    var _this = new RegExp(re, flags);\\n    \\n    _groups.set(_this, groups || _groups.get(re));\\n    return setPrototypeOf(_this, BabelRegExp.prototype);\\n  }\\n  inherits(BabelRegExp, RegExp);\\n  BabelRegExp.prototype.exec = function (str) {\\n    var result = _super.exec.call(this, str);\\n    if (result) result.groups = buildGroups(result, this);\\n    return result;\\n  };\\n  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\\n    if (typeof substitution === \"string\") {\\n      var groups = _groups.get(this);\\n      return _super[Symbol.replace].call(\\n        this,\\n        str,\\n        substitution.replace(/\\\\$<([^>]+)>/g, function (_, name) {\\n          return \"$\" + groups[name];\\n        })\\n      );\\n    } else if (typeof substitution === \"function\") {\\n      var _this = this;\\n      return _super[Symbol.replace].call(this, str, function () {\\n        var args = arguments;\\n        \\n        if (typeof args[args.length - 1] !== \"object\") {\\n          args = [].slice.call(args);\\n          args.push(buildGroups(args, _this));\\n        }\\n        return substitution.apply(this, args);\\n      });\\n    } else {\\n      return _super[Symbol.replace].call(this, str, substitution);\\n    }\\n  };\\n  function buildGroups(result, re) {\\n    \\n    \\n    var g = _groups.get(re);\\n    return Object.keys(g).reduce(function (groups, name) {\\n      groups[name] = result[g[name]];\\n      return groups;\\n    }, Object.create(null));\\n  }\\n  return _wrapRegExp.apply(this, arguments);\\n}\\n')\n};\nexports.wrapRegExp = wrapRegExp;"]},"metadata":{},"sourceType":"script"}