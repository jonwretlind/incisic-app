{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar isExpression = require('is-expression');\n\nvar characterParser = require('character-parser');\n\nvar error = require('pug-error');\n\nmodule.exports = lex;\nmodule.exports.Lexer = Lexer;\n\nfunction lex(str, options) {\n  var lexer = new Lexer(str, options);\n  return JSON.parse(JSON.stringify(lexer.getTokens()));\n}\n/**\n * Initialize `Lexer` with the given `str`.\n *\n * @param {String} str\n * @param {String} filename\n * @api private\n */\n\n\nfunction Lexer(str, options) {\n  options = options || {};\n\n  if (typeof str !== 'string') {\n    throw new Error('Expected source code to be a string but got \"' + typeof str + '\"');\n  }\n\n  if (typeof options !== 'object') {\n    throw new Error('Expected \"options\" to be an object but got \"' + typeof options + '\"');\n  } //Strip any UTF-8 BOM off of the start of `str`, if it exists.\n\n\n  str = str.replace(/^\\uFEFF/, '');\n  this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n  this.originalInput = this.input;\n  this.filename = options.filename;\n  this.interpolated = options.interpolated || false;\n  this.lineno = options.startingLine || 1;\n  this.colno = options.startingColumn || 1;\n  this.plugins = options.plugins || [];\n  this.indentStack = [0];\n  this.indentRe = null; // If #{}, !{} or #[] syntax is allowed when adding text\n\n  this.interpolationAllowed = true;\n  this.whitespaceRe = /[ \\n\\t]/;\n  this.tokens = [];\n  this.ended = false;\n}\n\n;\n/**\n * Lexer prototype.\n */\n\nLexer.prototype = {\n  constructor: Lexer,\n  error: function (code, message) {\n    var err = error(code, message, {\n      line: this.lineno,\n      column: this.colno,\n      filename: this.filename,\n      src: this.originalInput\n    });\n    throw err;\n  },\n  assert: function (value, message) {\n    if (!value) this.error('ASSERT_FAILED', message);\n  },\n  isExpression: function (exp) {\n    return isExpression(exp, {\n      throw: true\n    });\n  },\n  assertExpression: function (exp, noThrow) {\n    //this verifies that a JavaScript expression is valid\n    try {\n      this.callLexerFunction('isExpression', exp);\n      return true;\n    } catch (ex) {\n      if (noThrow) return false; // not coming from acorn\n\n      if (!ex.loc) throw ex;\n      this.incrementLine(ex.loc.line - 1);\n      this.incrementColumn(ex.loc.column);\n      var msg = 'Syntax Error: ' + ex.message.replace(/ \\([0-9]+:[0-9]+\\)$/, '');\n      this.error('SYNTAX_ERROR', msg);\n    }\n  },\n  assertNestingCorrect: function (exp) {\n    //this verifies that code is properly nested, but allows\n    //invalid JavaScript such as the contents of `attributes`\n    var res = characterParser(exp);\n\n    if (res.isNesting()) {\n      this.error('INCORRECT_NESTING', 'Nesting must match on expression `' + exp + '`');\n    }\n  },\n\n  /**\n   * Construct a token with the given `type` and `val`.\n   *\n   * @param {String} type\n   * @param {String} val\n   * @return {Object}\n   * @api private\n   */\n  tok: function (type, val) {\n    var res = {\n      type: type,\n      loc: {\n        start: {\n          line: this.lineno,\n          column: this.colno\n        },\n        filename: this.filename\n      }\n    };\n    if (val !== undefined) res.val = val;\n    return res;\n  },\n\n  /**\n   * Set the token's `loc.end` value.\n   * \n   * @param {Object} tok\n   * @returns {Object}\n   * @api private\n   */\n  tokEnd: function (tok) {\n    tok.loc.end = {\n      line: this.lineno,\n      column: this.colno\n    };\n    return tok;\n  },\n\n  /**\n   * Increment `this.lineno` and reset `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n  incrementLine: function (increment) {\n    this.lineno += increment;\n    if (increment) this.colno = 1;\n  },\n\n  /**\n   * Increment `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n  incrementColumn: function (increment) {\n    this.colno += increment;\n  },\n\n  /**\n   * Consume the given `len` of input.\n   *\n   * @param {Number} len\n   * @api private\n   */\n  consume: function (len) {\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Scan for `type` with the given `regexp`.\n   *\n   * @param {String} type\n   * @param {RegExp} regexp\n   * @return {Object}\n   * @api private\n   */\n  scan: function (regexp, type) {\n    var captures;\n\n    if (captures = regexp.exec(this.input)) {\n      var len = captures[0].length;\n      var val = captures[1];\n      var diff = len - (val ? val.length : 0);\n      var tok = this.tok(type, val);\n      this.consume(len);\n      this.incrementColumn(diff);\n      return tok;\n    }\n  },\n  scanEndOfLine: function (regexp, type) {\n    var captures;\n\n    if (captures = regexp.exec(this.input)) {\n      var whitespaceLength = 0;\n      var whitespace;\n      var tok;\n\n      if (whitespace = /^([ ]+)([^ ]*)/.exec(captures[0])) {\n        whitespaceLength = whitespace[1].length;\n        this.incrementColumn(whitespaceLength);\n      }\n\n      var newInput = this.input.substr(captures[0].length);\n\n      if (newInput[0] === ':') {\n        this.input = newInput;\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n\n      if (/^[ \\t]*(\\n|$)/.test(newInput)) {\n        this.input = newInput.substr(/^[ \\t]*/.exec(newInput)[0].length);\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n    }\n  },\n\n  /**\n   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.\n   *\n   * Make sure that when calling this function, colno is at the character\n   * immediately before the beginning.\n   *\n   * @return {Number}\n   * @api private\n   */\n  bracketExpression: function (skip) {\n    skip = skip || 0;\n    var start = this.input[skip];\n    assert(start === '(' || start === '{' || start === '[', 'The start character should be \"(\", \"{\" or \"[\"');\n    var end = characterParser.BRACKETS[start];\n    var range;\n\n    try {\n      range = characterParser.parseUntil(this.input, end, {\n        start: skip + 1\n      });\n    } catch (ex) {\n      if (ex.index !== undefined) {\n        var idx = ex.index; // starting from this.input[skip]\n\n        var tmp = this.input.substr(skip).indexOf('\\n'); // starting from this.input[0]\n\n        var nextNewline = tmp + skip;\n        var ptr = 0;\n\n        while (idx > nextNewline && tmp !== -1) {\n          this.incrementLine(1);\n          idx -= nextNewline + 1;\n          ptr += nextNewline + 1;\n          tmp = nextNewline = this.input.substr(ptr).indexOf('\\n');\n        }\n\n        ;\n        this.incrementColumn(idx);\n      }\n\n      if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n        this.error('NO_END_BRACKET', 'The end of the string reached with no closing bracket ' + end + ' found.');\n      } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n        this.error('BRACKET_MISMATCH', ex.message);\n      }\n\n      throw ex;\n    }\n\n    return range;\n  },\n  scanIndentation: function () {\n    var captures, re; // established regexp\n\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input); // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input); // spaces\n\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      } // established\n\n\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    return captures;\n  },\n\n  /**\n   * end-of-source.\n   */\n  eos: function () {\n    if (this.input.length) return;\n\n    if (this.interpolated) {\n      this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n    }\n\n    for (var i = 0; this.indentStack[i]; i++) {\n      this.tokens.push(this.tokEnd(this.tok('outdent')));\n    }\n\n    this.tokens.push(this.tokEnd(this.tok('eos')));\n    this.ended = true;\n    return true;\n  },\n\n  /**\n   * Blank line.\n   */\n  blank: function () {\n    var captures;\n\n    if (captures = /^\\n[ \\t]*\\n/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n      this.incrementLine(1);\n      return true;\n    }\n  },\n\n  /**\n   * Comment.\n   */\n  comment: function () {\n    var captures;\n\n    if (captures = /^\\/\\/(-)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('comment', captures[2]);\n      tok.buffer = '-' != captures[1];\n      this.interpolationAllowed = tok.buffer;\n      this.tokens.push(tok);\n      this.incrementColumn(captures[0].length);\n      this.tokEnd(tok);\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Interpolated tag.\n   */\n  interpolation: function () {\n    if (/^#\\{/.test(this.input)) {\n      var match = this.bracketExpression(1);\n      this.consume(match.end + 1);\n      var tok = this.tok('interpolation', match.src);\n      this.tokens.push(tok);\n      this.incrementColumn(2); // '#{'\n\n      this.assertExpression(match.src);\n      var splitted = match.src.split('\\n');\n      var lines = splitted.length - 1;\n      this.incrementLine(lines);\n      this.incrementColumn(splitted[lines].length + 1); // + 1 â†’ '}'\n\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Tag.\n   */\n  tag: function () {\n    var captures;\n\n    if (captures = /^(\\w(?:[-:\\w]*\\w)?)/.exec(this.input)) {\n      var tok,\n          name = captures[1],\n          len = captures[0].length;\n      this.consume(len);\n      tok = this.tok('tag', name);\n      this.tokens.push(tok);\n      this.incrementColumn(len);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Filter.\n   */\n  filter: function (opts) {\n    var tok = this.scan(/^:([\\w\\-]+)/, 'filter');\n    var inInclude = opts && opts.inInclude;\n\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      this.callLexerFunction('attrs');\n\n      if (!inInclude) {\n        this.interpolationAllowed = false;\n        this.callLexerFunction('pipelessText');\n      }\n\n      return true;\n    }\n  },\n\n  /**\n   * Doctype.\n   */\n  doctype: function () {\n    var node = this.scanEndOfLine(/^doctype *([^\\n]*)/, 'doctype');\n\n    if (node) {\n      this.tokens.push(this.tokEnd(node));\n      return true;\n    }\n  },\n\n  /**\n   * Id.\n   */\n  id: function () {\n    var tok = this.scan(/^#([\\w-]+)/, 'id');\n\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n\n    if (/^#/.test(this.input)) {\n      this.error('INVALID_ID', '\"' + /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] + '\" is not a valid ID.');\n    }\n  },\n\n  /**\n   * Class.\n   */\n  className: function () {\n    var tok = this.scan(/^\\.([_a-z0-9\\-]*[_a-z][_a-z0-9\\-]*)/i, 'class');\n\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n\n    if (/^\\.[_a-z0-9\\-]+/i.test(this.input)) {\n      this.error('INVALID_CLASS_NAME', 'Class names must contain at least one letter or underscore.');\n    }\n\n    if (/^\\./.test(this.input)) {\n      this.error('INVALID_CLASS_NAME', '\"' + /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] + '\" is not a valid class name.  Class names can only contain \"_\", \"-\", a-z and 0-9, and must contain at least one of \"_\", or a-z');\n    }\n  },\n\n  /**\n   * Text.\n   */\n  endInterpolation: function () {\n    if (this.interpolated && this.input[0] === ']') {\n      this.input = this.input.substr(1);\n      this.ended = true;\n      return true;\n    }\n  },\n  addText: function (type, value, prefix, escaped) {\n    var tok;\n    if (value + prefix === '') return;\n    prefix = prefix || '';\n    escaped = escaped || 0;\n    var indexOfEnd = this.interpolated ? value.indexOf(']') : -1;\n    var indexOfStart = this.interpolationAllowed ? value.indexOf('#[') : -1;\n    var indexOfEscaped = this.interpolationAllowed ? value.indexOf('\\\\#[') : -1;\n    var matchOfStringInterp = /(\\\\)?([#!]){((?:.|\\n)*)$/.exec(value);\n    var indexOfStringInterp = this.interpolationAllowed && matchOfStringInterp ? matchOfStringInterp.index : Infinity;\n    if (indexOfEnd === -1) indexOfEnd = Infinity;\n    if (indexOfStart === -1) indexOfStart = Infinity;\n    if (indexOfEscaped === -1) indexOfEscaped = Infinity;\n\n    if (indexOfEscaped !== Infinity && indexOfEscaped < indexOfEnd && indexOfEscaped < indexOfStart && indexOfEscaped < indexOfStringInterp) {\n      prefix = prefix + value.substring(0, indexOfEscaped) + '#[';\n      return this.addText(type, value.substring(indexOfEscaped + 3), prefix, escaped + 1);\n    }\n\n    if (indexOfStart !== Infinity && indexOfStart < indexOfEnd && indexOfStart < indexOfEscaped && indexOfStart < indexOfStringInterp) {\n      tok = this.tok(type, prefix + value.substring(0, indexOfStart));\n      this.incrementColumn(prefix.length + indexOfStart + escaped);\n      this.tokens.push(this.tokEnd(tok));\n      tok = this.tok('start-pug-interpolation');\n      this.incrementColumn(2);\n      this.tokens.push(this.tokEnd(tok));\n      var child = new this.constructor(value.substr(indexOfStart + 2), {\n        filename: this.filename,\n        interpolated: true,\n        startingLine: this.lineno,\n        startingColumn: this.colno\n      });\n      var interpolated;\n\n      try {\n        interpolated = child.getTokens();\n      } catch (ex) {\n        if (ex.code && /^PUG:/.test(ex.code)) {\n          this.colno = ex.column;\n          this.error(ex.code.substr(4), ex.msg);\n        }\n\n        throw ex;\n      }\n\n      this.colno = child.colno;\n      this.tokens = this.tokens.concat(interpolated);\n      tok = this.tok('end-pug-interpolation');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.addText(type, child.input);\n      return;\n    }\n\n    if (indexOfEnd !== Infinity && indexOfEnd < indexOfStart && indexOfEnd < indexOfEscaped && indexOfEnd < indexOfStringInterp) {\n      if (prefix + value.substring(0, indexOfEnd)) {\n        this.addText(type, value.substring(0, indexOfEnd), prefix);\n      }\n\n      this.ended = true;\n      this.input = value.substr(value.indexOf(']') + 1) + this.input;\n      return;\n    }\n\n    if (indexOfStringInterp !== Infinity) {\n      if (matchOfStringInterp[1]) {\n        prefix = prefix + value.substring(0, indexOfStringInterp) + '#{';\n        return this.addText(type, value.substring(indexOfStringInterp + 3), prefix, escaped + 1);\n      }\n\n      var before = value.substr(0, indexOfStringInterp);\n\n      if (prefix || before) {\n        before = prefix + before;\n        tok = this.tok(type, before);\n        this.incrementColumn(before.length + escaped);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      var rest = matchOfStringInterp[3];\n      var range;\n      tok = this.tok('interpolated-code');\n      this.incrementColumn(2);\n\n      try {\n        range = characterParser.parseUntil(rest, '}');\n      } catch (ex) {\n        if (ex.index !== undefined) {\n          this.incrementColumn(ex.index);\n        }\n\n        if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n          this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n        } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n          this.error('BRACKET_MISMATCH', ex.message);\n        } else {\n          throw ex;\n        }\n      }\n\n      tok.mustEscape = matchOfStringInterp[2] === '#';\n      tok.buffer = true;\n      tok.val = range.src;\n      this.assertExpression(range.src);\n\n      if (range.end + 1 < rest.length) {\n        rest = rest.substr(range.end + 1);\n        this.incrementColumn(range.end + 1);\n        this.tokens.push(this.tokEnd(tok));\n        this.addText(type, rest);\n      } else {\n        this.incrementColumn(rest.length);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      return;\n    }\n\n    value = prefix + value;\n    tok = this.tok(type, value);\n    this.incrementColumn(value.length + escaped);\n    this.tokens.push(this.tokEnd(tok));\n  },\n  text: function () {\n    var tok = this.scan(/^(?:\\| ?| )([^\\n]+)/, 'text') || this.scan(/^( )/, 'text') || this.scan(/^\\|( ?)/, 'text');\n\n    if (tok) {\n      this.addText('text', tok.val);\n      return true;\n    }\n  },\n  textHtml: function () {\n    var tok = this.scan(/^(<[^\\n]*)/, 'text-html');\n\n    if (tok) {\n      this.addText('text-html', tok.val);\n      return true;\n    }\n  },\n\n  /**\n   * Dot.\n   */\n  dot: function () {\n    var tok;\n\n    if (tok = this.scanEndOfLine(/^\\./, 'dot')) {\n      this.tokens.push(this.tokEnd(tok));\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Extends.\n   */\n  \"extends\": function () {\n    var tok = this.scan(/^extends?(?= |$|\\n)/, 'extends');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n\n      if (!this.callLexerFunction('path')) {\n        this.error('NO_EXTENDS_PATH', 'missing path for extends');\n      }\n\n      return true;\n    }\n\n    if (this.scan(/^extends?\\b/)) {\n      this.error('MALFORMED_EXTENDS', 'malformed extends');\n    }\n  },\n\n  /**\n   * Block prepend.\n   */\n  prepend: function () {\n    var captures;\n\n    if (captures = /^(?:block +)?prepend +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n\n      this.incrementColumn(len);\n      tok.mode = 'prepend';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block append.\n   */\n  append: function () {\n    var captures;\n\n    if (captures = /^(?:block +)?append +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n\n      this.incrementColumn(len);\n      tok.mode = 'append';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block.\n   */\n  block: function () {\n    var captures;\n\n    if (captures = /^block +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n\n      this.incrementColumn(len);\n      tok.mode = 'replace';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Mixin Block.\n   */\n  mixinBlock: function () {\n    var tok;\n\n    if (tok = this.scanEndOfLine(/^block/, 'mixin-block')) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Yield.\n   */\n  'yield': function () {\n    var tok = this.scanEndOfLine(/^yield/, 'yield');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Include.\n   */\n  include: function () {\n    var tok = this.scan(/^include(?=:| |$|\\n)/, 'include');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n\n      while (this.callLexerFunction('filter', {\n        inInclude: true\n      }));\n\n      if (!this.callLexerFunction('path')) {\n        if (/^[^ \\n]+/.test(this.input)) {\n          // if there is more text\n          this.fail();\n        } else {\n          // if not\n          this.error('NO_INCLUDE_PATH', 'missing path for include');\n        }\n      }\n\n      return true;\n    }\n\n    if (this.scan(/^include\\b/)) {\n      this.error('MALFORMED_INCLUDE', 'malformed include');\n    }\n  },\n\n  /**\n   * Path\n   */\n  path: function () {\n    var tok = this.scanEndOfLine(/^ ([^\\n]+)/, 'path');\n\n    if (tok && (tok.val = tok.val.trim())) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Case.\n   */\n  \"case\": function () {\n    var tok = this.scanEndOfLine(/^case +([^\\n]+)/, 'case');\n\n    if (tok) {\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^case\\b/)) {\n      this.error('NO_CASE_EXPRESSION', 'missing expression for case');\n    }\n  },\n\n  /**\n   * When.\n   */\n  when: function () {\n    var tok = this.scanEndOfLine(/^when +([^:\\n]+)/, 'when');\n\n    if (tok) {\n      var parser = characterParser(tok.val);\n\n      while (parser.isNesting() || parser.isString()) {\n        var rest = /:([^:\\n]+)/.exec(this.input);\n        if (!rest) break;\n        tok.val += rest[0];\n        this.consume(rest[0].length);\n        this.incrementColumn(rest[0].length);\n        parser = characterParser(tok.val);\n      }\n\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^when\\b/)) {\n      this.error('NO_WHEN_EXPRESSION', 'missing expression for when');\n    }\n  },\n\n  /**\n   * Default.\n   */\n  \"default\": function () {\n    var tok = this.scanEndOfLine(/^default/, 'default');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^default\\b/)) {\n      this.error('DEFAULT_WITH_EXPRESSION', 'default should not have an expression');\n    }\n  },\n\n  /**\n   * Call mixin.\n   */\n  call: function () {\n    var tok, captures, increment;\n\n    if (captures = /^\\+(\\s*)(([-\\w]+)|(#\\{))/.exec(this.input)) {\n      // try to consume simple or interpolated call\n      if (captures[3]) {\n        // simple call\n        increment = captures[0].length;\n        this.consume(increment);\n        tok = this.tok('call', captures[3]);\n      } else {\n        // interpolated call\n        var match = this.bracketExpression(2 + captures[1].length);\n        increment = match.end + 1;\n        this.consume(increment);\n        this.assertExpression(match.src);\n        tok = this.tok('call', '#{' + match.src + '}');\n      }\n\n      this.incrementColumn(increment);\n      tok.args = null; // Check for args (not attributes)\n\n      if (captures = /^ *\\(/.exec(this.input)) {\n        var range = this.bracketExpression(captures[0].length - 1);\n\n        if (!/^\\s*[-\\w]+ *=/.test(range.src)) {\n          // not attributes\n          this.incrementColumn(1);\n          this.consume(range.end + 1);\n          tok.args = range.src;\n          this.assertExpression('[' + tok.args + ']');\n\n          for (var i = 0; i <= tok.args.length; i++) {\n            if (tok.args[i] === '\\n') {\n              this.incrementLine(1);\n            } else {\n              this.incrementColumn(1);\n            }\n          }\n        }\n      }\n\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Mixin.\n   */\n  mixin: function () {\n    var captures;\n\n    if (captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))? */.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('mixin', captures[1]);\n      tok.args = captures[2] || null;\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Conditional.\n   */\n  conditional: function () {\n    var captures;\n\n    if (captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var type = captures[1].replace(/ /g, '-');\n      var js = captures[2] && captures[2].trim(); // type can be \"if\", \"else-if\" and \"else\"\n\n      var tok = this.tok(type, js);\n      this.incrementColumn(captures[0].length - js.length);\n\n      switch (type) {\n        case 'if':\n        case 'else-if':\n          this.assertExpression(js);\n          break;\n\n        case 'unless':\n          this.assertExpression(js);\n          tok.val = '!(' + js + ')';\n          tok.type = 'if';\n          break;\n\n        case 'else':\n          if (js) {\n            this.error('ELSE_CONDITION', '`else` cannot have a condition, perhaps you meant `else if`');\n          }\n\n          break;\n      }\n\n      this.incrementColumn(js.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * While.\n   */\n  \"while\": function () {\n    var captures, tok;\n\n    if (captures = /^while +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      this.assertExpression(captures[1]);\n      tok = this.tok('while', captures[1]);\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^while\\b/)) {\n      this.error('NO_WHILE_EXPRESSION', 'missing expression for while');\n    }\n  },\n\n  /**\n   * Each.\n   */\n  each: function () {\n    var captures;\n\n    if (captures = /^(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? * in *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('each', captures[1]);\n      tok.key = captures[2] || null;\n      this.incrementColumn(captures[0].length - captures[3].length);\n      this.assertExpression(captures[3]);\n      tok.code = captures[3];\n      this.incrementColumn(captures[3].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^(?:each|for)\\b/)) {\n      this.error('MALFORMED_EACH', 'malformed each');\n    }\n\n    if (captures = /^- *(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? +in +([^\\n]+)/.exec(this.input)) {\n      this.error('MALFORMED_EACH', 'Pug each and for should no longer be prefixed with a dash (\"-\"). They are pug keywords and not part of JavaScript.');\n    }\n  },\n\n  /**\n   * Code.\n   */\n  code: function () {\n    var captures;\n\n    if (captures = /^(!?=|-)[ \\t]*([^\\n]+)/.exec(this.input)) {\n      var flags = captures[1];\n      var code = captures[2];\n      var shortened = 0;\n\n      if (this.interpolated) {\n        var parsed;\n\n        try {\n          parsed = characterParser.parseUntil(code, ']');\n        } catch (err) {\n          if (err.index !== undefined) {\n            this.incrementColumn(captures[0].length - code.length + err.index);\n          }\n\n          if (err.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n            this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n          } else if (err.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n            this.error('BRACKET_MISMATCH', err.message);\n          } else {\n            throw err;\n          }\n        }\n\n        shortened = code.length - parsed.end;\n        code = parsed.src;\n      }\n\n      var consumed = captures[0].length - shortened;\n      this.consume(consumed);\n      var tok = this.tok('code', code);\n      tok.mustEscape = flags.charAt(0) === '=';\n      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '='; // p #[!=    abc] hey\n      //     ^              original colno\n      //     -------------- captures[0]\n      //           -------- captures[2]\n      //     ------         captures[0] - captures[2]\n      //           ^        after colno\n      // =   abc\n      // ^                  original colno\n      // -------            captures[0]\n      //     ---            captures[2]\n      // ----               captures[0] - captures[2]\n      //     ^              after colno\n\n      this.incrementColumn(captures[0].length - captures[2].length);\n      if (tok.buffer) this.assertExpression(code);\n      this.tokens.push(tok); // p #[!=    abc] hey\n      //           ^        original colno\n      //              ----- shortened\n      //           ---      code\n      //              ^     after colno\n      // =   abc\n      //     ^              original colno\n      //                    shortened\n      //     ---            code\n      //        ^           after colno\n\n      this.incrementColumn(code.length);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Block code.\n   */\n  blockCode: function () {\n    var tok;\n\n    if (tok = this.scanEndOfLine(/^-/, 'blockcode')) {\n      this.tokens.push(this.tokEnd(tok));\n      this.interpolationAllowed = false;\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Attribute Name.\n   */\n  attribute: function (str) {\n    var quote = '';\n    var quoteRe = /['\"]/;\n    var key = '';\n    var i; // consume all whitespace before the key\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    if (i === str.length) {\n      return '';\n    }\n\n    var tok = this.tok('attribute'); // quote?\n\n    if (quoteRe.test(str[i])) {\n      quote = str[i];\n      this.incrementColumn(1);\n      i++;\n    } // start looping through the key\n\n\n    for (; i < str.length; i++) {\n      if (quote) {\n        if (str[i] === quote) {\n          this.incrementColumn(1);\n          i++;\n          break;\n        }\n      } else {\n        if (this.whitespaceRe.test(str[i]) || str[i] === '!' || str[i] === '=' || str[i] === ',') {\n          break;\n        }\n      }\n\n      key += str[i];\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    tok.name = key;\n    var valueResponse = this.attributeValue(str.substr(i));\n\n    if (valueResponse.val) {\n      tok.val = valueResponse.val;\n      tok.mustEscape = valueResponse.mustEscape;\n    } else {\n      // was a boolean attribute (ex: `input(disabled)`)\n      tok.val = true;\n      tok.mustEscape = true;\n    }\n\n    str = valueResponse.remainingSource;\n    this.tokens.push(this.tokEnd(tok));\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) {\n        break;\n      }\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    if (str[i] === ',') {\n      this.incrementColumn(1);\n      i++;\n    }\n\n    return str.substr(i);\n  },\n\n  /**\n   * Attribute Value.\n   */\n  attributeValue: function (str) {\n    var quoteRe = /['\"]/;\n    var val = '';\n    var done, i, x;\n    var escapeAttr = true;\n    var state = characterParser.defaultState();\n    var col = this.colno;\n    var line = this.lineno; // consume all whitespace before the equals sign\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n\n      if (str[i] === '\\n') {\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n\n    if (i === str.length) {\n      return {\n        remainingSource: str\n      };\n    }\n\n    if (str[i] === '!') {\n      escapeAttr = false;\n      col++;\n      i++;\n      if (str[i] !== '=') this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[i] + ' expected `=`');\n    }\n\n    if (str[i] !== '=') {\n      // check for anti-pattern `div(\"foo\"bar)`\n      if (i === 0 && str && !this.whitespaceRe.test(str[0]) && str[0] !== ',') {\n        this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[0] + ' expected `=`');\n      } else {\n        return {\n          remainingSource: str\n        };\n      }\n    }\n\n    this.lineno = line;\n    this.colno = col + 1;\n    i++; // consume all whitespace before the value\n\n    for (; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    line = this.lineno;\n    col = this.colno; // start looping through the value\n\n    for (; i < str.length; i++) {\n      // if the character is in a string or in parentheses/brackets/braces\n      if (!(state.isNesting() || state.isString())) {\n        if (this.whitespaceRe.test(str[i])) {\n          done = false; // find the first non-whitespace character\n\n          for (x = i; x < str.length; x++) {\n            if (!this.whitespaceRe.test(str[x])) {\n              // if it is a JavaScript punctuator, then assume that it is\n              // a part of the value\n              const isNotPunctuator = !characterParser.isPunctuator(str[x]);\n              const isQuote = quoteRe.test(str[x]);\n              const isColon = str[x] === ':';\n              const isSpreadOperator = str[x] + str[x + 1] + str[x + 2] === '...';\n\n              if ((isNotPunctuator || isQuote || isColon || isSpreadOperator) && this.assertExpression(val, true)) {\n                done = true;\n              }\n\n              break;\n            }\n          } // if everything else is whitespace, return now so last attribute\n          // does not include trailing whitespace\n\n\n          if (done || x === str.length) {\n            break;\n          }\n        } // if there's no whitespace and the character is not ',', the\n        // attribute did not end.\n\n\n        if (str[i] === ',' && this.assertExpression(val, true)) {\n          break;\n        }\n      }\n\n      state = characterParser.parseChar(str[i], state);\n      val += str[i];\n\n      if (str[i] === '\\n') {\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n\n    this.assertExpression(val);\n    this.lineno = line;\n    this.colno = col;\n    return {\n      val: val,\n      mustEscape: escapeAttr,\n      remainingSource: str.substr(i)\n    };\n  },\n\n  /**\n   * Attributes.\n   */\n  attrs: function () {\n    var tok;\n\n    if ('(' == this.input.charAt(0)) {\n      tok = this.tok('start-attributes');\n      var index = this.bracketExpression().end;\n      var str = this.input.substr(1, index - 1);\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.assertNestingCorrect(str);\n      this.consume(index + 1);\n\n      while (str) {\n        str = this.attribute(str);\n      }\n\n      tok = this.tok('end-attributes');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * &attributes block\n   */\n  attributesBlock: function () {\n    if (/^&attributes\\b/.test(this.input)) {\n      var consumed = 11;\n      this.consume(consumed);\n      var tok = this.tok('&attributes');\n      this.incrementColumn(consumed);\n      var args = this.bracketExpression();\n      consumed = args.end + 1;\n      this.consume(consumed);\n      tok.val = args.src;\n      this.incrementColumn(consumed);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Indent | Outdent | Newline.\n   */\n  indent: function () {\n    var captures = this.scanIndentation();\n    var tok;\n\n    if (captures) {\n      var indents = captures[1].length;\n      this.incrementLine(1);\n      this.consume(indents + 1);\n\n      if (' ' == this.input[0] || '\\t' == this.input[0]) {\n        this.error('INVALID_INDENTATION', 'Invalid indentation, you can use tabs or spaces but not both');\n      } // blank line\n\n\n      if ('\\n' == this.input[0]) {\n        this.interpolationAllowed = true;\n        return this.tokEnd(this.tok('newline'));\n      } // outdent\n\n\n      if (indents < this.indentStack[0]) {\n        var outdent_count = 0;\n\n        while (this.indentStack[0] > indents) {\n          if (this.indentStack[1] < indents) {\n            this.error('INCONSISTENT_INDENTATION', 'Inconsistent indentation. Expecting either ' + this.indentStack[1] + ' or ' + this.indentStack[0] + ' spaces/tabs.');\n          }\n\n          outdent_count++;\n          this.indentStack.shift();\n        }\n\n        while (outdent_count--) {\n          this.colno = 1;\n          tok = this.tok('outdent');\n          this.colno = this.indentStack[0] + 1;\n          this.tokens.push(this.tokEnd(tok));\n        } // indent\n\n      } else if (indents && indents != this.indentStack[0]) {\n        tok = this.tok('indent', indents);\n        this.colno = 1 + indents;\n        this.tokens.push(this.tokEnd(tok));\n        this.indentStack.unshift(indents); // newline\n      } else {\n        tok = this.tok('newline');\n        this.colno = 1 + Math.min(this.indentStack[0] || 0, indents);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      this.interpolationAllowed = true;\n      return true;\n    }\n  },\n  pipelessText: function pipelessText(indents) {\n    while (this.callLexerFunction('blank'));\n\n    var captures = this.scanIndentation();\n    indents = indents || captures && captures[1].length;\n\n    if (indents > this.indentStack[0]) {\n      this.tokens.push(this.tokEnd(this.tok('start-pipeless-text')));\n      var tokens = [];\n      var token_indent = [];\n      var isMatch; // Index in this.input. Can't use this.consume because we might need to\n      // retry lexing the block.\n\n      var stringPtr = 0;\n\n      do {\n        // text has `\\n` as a prefix\n        var i = this.input.substr(stringPtr + 1).indexOf('\\n');\n        if (-1 == i) i = this.input.length - stringPtr - 1;\n        var str = this.input.substr(stringPtr + 1, i);\n        var lineCaptures = this.indentRe.exec('\\n' + str);\n        var lineIndents = lineCaptures && lineCaptures[1].length;\n        isMatch = lineIndents >= indents;\n        token_indent.push(isMatch);\n        isMatch = isMatch || !str.trim();\n\n        if (isMatch) {\n          // consume test along with `\\n` prefix if match\n          stringPtr += str.length + 1;\n          tokens.push(str.substr(indents));\n        } else if (lineIndents > this.indentStack[0]) {\n          // line is indented less than the first line but is still indented\n          // need to retry lexing the text block\n          this.tokens.pop();\n          return pipelessText.call(this, lineCaptures[1].length);\n        }\n      } while (this.input.length - stringPtr && isMatch);\n\n      this.consume(stringPtr);\n\n      while (this.input.length === 0 && tokens[tokens.length - 1] === '') tokens.pop();\n\n      tokens.forEach(function (token, i) {\n        var tok;\n        this.incrementLine(1);\n        if (i !== 0) tok = this.tok('newline');\n        if (token_indent[i]) this.incrementColumn(indents);\n        if (tok) this.tokens.push(this.tokEnd(tok));\n        this.addText('text', token);\n      }.bind(this));\n      this.tokens.push(this.tokEnd(this.tok('end-pipeless-text')));\n      return true;\n    }\n  },\n\n  /**\n   * Slash.\n   */\n  slash: function () {\n    var tok = this.scan(/^\\//, 'slash');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * ':'\n   */\n  colon: function () {\n    var tok = this.scan(/^: +/, ':');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n  fail: function () {\n    this.error('UNEXPECTED_TEXT', 'unexpected text \"' + this.input.substr(0, 5) + '\"');\n  },\n  callLexerFunction: function (func) {\n    var rest = [];\n\n    for (var i = 1; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n\n    var pluginArgs = [this].concat(rest);\n\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n\n      if (plugin[func] && plugin[func].apply(plugin, pluginArgs)) {\n        return true;\n      }\n    }\n\n    return this[func].apply(this, rest);\n  },\n\n  /**\n   * Move to the next token\n   *\n   * @api private\n   */\n  advance: function () {\n    return this.callLexerFunction('blank') || this.callLexerFunction('eos') || this.callLexerFunction('endInterpolation') || this.callLexerFunction('yield') || this.callLexerFunction('doctype') || this.callLexerFunction('interpolation') || this.callLexerFunction('case') || this.callLexerFunction('when') || this.callLexerFunction('default') || this.callLexerFunction('extends') || this.callLexerFunction('append') || this.callLexerFunction('prepend') || this.callLexerFunction('block') || this.callLexerFunction('mixinBlock') || this.callLexerFunction('include') || this.callLexerFunction('mixin') || this.callLexerFunction('call') || this.callLexerFunction('conditional') || this.callLexerFunction('each') || this.callLexerFunction('while') || this.callLexerFunction('tag') || this.callLexerFunction('filter') || this.callLexerFunction('blockCode') || this.callLexerFunction('code') || this.callLexerFunction('id') || this.callLexerFunction('dot') || this.callLexerFunction('className') || this.callLexerFunction('attrs') || this.callLexerFunction('attributesBlock') || this.callLexerFunction('indent') || this.callLexerFunction('text') || this.callLexerFunction('textHtml') || this.callLexerFunction('comment') || this.callLexerFunction('slash') || this.callLexerFunction('colon') || this.fail();\n  },\n\n  /**\n   * Return an array of tokens for the current file\n   *\n   * @returns {Array.<Token>}\n   * @api public\n   */\n  getTokens: function () {\n    while (!this.ended) {\n      this.callLexerFunction('advance');\n    }\n\n    return this.tokens;\n  }\n};","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/babel-plugin-transform-react-pug/node_modules/pug-lexer/index.js"],"names":["assert","require","isExpression","characterParser","error","module","exports","lex","Lexer","str","options","lexer","JSON","parse","stringify","getTokens","Error","replace","input","originalInput","filename","interpolated","lineno","startingLine","colno","startingColumn","plugins","indentStack","indentRe","interpolationAllowed","whitespaceRe","tokens","ended","prototype","constructor","code","message","err","line","column","src","value","exp","throw","assertExpression","noThrow","callLexerFunction","ex","loc","incrementLine","incrementColumn","msg","assertNestingCorrect","res","isNesting","tok","type","val","start","undefined","tokEnd","end","increment","consume","len","substr","scan","regexp","captures","exec","length","diff","scanEndOfLine","whitespaceLength","whitespace","newInput","test","bracketExpression","skip","BRACKETS","range","parseUntil","index","idx","tmp","indexOf","nextNewline","ptr","scanIndentation","re","eos","i","push","blank","comment","buffer","interpolation","match","splitted","split","lines","tag","name","filter","opts","inInclude","doctype","node","id","className","endInterpolation","addText","prefix","escaped","indexOfEnd","indexOfStart","indexOfEscaped","matchOfStringInterp","indexOfStringInterp","Infinity","substring","child","concat","before","rest","mustEscape","text","textHtml","dot","prepend","trim","slice","join","charAt","mode","append","block","mixinBlock","include","fail","path","when","parser","isString","call","args","mixin","conditional","js","each","key","flags","shortened","parsed","consumed","blockCode","attribute","quote","quoteRe","valueResponse","attributeValue","remainingSource","done","x","escapeAttr","state","defaultState","col","isNotPunctuator","isPunctuator","isQuote","isColon","isSpreadOperator","parseChar","attrs","attributesBlock","indent","indents","outdent_count","shift","unshift","Math","min","pipelessText","token_indent","isMatch","stringPtr","lineCaptures","lineIndents","pop","forEach","token","bind","slash","colon","func","arguments","pluginArgs","plugin","apply","advance"],"mappings":"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","sourcesContent":["'use strict';\n\nvar assert = require('assert');\nvar isExpression = require('is-expression');\nvar characterParser = require('character-parser');\nvar error = require('pug-error');\n\nmodule.exports = lex;\nmodule.exports.Lexer = Lexer;\nfunction lex(str, options) {\n  var lexer = new Lexer(str, options);\n  return JSON.parse(JSON.stringify(lexer.getTokens()));\n}\n\n/**\n * Initialize `Lexer` with the given `str`.\n *\n * @param {String} str\n * @param {String} filename\n * @api private\n */\n\nfunction Lexer(str, options) {\n  options = options || {};\n  if (typeof str !== 'string') {\n    throw new Error('Expected source code to be a string but got \"' + (typeof str) + '\"')\n  }\n  if (typeof options !== 'object') {\n    throw new Error('Expected \"options\" to be an object but got \"' + (typeof options) + '\"')\n  }\n  //Strip any UTF-8 BOM off of the start of `str`, if it exists.\n  str = str.replace(/^\\uFEFF/, '');\n  this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n  this.originalInput = this.input;\n  this.filename = options.filename;\n  this.interpolated = options.interpolated || false;\n  this.lineno = options.startingLine || 1;\n  this.colno = options.startingColumn || 1;\n  this.plugins = options.plugins || [];\n  this.indentStack = [0];\n  this.indentRe = null;\n  // If #{}, !{} or #[] syntax is allowed when adding text\n  this.interpolationAllowed = true;\n  this.whitespaceRe = /[ \\n\\t]/;\n\n  this.tokens = [];\n  this.ended = false;\n};\n\n/**\n * Lexer prototype.\n */\n\nLexer.prototype = {\n\n  constructor: Lexer,\n\n  error: function (code, message) {\n    var err = error(code, message, {line: this.lineno, column: this.colno, filename: this.filename, src: this.originalInput});\n    throw err;\n  },\n\n  assert: function (value, message) {\n    if (!value) this.error('ASSERT_FAILED', message);\n  },\n\n  isExpression: function (exp) {\n    return isExpression(exp, {\n      throw: true\n    });\n  },\n\n  assertExpression: function (exp, noThrow) {\n    //this verifies that a JavaScript expression is valid\n    try {\n      this.callLexerFunction('isExpression', exp);\n      return true;\n    } catch (ex) {\n      if (noThrow) return false;\n\n      // not coming from acorn\n      if (!ex.loc) throw ex;\n\n      this.incrementLine(ex.loc.line - 1);\n      this.incrementColumn(ex.loc.column);\n      var msg = 'Syntax Error: ' + ex.message.replace(/ \\([0-9]+:[0-9]+\\)$/, '');\n      this.error('SYNTAX_ERROR', msg);\n    }\n  },\n\n  assertNestingCorrect: function (exp) {\n    //this verifies that code is properly nested, but allows\n    //invalid JavaScript such as the contents of `attributes`\n    var res = characterParser(exp)\n    if (res.isNesting()) {\n      this.error('INCORRECT_NESTING', 'Nesting must match on expression `' + exp + '`')\n    }\n  },\n\n  /**\n   * Construct a token with the given `type` and `val`.\n   *\n   * @param {String} type\n   * @param {String} val\n   * @return {Object}\n   * @api private\n   */\n\n  tok: function(type, val){\n    var res = {\n      type: type, \n      loc: {\n        start: {\n          line: this.lineno, \n          column: this.colno\n        },\n        filename: this.filename\n      }\n    };\n\n    if (val !== undefined) res.val = val;\n\n    return res;\n  },\n  \n  /**\n   * Set the token's `loc.end` value.\n   * \n   * @param {Object} tok\n   * @returns {Object}\n   * @api private\n   */\n  \n  tokEnd: function(tok){\n    tok.loc.end = {\n      line: this.lineno,\n      column: this.colno\n    };\n    return tok;\n  },\n\n  /**\n   * Increment `this.lineno` and reset `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n\n  incrementLine: function(increment){\n    this.lineno += increment;\n    if (increment) this.colno = 1;\n  },\n\n  /**\n   * Increment `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n\n  incrementColumn: function(increment){\n    this.colno += increment\n  },\n\n  /**\n   * Consume the given `len` of input.\n   *\n   * @param {Number} len\n   * @api private\n   */\n\n  consume: function(len){\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Scan for `type` with the given `regexp`.\n   *\n   * @param {String} type\n   * @param {RegExp} regexp\n   * @return {Object}\n   * @api private\n   */\n\n  scan: function(regexp, type){\n    var captures;\n    if (captures = regexp.exec(this.input)) {\n      var len = captures[0].length;\n      var val = captures[1];\n      var diff = len - (val ? val.length : 0);\n      var tok = this.tok(type, val);\n      this.consume(len);\n      this.incrementColumn(diff);\n      return tok;\n    }\n  },\n  scanEndOfLine: function (regexp, type) {\n    var captures;\n    if (captures = regexp.exec(this.input)) {\n      var whitespaceLength = 0;\n      var whitespace;\n      var tok;\n      if (whitespace = /^([ ]+)([^ ]*)/.exec(captures[0])) {\n        whitespaceLength = whitespace[1].length;\n        this.incrementColumn(whitespaceLength);\n      }\n      var newInput = this.input.substr(captures[0].length);\n      if (newInput[0] === ':') {\n        this.input = newInput;\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n      if (/^[ \\t]*(\\n|$)/.test(newInput)) {\n        this.input = newInput.substr(/^[ \\t]*/.exec(newInput)[0].length);\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n    }\n  },\n\n  /**\n   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.\n   *\n   * Make sure that when calling this function, colno is at the character\n   * immediately before the beginning.\n   *\n   * @return {Number}\n   * @api private\n   */\n\n  bracketExpression: function(skip){\n    skip = skip || 0;\n    var start = this.input[skip];\n    assert(start === '(' || start === '{' || start === '[',\n           'The start character should be \"(\", \"{\" or \"[\"');\n    var end = characterParser.BRACKETS[start];\n    var range;\n    try {\n      range = characterParser.parseUntil(this.input, end, {start: skip + 1});\n    } catch (ex) {\n      if (ex.index !== undefined) {\n        var idx = ex.index;\n        // starting from this.input[skip]\n        var tmp = this.input.substr(skip).indexOf('\\n');\n        // starting from this.input[0]\n        var nextNewline = tmp + skip;\n        var ptr = 0;\n        while (idx > nextNewline && tmp !== -1) {\n          this.incrementLine(1);\n          idx -= nextNewline + 1;\n          ptr += nextNewline + 1;\n          tmp = nextNewline = this.input.substr(ptr).indexOf('\\n');\n        };\n\n        this.incrementColumn(idx);\n      }\n      if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n        this.error('NO_END_BRACKET', 'The end of the string reached with no closing bracket ' + end + ' found.');\n      } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n        this.error('BRACKET_MISMATCH', ex.message);\n      }\n      throw ex;\n    }\n    return range;\n  },\n\n  scanIndentation: function() {\n    var captures, re;\n\n    // established regexp\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input);\n    // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input);\n\n      // spaces\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      }\n\n      // established\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    return captures;\n  },\n\n  /**\n   * end-of-source.\n   */\n\n  eos: function() {\n    if (this.input.length) return;\n    if (this.interpolated) {\n      this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n    }\n    for (var i = 0; this.indentStack[i]; i++) {\n      this.tokens.push(this.tokEnd(this.tok('outdent')));\n    }\n    this.tokens.push(this.tokEnd(this.tok('eos')));\n    this.ended = true;\n    return true;\n  },\n\n  /**\n   * Blank line.\n   */\n\n  blank: function() {\n    var captures;\n    if (captures = /^\\n[ \\t]*\\n/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n      this.incrementLine(1);\n      return true;\n    }\n  },\n\n  /**\n   * Comment.\n   */\n\n  comment: function() {\n    var captures;\n    if (captures = /^\\/\\/(-)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('comment', captures[2]);\n      tok.buffer = '-' != captures[1];\n      this.interpolationAllowed = tok.buffer;\n      this.tokens.push(tok);\n      this.incrementColumn(captures[0].length);\n      this.tokEnd(tok);\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Interpolated tag.\n   */\n\n  interpolation: function() {\n    if (/^#\\{/.test(this.input)) {\n      var match = this.bracketExpression(1);\n      this.consume(match.end + 1);\n      var tok = this.tok('interpolation', match.src);\n      this.tokens.push(tok);\n      this.incrementColumn(2); // '#{'\n      this.assertExpression(match.src);\n\n      var splitted = match.src.split('\\n');\n      var lines = splitted.length - 1;\n      this.incrementLine(lines);\n      this.incrementColumn(splitted[lines].length + 1); // + 1 â†’ '}'\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Tag.\n   */\n\n  tag: function() {\n    var captures;\n\n    if (captures = /^(\\w(?:[-:\\w]*\\w)?)/.exec(this.input)) {\n      var tok, name = captures[1], len = captures[0].length;\n      this.consume(len);\n      tok = this.tok('tag', name);\n      this.tokens.push(tok);\n      this.incrementColumn(len);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Filter.\n   */\n\n  filter: function(opts) {\n    var tok = this.scan(/^:([\\w\\-]+)/, 'filter');\n    var inInclude = opts && opts.inInclude;\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      this.callLexerFunction('attrs');\n      if (!inInclude) {\n        this.interpolationAllowed = false;\n        this.callLexerFunction('pipelessText');\n      }\n      return true;\n    }\n  },\n\n  /**\n   * Doctype.\n   */\n\n  doctype: function() {\n    var node = this.scanEndOfLine(/^doctype *([^\\n]*)/, 'doctype');\n    if (node) {\n      this.tokens.push(this.tokEnd(node));\n      return true;\n    }\n  },\n\n  /**\n   * Id.\n   */\n\n  id: function() {\n    var tok = this.scan(/^#([\\w-]+)/, 'id');\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n    if (/^#/.test(this.input)) {\n      this.error('INVALID_ID', '\"' + /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] + '\" is not a valid ID.');\n    }\n  },\n\n  /**\n   * Class.\n   */\n\n  className: function() {\n    var tok = this.scan(/^\\.([_a-z0-9\\-]*[_a-z][_a-z0-9\\-]*)/i, 'class');\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n    if (/^\\.[_a-z0-9\\-]+/i.test(this.input)) {\n      this.error('INVALID_CLASS_NAME', 'Class names must contain at least one letter or underscore.');\n    }\n    if (/^\\./.test(this.input)) {\n      this.error('INVALID_CLASS_NAME', '\"' + /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] + '\" is not a valid class name.  Class names can only contain \"_\", \"-\", a-z and 0-9, and must contain at least one of \"_\", or a-z');\n    }\n  },\n\n  /**\n   * Text.\n   */\n  endInterpolation: function () {\n    if (this.interpolated && this.input[0] === ']') {\n      this.input = this.input.substr(1);\n      this.ended = true;\n      return true;\n    }\n  },\n  addText: function (type, value, prefix, escaped) {\n    var tok;\n    if (value + prefix === '') return;\n    prefix = prefix || '';\n    escaped = escaped || 0;\n    var indexOfEnd = this.interpolated ? value.indexOf(']') : -1;\n    var indexOfStart = this.interpolationAllowed ? value.indexOf('#[') : -1;\n    var indexOfEscaped = this.interpolationAllowed ? value.indexOf('\\\\#[') : -1;\n    var matchOfStringInterp = /(\\\\)?([#!]){((?:.|\\n)*)$/.exec(value);\n    var indexOfStringInterp = this.interpolationAllowed && matchOfStringInterp ? matchOfStringInterp.index : Infinity;\n\n    if (indexOfEnd === -1) indexOfEnd = Infinity;\n    if (indexOfStart === -1) indexOfStart = Infinity;\n    if (indexOfEscaped === -1) indexOfEscaped = Infinity;\n\n    if (indexOfEscaped !== Infinity && indexOfEscaped < indexOfEnd && indexOfEscaped < indexOfStart && indexOfEscaped < indexOfStringInterp) {\n      prefix = prefix + value.substring(0, indexOfEscaped) + '#[';\n      return this.addText(type, value.substring(indexOfEscaped + 3), prefix, escaped + 1);\n    }\n    if (indexOfStart !== Infinity && indexOfStart < indexOfEnd && indexOfStart < indexOfEscaped && indexOfStart < indexOfStringInterp) {\n      tok = this.tok(type, prefix + value.substring(0, indexOfStart));\n      this.incrementColumn(prefix.length + indexOfStart + escaped);\n      this.tokens.push(this.tokEnd(tok));\n      tok = this.tok('start-pug-interpolation');\n      this.incrementColumn(2);\n      this.tokens.push(this.tokEnd(tok));\n      var child = new this.constructor(value.substr(indexOfStart + 2), {\n        filename: this.filename,\n        interpolated: true,\n        startingLine: this.lineno,\n        startingColumn: this.colno\n      });\n      var interpolated;\n      try {\n        interpolated = child.getTokens();\n      } catch (ex) {\n        if (ex.code && /^PUG:/.test(ex.code)) {\n          this.colno = ex.column;\n          this.error(ex.code.substr(4), ex.msg);\n        }\n        throw ex;\n      }\n      this.colno = child.colno;\n      this.tokens = this.tokens.concat(interpolated);\n      tok = this.tok('end-pug-interpolation');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.addText(type, child.input);\n      return;\n    }\n    if (indexOfEnd !== Infinity && indexOfEnd < indexOfStart && indexOfEnd < indexOfEscaped && indexOfEnd < indexOfStringInterp) {\n      if (prefix + value.substring(0, indexOfEnd)) {\n        this.addText(type, value.substring(0, indexOfEnd), prefix);\n      }\n      this.ended = true;\n      this.input = value.substr(value.indexOf(']') + 1) + this.input;\n      return;\n    }\n    if (indexOfStringInterp !== Infinity) {\n      if (matchOfStringInterp[1]) {\n        prefix = prefix + value.substring(0, indexOfStringInterp) + '#{';\n        return this.addText(type, value.substring(indexOfStringInterp + 3), prefix, escaped + 1);\n      }\n      var before = value.substr(0, indexOfStringInterp);\n      if (prefix || before) {\n        before = prefix + before;\n        tok = this.tok(type, before);\n        this.incrementColumn(before.length + escaped);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      var rest = matchOfStringInterp[3];\n      var range;\n      tok = this.tok('interpolated-code');\n      this.incrementColumn(2);\n      try {\n        range = characterParser.parseUntil(rest, '}');\n      } catch (ex) {\n        if (ex.index !== undefined) {\n          this.incrementColumn(ex.index);\n        }\n        if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n          this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n        } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n          this.error('BRACKET_MISMATCH', ex.message);\n        } else {\n          throw ex;\n        }\n      }\n      tok.mustEscape = matchOfStringInterp[2] === '#';\n      tok.buffer = true;\n      tok.val = range.src;\n      this.assertExpression(range.src);\n\n      if (range.end + 1 < rest.length) {\n        rest = rest.substr(range.end + 1);\n        this.incrementColumn(range.end + 1);\n        this.tokens.push(this.tokEnd(tok));\n        this.addText(type, rest);\n      } else {\n        this.incrementColumn(rest.length);\n        this.tokens.push(this.tokEnd(tok));\n      }\n      return;\n    }\n\n    value = prefix + value;\n    tok = this.tok(type, value);\n    this.incrementColumn(value.length + escaped);\n    this.tokens.push(this.tokEnd(tok));\n  },\n\n  text: function() {\n    var tok = this.scan(/^(?:\\| ?| )([^\\n]+)/, 'text') ||\n      this.scan(/^( )/, 'text') ||\n      this.scan(/^\\|( ?)/, 'text');\n    if (tok) {\n      this.addText('text', tok.val);\n      return true;\n    }\n  },\n\n  textHtml: function () {\n    var tok = this.scan(/^(<[^\\n]*)/, 'text-html');\n    if (tok) {\n      this.addText('text-html', tok.val);\n      return true;\n    }\n  },\n\n  /**\n   * Dot.\n   */\n\n  dot: function() {\n    var tok;\n    if (tok = this.scanEndOfLine(/^\\./, 'dot')) {\n      this.tokens.push(this.tokEnd(tok));\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Extends.\n   */\n\n  \"extends\": function() {\n    var tok = this.scan(/^extends?(?= |$|\\n)/, 'extends');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      if (!this.callLexerFunction('path')) {\n        this.error('NO_EXTENDS_PATH', 'missing path for extends');\n      }\n      return true;\n    }\n    if (this.scan(/^extends?\\b/)) {\n      this.error('MALFORMED_EXTENDS', 'malformed extends');\n    }\n  },\n\n  /**\n   * Block prepend.\n   */\n\n  prepend: function() {\n    var captures;\n    if (captures = /^(?:block +)?prepend +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n      while(this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n      this.incrementColumn(len);\n      tok.mode = 'prepend';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block append.\n   */\n\n  append: function() {\n    var captures;\n    if (captures = /^(?:block +)?append +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n      while(this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n      this.incrementColumn(len);\n      tok.mode = 'append';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block.\n   */\n\n  block: function() {\n    var captures;\n    if (captures = /^block +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n      while(this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n      this.incrementColumn(len);\n      tok.mode = 'replace';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Mixin Block.\n   */\n\n  mixinBlock: function() {\n    var tok;\n    if (tok = this.scanEndOfLine(/^block/, 'mixin-block')) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Yield.\n   */\n\n  'yield': function() {\n    var tok = this.scanEndOfLine(/^yield/, 'yield');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Include.\n   */\n\n  include: function() {\n    var tok = this.scan(/^include(?=:| |$|\\n)/, 'include');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      while (this.callLexerFunction('filter', { inInclude: true }));\n      if (!this.callLexerFunction('path')) {\n        if (/^[^ \\n]+/.test(this.input)) {\n          // if there is more text\n          this.fail();\n        } else {\n          // if not\n          this.error('NO_INCLUDE_PATH', 'missing path for include');\n        }\n      }\n      return true;\n    }\n    if (this.scan(/^include\\b/)) {\n      this.error('MALFORMED_INCLUDE', 'malformed include');\n    }\n  },\n\n  /**\n   * Path\n   */\n\n  path: function() {\n    var tok = this.scanEndOfLine(/^ ([^\\n]+)/, 'path');\n    if (tok && (tok.val = tok.val.trim())) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Case.\n   */\n\n  \"case\": function() {\n    var tok = this.scanEndOfLine(/^case +([^\\n]+)/, 'case');\n    if (tok) {\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    if (this.scan(/^case\\b/)) {\n      this.error('NO_CASE_EXPRESSION', 'missing expression for case');\n    }\n  },\n\n  /**\n   * When.\n   */\n\n  when: function() {\n    var tok = this.scanEndOfLine(/^when +([^:\\n]+)/, 'when');\n    if (tok) {\n      var parser = characterParser(tok.val);\n      while (parser.isNesting() || parser.isString()) {\n        var rest = /:([^:\\n]+)/.exec(this.input);\n        if (!rest) break;\n\n        tok.val += rest[0];\n        this.consume(rest[0].length);\n        this.incrementColumn(rest[0].length);\n        parser = characterParser(tok.val);\n      }\n\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    if (this.scan(/^when\\b/)) {\n      this.error('NO_WHEN_EXPRESSION', 'missing expression for when');\n    }\n  },\n\n  /**\n   * Default.\n   */\n\n  \"default\": function() {\n    var tok = this.scanEndOfLine(/^default/, 'default');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    if (this.scan(/^default\\b/)) {\n      this.error('DEFAULT_WITH_EXPRESSION', 'default should not have an expression');\n    }\n  },\n\n  /**\n   * Call mixin.\n   */\n\n  call: function(){\n\n    var tok, captures, increment;\n    if (captures = /^\\+(\\s*)(([-\\w]+)|(#\\{))/.exec(this.input)) {\n      // try to consume simple or interpolated call\n      if (captures[3]) {\n        // simple call\n        increment = captures[0].length;\n        this.consume(increment);\n        tok = this.tok('call', captures[3]);\n      } else {\n        // interpolated call\n        var match = this.bracketExpression(2 + captures[1].length);\n        increment = match.end + 1;\n        this.consume(increment);\n        this.assertExpression(match.src);\n        tok = this.tok('call', '#{'+match.src+'}');\n      }\n\n      this.incrementColumn(increment);\n\n      tok.args = null;\n      // Check for args (not attributes)\n      if (captures = /^ *\\(/.exec(this.input)) {\n        var range = this.bracketExpression(captures[0].length - 1);\n        if (!/^\\s*[-\\w]+ *=/.test(range.src)) { // not attributes\n          this.incrementColumn(1);\n          this.consume(range.end + 1);\n          tok.args = range.src;\n          this.assertExpression('[' + tok.args + ']');\n          for (var i = 0; i <= tok.args.length; i++) {\n            if (tok.args[i] === '\\n') {\n              this.incrementLine(1);\n            } else {\n              this.incrementColumn(1);\n            }\n          }\n        }\n      }\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Mixin.\n   */\n\n  mixin: function(){\n    var captures;\n    if (captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))? */.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('mixin', captures[1]);\n      tok.args = captures[2] || null;\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Conditional.\n   */\n\n  conditional: function() {\n    var captures;\n    if (captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var type = captures[1].replace(/ /g, '-');\n      var js = captures[2] && captures[2].trim();\n      // type can be \"if\", \"else-if\" and \"else\"\n      var tok = this.tok(type, js);\n      this.incrementColumn(captures[0].length - js.length);\n\n      switch (type) {\n        case 'if':\n        case 'else-if':\n          this.assertExpression(js);\n          break;\n        case 'unless':\n          this.assertExpression(js);\n          tok.val = '!(' + js + ')';\n          tok.type = 'if';\n          break;\n        case 'else':\n          if (js) {\n            this.error(\n              'ELSE_CONDITION',\n              '`else` cannot have a condition, perhaps you meant `else if`'\n            );\n          }\n          break;\n      }\n      this.incrementColumn(js.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * While.\n   */\n\n  \"while\": function() {\n    var captures, tok;\n    if (captures = /^while +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      this.assertExpression(captures[1]);\n      tok = this.tok('while', captures[1]);\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    if (this.scan(/^while\\b/)) {\n      this.error('NO_WHILE_EXPRESSION', 'missing expression for while');\n    }\n  },\n\n  /**\n   * Each.\n   */\n\n  each: function() {\n    var captures;\n    if (captures = /^(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? * in *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('each', captures[1]);\n      tok.key = captures[2] || null;\n      this.incrementColumn(captures[0].length - captures[3].length);\n      this.assertExpression(captures[3])\n      tok.code = captures[3];\n      this.incrementColumn(captures[3].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    if (this.scan(/^(?:each|for)\\b/)) {\n      this.error('MALFORMED_EACH', 'malformed each');\n    }\n    if (captures = /^- *(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? +in +([^\\n]+)/.exec(this.input)) {\n      this.error(\n        'MALFORMED_EACH',\n        'Pug each and for should no longer be prefixed with a dash (\"-\"). They are pug keywords and not part of JavaScript.'\n      );\n    }\n  },\n\n  /**\n   * Code.\n   */\n\n  code: function() {\n    var captures;\n    if (captures = /^(!?=|-)[ \\t]*([^\\n]+)/.exec(this.input)) {\n      var flags = captures[1];\n      var code = captures[2];\n      var shortened = 0;\n      if (this.interpolated) {\n        var parsed;\n        try {\n          parsed = characterParser.parseUntil(code, ']');\n        } catch (err) {\n          if (err.index !== undefined) {\n            this.incrementColumn(captures[0].length - code.length + err.index);\n          }\n          if (err.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n            this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n          } else if (err.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n            this.error('BRACKET_MISMATCH', err.message);\n          } else {\n            throw err;\n          }\n        }\n        shortened = code.length - parsed.end;\n        code = parsed.src;\n      }\n      var consumed = captures[0].length - shortened;\n      this.consume(consumed);\n      var tok = this.tok('code', code);\n      tok.mustEscape = flags.charAt(0) === '=';\n      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';\n\n      // p #[!=    abc] hey\n      //     ^              original colno\n      //     -------------- captures[0]\n      //           -------- captures[2]\n      //     ------         captures[0] - captures[2]\n      //           ^        after colno\n\n      // =   abc\n      // ^                  original colno\n      // -------            captures[0]\n      //     ---            captures[2]\n      // ----               captures[0] - captures[2]\n      //     ^              after colno\n      this.incrementColumn(captures[0].length - captures[2].length);\n      if (tok.buffer) this.assertExpression(code);\n      this.tokens.push(tok);\n\n      // p #[!=    abc] hey\n      //           ^        original colno\n      //              ----- shortened\n      //           ---      code\n      //              ^     after colno\n\n      // =   abc\n      //     ^              original colno\n      //                    shortened\n      //     ---            code\n      //        ^           after colno\n      this.incrementColumn(code.length);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Block code.\n   */\n  blockCode: function() {\n    var tok\n    if (tok = this.scanEndOfLine(/^-/, 'blockcode')) {\n      this.tokens.push(this.tokEnd(tok));\n      this.interpolationAllowed = false;\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n  \n  /**\n   * Attribute Name.\n   */\n  attribute: function(str){\n    var quote = '';\n    var quoteRe = /['\"]/;\n    var key = '';\n    var i;\n    \n    // consume all whitespace before the key\n    for(i = 0; i < str.length; i++){\n      if(!this.whitespaceRe.test(str[i])) break;\n      if(str[i] === '\\n'){\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n    \n    if(i === str.length){\n      return '';\n    }\n    \n    var tok = this.tok('attribute');\n    \n    // quote?\n    if(quoteRe.test(str[i])){\n      quote = str[i];\n      this.incrementColumn(1);\n      i++;\n    }\n    \n    // start looping through the key\n    for (; i < str.length; i++) {\n      \n      if(quote){\n        if (str[i] === quote) {\n          this.incrementColumn(1);\n          i++;\n          break;\n        }\n      } else {\n        if(this.whitespaceRe.test(str[i]) || str[i] === '!' || str[i] === '=' || str[i] === ',') {\n          break;\n        }\n      }\n      \n      key += str[i];\n        \n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n    \n    tok.name = key;\n    \n    var valueResponse = this.attributeValue(str.substr(i));\n    \n    if (valueResponse.val) {\n      tok.val = valueResponse.val;\n      tok.mustEscape = valueResponse.mustEscape;\n    } else {\n      // was a boolean attribute (ex: `input(disabled)`)\n      tok.val = true;\n      tok.mustEscape = true;\n    }\n    \n    str = valueResponse.remainingSource;\n    \n    this.tokens.push(this.tokEnd(tok));\n    \n    for(i = 0; i < str.length; i++){\n      if(!this.whitespaceRe.test(str[i])) {\n        break;\n      }\n      if(str[i] === '\\n'){\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n    \n    if(str[i] === ','){\n      this.incrementColumn(1);\n      i++;\n    }\n    \n    return str.substr(i);\n  },\n  \n  /**\n   * Attribute Value.\n   */\n  attributeValue: function(str){\n    var quoteRe = /['\"]/;\n    var val = '';\n    var done, i, x;\n    var escapeAttr = true;\n    var state = characterParser.defaultState();\n    var col = this.colno;\n    var line = this.lineno;\n    \n    // consume all whitespace before the equals sign\n    for(i = 0; i < str.length; i++){\n      if(!this.whitespaceRe.test(str[i])) break;\n      if(str[i] === '\\n'){\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n    \n    if(i === str.length){\n      return { remainingSource: str };\n    }\n    \n    if(str[i] === '!'){\n      escapeAttr = false;\n      col++;\n      i++;\n      if (str[i] !== '=') this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[i] + ' expected `=`');\n    }\n    \n    if(str[i] !== '='){\n      // check for anti-pattern `div(\"foo\"bar)`\n      if (i === 0 && str && !this.whitespaceRe.test(str[0]) && str[0] !== ','){\n        this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[0] + ' expected `=`');\n      } else {\n        return { remainingSource: str };\n      }\n    }\n    \n    this.lineno = line;\n    this.colno = col + 1;\n    i++;\n    \n    // consume all whitespace before the value\n    for(; i < str.length; i++){\n      if(!this.whitespaceRe.test(str[i])) break;\n      if(str[i] === '\\n'){\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n    \n    line = this.lineno;\n    col = this.colno;\n    \n    // start looping through the value\n    for (; i < str.length; i++) {\n      // if the character is in a string or in parentheses/brackets/braces\n      if (!(state.isNesting() || state.isString())){\n        \n        if (this.whitespaceRe.test(str[i])) {\n          done = false;\n          \n          // find the first non-whitespace character\n          for (x = i; x < str.length; x++) {\n            if (!this.whitespaceRe.test(str[x])) {\n              // if it is a JavaScript punctuator, then assume that it is\n              // a part of the value\n              const isNotPunctuator = !characterParser.isPunctuator(str[x])\n              const isQuote = quoteRe.test(str[x])\n              const isColon = str[x] === ':'\n              const isSpreadOperator = str[x] + str[x + 1] + str[x + 2] === '...'\n              if ((isNotPunctuator || isQuote || isColon || isSpreadOperator) && this.assertExpression(val, true)) {\n                done = true;\n              }\n              break;\n            }\n          }\n          \n          // if everything else is whitespace, return now so last attribute\n          // does not include trailing whitespace\n          if(done || x === str.length){\n            break;\n          }\n        }\n        \n        // if there's no whitespace and the character is not ',', the\n        // attribute did not end.\n        if(str[i] === ',' && this.assertExpression(val, true)){\n          break;\n        }\n      }\n      \n      state = characterParser.parseChar(str[i], state);\n      val += str[i];\n      \n      if (str[i] === '\\n') {\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n    \n    this.assertExpression(val);\n    \n    this.lineno = line;\n    this.colno = col;\n    \n    return { val: val, mustEscape: escapeAttr, remainingSource: str.substr(i) };\n  },\n\n  /**\n   * Attributes.\n   */\n  \n  attrs: function() {\n    var tok;\n    \n    if ('(' == this.input.charAt(0)) {\n      tok = this.tok('start-attributes');\n      var index = this.bracketExpression().end;\n      var str = this.input.substr(1, index-1);\n\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.assertNestingCorrect(str);\n      this.consume(index + 1);\n\n      while(str){\n        str = this.attribute(str);\n      }\n\n      tok = this.tok('end-attributes');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * &attributes block\n   */\n  attributesBlock: function () {\n    if (/^&attributes\\b/.test(this.input)) {\n      var consumed = 11;\n      this.consume(consumed);\n      var tok = this.tok('&attributes');\n      this.incrementColumn(consumed);\n      var args = this.bracketExpression();\n      consumed = args.end + 1;\n      this.consume(consumed);\n      tok.val = args.src;\n      this.incrementColumn(consumed);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Indent | Outdent | Newline.\n   */\n\n  indent: function() {\n    var captures = this.scanIndentation();\n    var tok;\n\n    if (captures) {\n      var indents = captures[1].length;\n\n      this.incrementLine(1);\n      this.consume(indents + 1);\n\n      if (' ' == this.input[0] || '\\t' == this.input[0]) {\n        this.error('INVALID_INDENTATION', 'Invalid indentation, you can use tabs or spaces but not both');\n      }\n\n      // blank line\n      if ('\\n' == this.input[0]) {\n        this.interpolationAllowed = true;\n        return this.tokEnd(this.tok('newline'));\n      }\n\n      // outdent\n      if (indents < this.indentStack[0]) {\n        var outdent_count = 0;\n        while (this.indentStack[0] > indents) {\n          if (this.indentStack[1] < indents) {\n            this.error('INCONSISTENT_INDENTATION', 'Inconsistent indentation. Expecting either ' + this.indentStack[1] + ' or ' + this.indentStack[0] + ' spaces/tabs.');\n          }\n          outdent_count++;\n          this.indentStack.shift();\n        }\n        while(outdent_count--){\n          this.colno = 1;\n          tok = this.tok('outdent');\n          this.colno = this.indentStack[0] + 1;\n          this.tokens.push(this.tokEnd(tok));\n        }\n      // indent\n      } else if (indents && indents != this.indentStack[0]) {\n        tok = this.tok('indent', indents);\n        this.colno = 1 + indents;\n        this.tokens.push(this.tokEnd(tok));\n        this.indentStack.unshift(indents);\n      // newline\n      } else {\n        tok = this.tok('newline');\n        this.colno = 1 + Math.min(this.indentStack[0] || 0, indents);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      this.interpolationAllowed = true;\n      return true;\n    }\n  },\n\n  pipelessText: function pipelessText(indents) {\n    while (this.callLexerFunction('blank'));\n\n    var captures = this.scanIndentation();\n\n    indents = indents || captures && captures[1].length;\n    if (indents > this.indentStack[0]) {\n      this.tokens.push(this.tokEnd(this.tok('start-pipeless-text')));\n      var tokens = [];\n      var token_indent = [];\n      var isMatch;\n      // Index in this.input. Can't use this.consume because we might need to\n      // retry lexing the block.\n      var stringPtr = 0;\n      do {\n        // text has `\\n` as a prefix\n        var i = this.input.substr(stringPtr + 1).indexOf('\\n');\n        if (-1 == i) i = this.input.length - stringPtr - 1;\n        var str = this.input.substr(stringPtr + 1, i);\n        var lineCaptures = this.indentRe.exec('\\n' + str);\n        var lineIndents = lineCaptures && lineCaptures[1].length;\n        isMatch = lineIndents >= indents;\n        token_indent.push(isMatch);\n        isMatch = isMatch || !str.trim();\n        if (isMatch) {\n          // consume test along with `\\n` prefix if match\n          stringPtr += str.length + 1;\n          tokens.push(str.substr(indents));\n        } else if (lineIndents > this.indentStack[0]) {\n          // line is indented less than the first line but is still indented\n          // need to retry lexing the text block\n          this.tokens.pop();\n          return pipelessText.call(this, lineCaptures[1].length);\n        }\n      } while((this.input.length - stringPtr) && isMatch);\n      this.consume(stringPtr);\n      while (this.input.length === 0 && tokens[tokens.length - 1] === '') tokens.pop();\n      tokens.forEach(function (token, i) {\n        var tok;\n        this.incrementLine(1);\n        if (i !== 0) tok = this.tok('newline');\n        if (token_indent[i]) this.incrementColumn(indents);\n        if (tok) this.tokens.push(this.tokEnd(tok));\n        this.addText('text', token);\n      }.bind(this));\n      this.tokens.push(this.tokEnd(this.tok('end-pipeless-text')));\n      return true;\n    }\n  },\n\n  /**\n   * Slash.\n   */\n\n  slash: function() {\n    var tok = this.scan(/^\\//, 'slash');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * ':'\n   */\n\n  colon: function() {\n    var tok = this.scan(/^: +/, ':');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  fail: function () {\n    this.error('UNEXPECTED_TEXT', 'unexpected text \"' + this.input.substr(0, 5) + '\"');\n  },\n\n  callLexerFunction: function (func) {\n    var rest = [];\n    for (var i = 1; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n    var pluginArgs = [this].concat(rest);\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n      if (plugin[func] && plugin[func].apply(plugin, pluginArgs)) {\n        return true;\n      }\n    }\n    return this[func].apply(this, rest);\n  },\n\n  /**\n   * Move to the next token\n   *\n   * @api private\n   */\n\n  advance: function() {\n    return this.callLexerFunction('blank')\n      || this.callLexerFunction('eos')\n      || this.callLexerFunction('endInterpolation')\n      || this.callLexerFunction('yield')\n      || this.callLexerFunction('doctype')\n      || this.callLexerFunction('interpolation')\n      || this.callLexerFunction('case')\n      || this.callLexerFunction('when')\n      || this.callLexerFunction('default')\n      || this.callLexerFunction('extends')\n      || this.callLexerFunction('append')\n      || this.callLexerFunction('prepend')\n      || this.callLexerFunction('block')\n      || this.callLexerFunction('mixinBlock')\n      || this.callLexerFunction('include')\n      || this.callLexerFunction('mixin')\n      || this.callLexerFunction('call')\n      || this.callLexerFunction('conditional')\n      || this.callLexerFunction('each')\n      || this.callLexerFunction('while')\n      || this.callLexerFunction('tag')\n      || this.callLexerFunction('filter')\n      || this.callLexerFunction('blockCode')\n      || this.callLexerFunction('code')\n      || this.callLexerFunction('id')\n      || this.callLexerFunction('dot')\n      || this.callLexerFunction('className')\n      || this.callLexerFunction('attrs')\n      || this.callLexerFunction('attributesBlock')\n      || this.callLexerFunction('indent')\n      || this.callLexerFunction('text')\n      || this.callLexerFunction('textHtml')\n      || this.callLexerFunction('comment')\n      || this.callLexerFunction('slash')\n      || this.callLexerFunction('colon')\n      || this.fail();\n  },\n\n  /**\n   * Return an array of tokens for the current file\n   *\n   * @returns {Array.<Token>}\n   * @api public\n   */\n  getTokens: function () {\n    while (!this.ended) {\n      this.callLexerFunction('advance');\n    }\n    return this.tokens;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}