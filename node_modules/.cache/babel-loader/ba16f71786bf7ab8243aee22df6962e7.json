{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.acorn = global.acorn || {});\n})(this, function (exports) {\n  'use strict'; // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  }; // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n  var keywords = {\n    5: ecma5AndLessKeywords,\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  }; // ## Character categories\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n  // Generated by `bin/generate-identifier-regex.js`.\n\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range. They were\n  // generated by bin/generate-identifier-regex.js\n\n  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];\n  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239]; // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n      if (pos > code) return false;\n      pos += set[i + 1];\n      if (pos >= code) return true;\n    }\n  } // Test whether a given character code starts an identifier.\n\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) return code === 36;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n    if (astral === false) return false;\n    return isInAstralSet(code, astralIdentifierStartCodes);\n  } // Test whether a given character is part of an identifier.\n\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n    if (astral === false) return false;\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n  } // ## Token types\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n\n  var TokenType = function TokenType(label, conf) {\n    if (conf === void 0) conf = {};\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {\n      beforeExpr: true,\n      binop: prec\n    });\n  }\n\n  var beforeExpr = {\n    beforeExpr: true\n  };\n  var startsExpr = {\n    startsExpr: true\n  }; // Map keyword names to token types.\n\n  var keywordTypes = {}; // Succinct definitions of keyword token types\n\n  function kw(name, options) {\n    if (options === void 0) options = {};\n    options.keyword = name;\n    return keywordTypes[name] = new TokenType(name, options);\n  }\n\n  var tt = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    eof: new TokenType(\"eof\"),\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n    eq: new TokenType(\"=\", {\n      beforeExpr: true,\n      isAssign: true\n    }),\n    assign: new TokenType(\"_=\", {\n      beforeExpr: true,\n      isAssign: true\n    }),\n    incDec: new TokenType(\"++/--\", {\n      prefix: true,\n      postfix: true,\n      startsExpr: true\n    }),\n    prefix: new TokenType(\"prefix\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=\", 6),\n    relational: binop(\"</>\", 7),\n    bitShift: binop(\"<</>>\", 8),\n    plusMin: new TokenType(\"+/-\", {\n      beforeExpr: true,\n      binop: 9,\n      prefix: true,\n      startsExpr: true\n    }),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {\n      beforeExpr: true\n    }),\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {\n      isLoop: true,\n      beforeExpr: true\n    }),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {\n      isLoop: true\n    }),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {\n      isLoop: true\n    }),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {\n      beforeExpr: true,\n      startsExpr: true\n    }),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\"),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\"),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {\n      beforeExpr: true,\n      binop: 7\n    }),\n    _instanceof: kw(\"instanceof\", {\n      beforeExpr: true,\n      binop: 7\n    }),\n    _typeof: kw(\"typeof\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }),\n    _void: kw(\"void\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    }),\n    _delete: kw(\"delete\", {\n      beforeExpr: true,\n      prefix: true,\n      startsExpr: true\n    })\n  }; // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code) {\n    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  } // Checks if an object has a property.\n\n\n  function has(obj, propName) {\n    return Object.prototype.hasOwnProperty.call(obj, propName);\n  } // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset(n) {\n    return new Position(this.line, this.column + n);\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) this.source = p.sourceFile;\n  }; // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreakG.lastIndex = cur;\n      var match = lineBreakG.exec(input);\n\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else {\n        return new Position(line, offset - cur);\n      }\n    }\n  } // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\n    // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n    // for strict mode, the set of reserved words, and support for\n    // new syntax features. The default is 7.\n    ecmaVersion: 7,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // th position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program.\n    allowImportExportEverywhere: false,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false,\n    plugins: {}\n  }; // Interpret and default an options object\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions) options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];\n\n    if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;\n    if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n\n      options.onToken = function (token) {\n        return tokens.push(token);\n      };\n    }\n\n    if (isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);\n    return options;\n  }\n\n  function pushComment(options, array) {\n    return function (block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? 'Block' : 'Line',\n        value: text,\n        start: start,\n        end: end\n      };\n      if (options.locations) comment.loc = new SourceLocation(this, startLoc, endLoc);\n      if (options.ranges) comment.range = [start, end];\n      array.push(comment);\n    };\n  } // Registered plugins\n\n\n  var plugins = {};\n\n  function keywordRegexp(words) {\n    return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\");\n  }\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n    var reserved = \"\";\n\n    if (!options.allowReserved) {\n      for (var v = options.ecmaVersion;; v--) if (reserved = reservedWords[v]) break;\n\n      if (options.sourceType == \"module\") reserved += \" await\";\n    }\n\n    this.reservedWords = keywordRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = keywordRegexp(reservedStrict);\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input); // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n\n    this.containsEsc = false; // Load plugins\n\n    this.loadPlugins(options.plugins); // Set up token state\n    // The current position of the tokenizer in the input.\n\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    } // Properties of the current token:\n    // Its type\n\n\n    this.type = tt.eof; // For tokens that include more information than their type, the value\n\n    this.value = null; // Its start and end offset\n\n    this.start = this.end = this.pos; // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n\n    this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token\n\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n\n    this.context = this.initialContext();\n    this.exprAllowed = true; // Figure out if it's a module code.\n\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos); // Used to signify the start of a potential arrow function\n\n    this.potentialArrowAt = -1; // Flags to track whether we are in a function, a generator, an async function.\n\n    this.inFunction = this.inGenerator = this.inAsync = false; // Positions to delayed-check that yield/await does not exist in default parameters.\n\n    this.yieldPos = this.awaitPos = 0; // Labels in scope.\n\n    this.labels = []; // If enabled, skip leading hashbang line.\n\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);\n  }; // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n\n\n  Parser.prototype.isKeyword = function isKeyword(word) {\n    return this.keywords.test(word);\n  };\n\n  Parser.prototype.isReservedWord = function isReservedWord(word) {\n    return this.reservedWords.test(word);\n  };\n\n  Parser.prototype.extend = function extend(name, f) {\n    this[name] = f(this[name]);\n  };\n\n  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {\n    var this$1 = this;\n\n    for (var name in pluginConfigs) {\n      var plugin = plugins[name];\n      if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\");\n      plugin(this$1, pluginConfigs[name]);\n    }\n  };\n\n  Parser.prototype.parse = function parse() {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node);\n  };\n\n  var pp = Parser.prototype; // ## Parser utilities\n\n  var literal = /^(?:'((?:[^\\']|\\.)*)'|\"((?:[^\\\"]|\\.)*)\"|;)/;\n\n  pp.strictDirective = function (start) {\n    var this$1 = this;\n\n    for (;;) {\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this$1.input)[0].length;\n      var match = literal.exec(this$1.input.slice(start));\n      if (!match) return false;\n      if ((match[1] || match[2]) == \"use strict\") return true;\n      start += match[0].length;\n    }\n  }; // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n\n  pp.eat = function (type) {\n    if (this.type === type) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }; // Tests whether parsed token is a contextual keyword.\n\n\n  pp.isContextual = function (name) {\n    return this.type === tt.name && this.value === name;\n  }; // Consumes contextual keyword if possible.\n\n\n  pp.eatContextual = function (name) {\n    return this.value === name && this.eat(tt.name);\n  }; // Asserts that following token is given contextual keyword.\n\n\n  pp.expectContextual = function (name) {\n    if (!this.eatContextual(name)) this.unexpected();\n  }; // Test whether a semicolon can be inserted at the current position.\n\n\n  pp.canInsertSemicolon = function () {\n    return this.type === tt.eof || this.type === tt.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n  };\n\n  pp.insertSemicolon = function () {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n      return true;\n    }\n  }; // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n\n  pp.semicolon = function () {\n    if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected();\n  };\n\n  pp.afterTrailingComma = function (tokType, notNext) {\n    if (this.type == tokType) {\n      if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n      if (!notNext) this.next();\n      return true;\n    }\n  }; // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n\n  pp.expect = function (type) {\n    this.eat(type) || this.unexpected();\n  }; // Raise an unexpected token error.\n\n\n  pp.unexpected = function (pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  var DestructuringErrors = function DestructuringErrors() {\n    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1;\n  };\n\n  pp.checkPatternErrors = function (refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) return;\n    if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) this.raiseRecoverable(parens, \"Parenthesized pattern\");\n  };\n\n  pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {\n    var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1;\n    if (!andThrow) return pos >= 0;\n    if (pos > -1) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\");\n  };\n\n  pp.checkYieldAwaitInDefaultParams = function () {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n    if (this.awaitPos) this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n  };\n\n  pp.isSimpleAssignTarget = function (expr) {\n    if (expr.type === \"ParenthesizedExpression\") return this.isSimpleAssignTarget(expr.expression);\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n  };\n\n  var pp$1 = Parser.prototype; // ### Statement parsing\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$1.parseTopLevel = function (node) {\n    var this$1 = this;\n    var exports = {};\n    if (!node.body) node.body = [];\n\n    while (this.type !== tt.eof) {\n      var stmt = this$1.parseStatement(true, true, exports);\n      node.body.push(stmt);\n    }\n\n    this.next();\n\n    if (this.options.ecmaVersion >= 6) {\n      node.sourceType = this.options.sourceType;\n    }\n\n    return this.finishNode(node, \"Program\");\n  };\n\n  var loopLabel = {\n    kind: \"loop\"\n  };\n  var switchLabel = {\n    kind: \"switch\"\n  };\n\n  pp$1.isLet = function () {\n    if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false;\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length,\n        nextCh = this.input.charCodeAt(next);\n    if (nextCh === 91 || nextCh == 123) return true; // '{' and '['\n\n    if (isIdentifierStart(nextCh, true)) {\n      for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}\n\n      var ident = this.input.slice(next, pos);\n      if (!this.isKeyword(ident)) return true;\n    }\n\n    return false;\n  }; // check 'async [no LineTerminator here] function'\n  // - 'async /*foo*/ function' is OK.\n  // - 'async /*\\n*/ function' is invalid.\n\n\n  pp$1.isAsyncFunction = function () {\n    if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != \"async\") return false;\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length;\n    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));\n  }; // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n\n  pp$1.parseStatement = function (declaration, topLevel, exports) {\n    var starttype = this.type,\n        node = this.startNode(),\n        kind;\n\n    if (this.isLet()) {\n      starttype = tt._var;\n      kind = \"let\";\n    } // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n\n    switch (starttype) {\n      case tt._break:\n      case tt._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case tt._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case tt._do:\n        return this.parseDoStatement(node);\n\n      case tt._for:\n        return this.parseForStatement(node);\n\n      case tt._function:\n        if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();\n        return this.parseFunctionStatement(node, false);\n\n      case tt._class:\n        if (!declaration) this.unexpected();\n        return this.parseClass(node, true);\n\n      case tt._if:\n        return this.parseIfStatement(node);\n\n      case tt._return:\n        return this.parseReturnStatement(node);\n\n      case tt._switch:\n        return this.parseSwitchStatement(node);\n\n      case tt._throw:\n        return this.parseThrowStatement(node);\n\n      case tt._try:\n        return this.parseTryStatement(node);\n\n      case tt._const:\n      case tt._var:\n        kind = kind || this.value;\n        if (!declaration && kind != \"var\") this.unexpected();\n        return this.parseVarStatement(node, kind);\n\n      case tt._while:\n        return this.parseWhileStatement(node);\n\n      case tt._with:\n        return this.parseWithStatement(node);\n\n      case tt.braceL:\n        return this.parseBlock();\n\n      case tt.semi:\n        return this.parseEmptyStatement(node);\n\n      case tt._export:\n      case tt._import:\n        if (!this.options.allowImportExportEverywhere) {\n          if (!topLevel) this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n          if (!this.inModule) this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n        }\n\n        return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports);\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n\n      default:\n        if (this.isAsyncFunction() && declaration) {\n          this.next();\n          return this.parseFunctionStatement(node, true);\n        }\n\n        var maybeName = this.value,\n            expr = this.parseExpression();\n        if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);\n    }\n  };\n\n  pp$1.parseBreakContinueStatement = function (node, keyword) {\n    var this$1 = this;\n    var isBreak = keyword == \"break\";\n    this.next();\n    if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== tt.name) this.unexpected();else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    } // Verify that there is an actual destination to break or\n    // continue to.\n\n    for (var i = 0; i < this.labels.length; ++i) {\n      var lab = this$1.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  };\n\n  pp$1.parseDebuggerStatement = function (node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  };\n\n  pp$1.parseDoStatement = function (node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    this.expect(tt._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6) this.eat(tt.semi);else this.semicolon();\n    return this.finishNode(node, \"DoWhileStatement\");\n  }; // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n\n  pp$1.parseForStatement = function (node) {\n    this.next();\n    this.labels.push(loopLabel);\n    this.expect(tt.parenL);\n    if (this.type === tt.semi) return this.parseFor(node, null);\n    var isLet = this.isLet();\n\n    if (this.type === tt._var || this.type === tt._const || isLet) {\n      var init$1 = this.startNode(),\n          kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n      if ((this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1 && !(kind !== \"var\" && init$1.declarations[0].init)) return this.parseForIn(node, init$1);\n      return this.parseFor(node, init$1);\n    }\n\n    var refDestructuringErrors = new DestructuringErrors();\n    var init = this.parseExpression(true, refDestructuringErrors);\n\n    if (this.type === tt._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) {\n      this.toAssignable(init);\n      this.checkLVal(init);\n      this.checkPatternErrors(refDestructuringErrors, true);\n      return this.parseForIn(node, init);\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n\n    return this.parseFor(node, init);\n  };\n\n  pp$1.parseFunctionStatement = function (node, isAsync) {\n    this.next();\n    return this.parseFunction(node, true, false, isAsync);\n  };\n\n  pp$1.isFunction = function () {\n    return this.type === tt._function || this.isAsyncFunction();\n  };\n\n  pp$1.parseIfStatement = function (node) {\n    this.next();\n    node.test = this.parseParenExpression(); // allow function declarations in branches, but only in non-strict mode\n\n    node.consequent = this.parseStatement(!this.strict && this.isFunction());\n    node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null;\n    return this.finishNode(node, \"IfStatement\");\n  };\n\n  pp$1.parseReturnStatement = function (node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, \"'return' outside of function\");\n    this.next(); // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null;else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  };\n\n  pp$1.parseSwitchStatement = function (node) {\n    var this$1 = this;\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(tt.braceL);\n    this.labels.push(switchLabel); // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    for (var cur, sawDefault = false; this.type != tt.braceR;) {\n      if (this$1.type === tt._case || this$1.type === tt._default) {\n        var isCase = this$1.type === tt._case;\n        if (cur) this$1.finishNode(cur, \"SwitchCase\");\n        node.cases.push(cur = this$1.startNode());\n        cur.consequent = [];\n        this$1.next();\n\n        if (isCase) {\n          cur.test = this$1.parseExpression();\n        } else {\n          if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\");\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this$1.expect(tt.colon);\n      } else {\n        if (!cur) this$1.unexpected();\n        cur.consequent.push(this$1.parseStatement(true));\n      }\n    }\n\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  };\n\n  pp$1.parseThrowStatement = function (node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }; // Reused empty array added for node fields that are always empty.\n\n\n  var empty = [];\n\n  pp$1.parseTryStatement = function (node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.type === tt._catch) {\n      var clause = this.startNode();\n      this.next();\n      this.expect(tt.parenL);\n      clause.param = this.parseBindingAtom();\n      this.checkLVal(clause.param, true);\n      this.expect(tt.parenR);\n      clause.body = this.parseBlock();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) this.raise(node.start, \"Missing catch or finally clause\");\n    return this.finishNode(node, \"TryStatement\");\n  };\n\n  pp$1.parseVarStatement = function (node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  };\n\n  pp$1.parseWhileStatement = function (node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  };\n\n  pp$1.parseWithStatement = function (node) {\n    if (this.strict) this.raise(this.start, \"'with' in strict mode\");\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(false);\n    return this.finishNode(node, \"WithStatement\");\n  };\n\n  pp$1.parseEmptyStatement = function (node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  };\n\n  pp$1.parseLabeledStatement = function (node, maybeName, expr) {\n    var this$1 = this;\n\n    for (var i = 0; i < this.labels.length; ++i) if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n\n    var kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null;\n\n    for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {\n      var label = this$1.labels[i$1];\n\n      if (label.statementStart == node.start) {\n        label.statementStart = this$1.start;\n        label.kind = kind;\n      } else break;\n    }\n\n    this.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.start\n    });\n    node.body = this.parseStatement(true);\n    if (node.body.type == \"ClassDeclaration\" || node.body.type == \"VariableDeclaration\" && (this.strict || node.body.kind != \"var\") || node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator)) this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  };\n\n  pp$1.parseExpressionStatement = function (node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }; // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n\n  pp$1.parseBlock = function () {\n    var this$1 = this;\n    var node = this.startNode();\n    node.body = [];\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      var stmt = this$1.parseStatement(true);\n      node.body.push(stmt);\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }; // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n\n  pp$1.parseFor = function (node, init) {\n    node.init = init;\n    this.expect(tt.semi);\n    node.test = this.type === tt.semi ? null : this.parseExpression();\n    this.expect(tt.semi);\n    node.update = this.type === tt.parenR ? null : this.parseExpression();\n    this.expect(tt.parenR);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }; // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n\n  pp$1.parseForIn = function (node, init) {\n    var type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\";\n    this.next();\n    node.left = init;\n    node.right = this.parseExpression();\n    this.expect(tt.parenR);\n    node.body = this.parseStatement(false);\n    this.labels.pop();\n    return this.finishNode(node, type);\n  }; // Parse a list of variable declarations.\n\n\n  pp$1.parseVar = function (node, isFor, kind) {\n    var this$1 = this;\n    node.declarations = [];\n    node.kind = kind;\n\n    for (;;) {\n      var decl = this$1.startNode();\n      this$1.parseVarId(decl);\n\n      if (this$1.eat(tt.eq)) {\n        decl.init = this$1.parseMaybeAssign(isFor);\n      } else if (kind === \"const\" && !(this$1.type === tt._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\"))) {\n        this$1.unexpected();\n      } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === tt._in || this$1.isContextual(\"of\")))) {\n        this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n\n      node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n      if (!this$1.eat(tt.comma)) break;\n    }\n\n    return node;\n  };\n\n  pp$1.parseVarId = function (decl) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, true);\n  }; // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n\n  pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6 && !isAsync) node.generator = this.eat(tt.star);\n    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;\n    if (isStatement == null) isStatement = this.type == tt.name;\n    if (isStatement) node.id = this.parseIdent();\n    var oldInGen = this.inGenerator,\n        oldInAsync = this.inAsync,\n        oldYieldPos = this.yieldPos,\n        oldAwaitPos = this.awaitPos,\n        oldInFunc = this.inFunction;\n    this.inGenerator = node.generator;\n    this.inAsync = node.async;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.inFunction = true;\n    if (!isStatement && this.type === tt.name) node.id = this.parseIdent();\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody);\n    this.inGenerator = oldInGen;\n    this.inAsync = oldInAsync;\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.inFunction = oldInFunc;\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  };\n\n  pp$1.parseFunctionParams = function (node) {\n    this.expect(tt.parenL);\n    node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true);\n    this.checkYieldAwaitInDefaultParams();\n  }; // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n\n  pp$1.parseClass = function (node, isStatement) {\n    var this$1 = this;\n    this.next();\n    if (isStatement == null) isStatement = this.type === tt.name;\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (this$1.eat(tt.semi)) continue;\n      var method = this$1.startNode();\n      var isGenerator = this$1.eat(tt.star);\n      var isAsync = false;\n      var isMaybeStatic = this$1.type === tt.name && this$1.value === \"static\";\n      this$1.parsePropertyName(method);\n      method.static = isMaybeStatic && this$1.type !== tt.parenL;\n\n      if (method.static) {\n        if (isGenerator) this$1.unexpected();\n        isGenerator = this$1.eat(tt.star);\n        this$1.parsePropertyName(method);\n      }\n\n      if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed && method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== tt.parenL && !this$1.canInsertSemicolon()) {\n        isAsync = true;\n        this$1.parsePropertyName(method);\n      }\n\n      method.kind = \"method\";\n      var isGetSet = false;\n\n      if (!method.computed) {\n        var key = method.key;\n\n        if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n          isGetSet = true;\n          method.kind = key.name;\n          key = this$1.parsePropertyName(method);\n        }\n\n        if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"Literal\" && key.value === \"constructor\")) {\n          if (hadConstructor) this$1.raise(key.start, \"Duplicate constructor in the same class\");\n          if (isGetSet) this$1.raise(key.start, \"Constructor can't have get/set modifier\");\n          if (isGenerator) this$1.raise(key.start, \"Constructor can't be a generator\");\n          if (isAsync) this$1.raise(key.start, \"Constructor can't be an async method\");\n          method.kind = \"constructor\";\n          hadConstructor = true;\n        }\n      }\n\n      this$1.parseClassMethod(classBody, method, isGenerator, isAsync);\n\n      if (isGetSet) {\n        var paramCount = method.kind === \"get\" ? 0 : 1;\n\n        if (method.value.params.length !== paramCount) {\n          var start = method.value.start;\n          if (method.kind === \"get\") this$1.raiseRecoverable(start, \"getter should have no params\");else this$1.raiseRecoverable(start, \"setter should have exactly one param\");\n        } else {\n          if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\") this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\");\n        }\n      }\n    }\n\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  };\n\n  pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {\n    method.value = this.parseMethod(isGenerator, isAsync);\n    classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n  };\n\n  pp$1.parseClassId = function (node, isStatement) {\n    node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null;\n  };\n\n  pp$1.parseClassSuper = function (node) {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\n  }; // Parses module export declaration.\n\n\n  pp$1.parseExport = function (node, exports) {\n    var this$1 = this;\n    this.next(); // export * from '...'\n\n    if (this.eat(tt.star)) {\n      this.expectContextual(\"from\");\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      this.semicolon();\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    if (this.eat(tt._default)) {\n      // export default ...\n      this.checkExport(exports, \"default\", this.lastTokStart);\n      var isAsync;\n\n      if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) this.next();\n        node.declaration = this.parseFunction(fNode, null, false, isAsync);\n      } else if (this.type === tt._class) {\n        var cNode = this.startNode();\n        node.declaration = this.parseClass(cNode, null);\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    } // export var|const|let|function|class ...\n\n\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(true);\n      if (node.declaration.type === \"VariableDeclaration\") this.checkVariableExport(exports, node.declaration.declarations);else this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n      node.specifiers = [];\n      node.source = null;\n    } else {\n      // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers(exports);\n\n      if (this.eatContextual(\"from\")) {\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      } else {\n        // check for keywords used as local names\n        for (var i = 0; i < node.specifiers.length; i++) {\n          if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {\n            this$1.unexpected(node.specifiers[i].local.start);\n          }\n        }\n\n        node.source = null;\n      }\n\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n  };\n\n  pp$1.checkExport = function (exports, name, pos) {\n    if (!exports) return;\n    if (Object.prototype.hasOwnProperty.call(exports, name)) this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n    exports[name] = true;\n  };\n\n  pp$1.checkPatternExport = function (exports, pat) {\n    var this$1 = this;\n    var type = pat.type;\n    if (type == \"Identifier\") this.checkExport(exports, pat.name, pat.start);else if (type == \"ObjectPattern\") for (var i = 0; i < pat.properties.length; ++i) this$1.checkPatternExport(exports, pat.properties[i].value);else if (type == \"ArrayPattern\") for (var i$1 = 0; i$1 < pat.elements.length; ++i$1) {\n      var elt = pat.elements[i$1];\n      if (elt) this$1.checkPatternExport(exports, elt);\n    } else if (type == \"AssignmentPattern\") this.checkPatternExport(exports, pat.left);else if (type == \"ParenthesizedExpression\") this.checkPatternExport(exports, pat.expression);\n  };\n\n  pp$1.checkVariableExport = function (exports, decls) {\n    var this$1 = this;\n    if (!exports) return;\n\n    for (var i = 0; i < decls.length; i++) this$1.checkPatternExport(exports, decls[i].id);\n  };\n\n  pp$1.shouldParseExportStatement = function () {\n    return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n  }; // Parses a comma-separated list of module exports.\n\n\n  pp$1.parseExportSpecifiers = function (exports) {\n    var this$1 = this;\n    var nodes = [],\n        first = true; // export { x, y as z } [from '...']\n\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (!first) {\n        this$1.expect(tt.comma);\n        if (this$1.afterTrailingComma(tt.braceR)) break;\n      } else first = false;\n\n      var node = this$1.startNode();\n      node.local = this$1.parseIdent(true);\n      node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n      this$1.checkExport(exports, node.exported.name, node.exported.start);\n      nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }; // Parses import declaration.\n\n\n  pp$1.parseImport = function (node) {\n    this.next(); // import '...'\n\n    if (this.type === tt.string) {\n      node.specifiers = empty;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }; // Parses a comma-separated list of module imports.\n\n\n  pp$1.parseImportSpecifiers = function () {\n    var this$1 = this;\n    var nodes = [],\n        first = true;\n\n    if (this.type === tt.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode();\n      node.local = this.parseIdent();\n      this.checkLVal(node.local, true);\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n      if (!this.eat(tt.comma)) return nodes;\n    }\n\n    if (this.type === tt.star) {\n      var node$1 = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      node$1.local = this.parseIdent();\n      this.checkLVal(node$1.local, true);\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n      return nodes;\n    }\n\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (!first) {\n        this$1.expect(tt.comma);\n        if (this$1.afterTrailingComma(tt.braceR)) break;\n      } else first = false;\n\n      var node$2 = this$1.startNode();\n      node$2.imported = this$1.parseIdent(true);\n\n      if (this$1.eatContextual(\"as\")) {\n        node$2.local = this$1.parseIdent();\n      } else {\n        node$2.local = node$2.imported;\n        if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start);\n        if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, \"The keyword '\" + node$2.local.name + \"' is reserved\");\n      }\n\n      this$1.checkLVal(node$2.local, true);\n      nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n    }\n\n    return nodes;\n  };\n\n  var pp$2 = Parser.prototype; // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$2.toAssignable = function (node, isBinding) {\n    var this$1 = this;\n\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n        case \"Identifier\":\n          if (this.inAsync && node.name === \"await\") this.raise(node.start, \"Can not use 'await' as identifier inside an async function\");\n          break;\n\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n          break;\n\n        case \"ObjectExpression\":\n          node.type = \"ObjectPattern\";\n\n          for (var i = 0; i < node.properties.length; i++) {\n            var prop = node.properties[i];\n            if (prop.kind !== \"init\") this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n            this$1.toAssignable(prop.value, isBinding);\n          }\n\n          break;\n\n        case \"ArrayExpression\":\n          node.type = \"ArrayPattern\";\n          this.toAssignableList(node.elements, isBinding);\n          break;\n\n        case \"AssignmentExpression\":\n          if (node.operator === \"=\") {\n            node.type = \"AssignmentPattern\";\n            delete node.operator;\n            this.toAssignable(node.left, isBinding); // falls through to AssignmentPattern\n          } else {\n            this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n            break;\n          }\n\n        case \"AssignmentPattern\":\n          break;\n\n        case \"ParenthesizedExpression\":\n          node.expression = this.toAssignable(node.expression, isBinding);\n          break;\n\n        case \"MemberExpression\":\n          if (!isBinding) break;\n\n        default:\n          this.raise(node.start, \"Assigning to rvalue\");\n      }\n    }\n\n    return node;\n  }; // Convert list of expression atoms to binding list.\n\n\n  pp$2.toAssignableList = function (exprList, isBinding) {\n    var this$1 = this;\n    var end = exprList.length;\n\n    if (end) {\n      var last = exprList[end - 1];\n\n      if (last && last.type == \"RestElement\") {\n        --end;\n      } else if (last && last.type == \"SpreadElement\") {\n        last.type = \"RestElement\";\n        var arg = last.argument;\n        this.toAssignable(arg, isBinding);\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\") this.unexpected(arg.start);\n        --end;\n      }\n\n      if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") this.unexpected(last.argument.start);\n    }\n\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n      if (elt) this$1.toAssignable(elt, isBinding);\n    }\n\n    return exprList;\n  }; // Parses spread element.\n\n\n  pp$2.parseSpread = function (refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\");\n  };\n\n  pp$2.parseRest = function (allowNonIdent) {\n    var node = this.startNode();\n    this.next(); // RestElement inside of a function parameter must be an identifier\n\n    if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected();\n    return this.finishNode(node, \"RestElement\");\n  }; // Parses lvalue (assignable) atom.\n\n\n  pp$2.parseBindingAtom = function () {\n    if (this.options.ecmaVersion < 6) return this.parseIdent();\n\n    switch (this.type) {\n      case tt.name:\n        return this.parseIdent();\n\n      case tt.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(tt.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\");\n\n      case tt.braceL:\n        return this.parseObj(true);\n\n      default:\n        this.unexpected();\n    }\n  };\n\n  pp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {\n    var this$1 = this;\n    var elts = [],\n        first = true;\n\n    while (!this.eat(close)) {\n      if (first) first = false;else this$1.expect(tt.comma);\n\n      if (allowEmpty && this$1.type === tt.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n        break;\n      } else if (this$1.type === tt.ellipsis) {\n        var rest = this$1.parseRest(allowNonIdent);\n        this$1.parseBindingListItem(rest);\n        elts.push(rest);\n        if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\");\n        this$1.expect(close);\n        break;\n      } else {\n        var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n        this$1.parseBindingListItem(elem);\n        elts.push(elem);\n      }\n    }\n\n    return elts;\n  };\n\n  pp$2.parseBindingListItem = function (param) {\n    return param;\n  }; // Parses assignment pattern around given atom if possible.\n\n\n  pp$2.parseMaybeDefault = function (startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left;\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }; // Verify that a node is an lval — something that can be assigned\n  // to.\n\n\n  pp$2.checkLVal = function (expr, isBinding, checkClashes) {\n    var this$1 = this;\n\n    switch (expr.type) {\n      case \"Identifier\":\n        if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n\n        if (checkClashes) {\n          if (has(checkClashes, expr.name)) this.raiseRecoverable(expr.start, \"Argument name clash\");\n          checkClashes[expr.name] = true;\n        }\n\n        break;\n\n      case \"MemberExpression\":\n        if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\");\n        break;\n\n      case \"ObjectPattern\":\n        for (var i = 0; i < expr.properties.length; i++) this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes);\n\n        break;\n\n      case \"ArrayPattern\":\n        for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {\n          var elem = expr.elements[i$1];\n          if (elem) this$1.checkLVal(elem, isBinding, checkClashes);\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, isBinding, checkClashes);\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, isBinding, checkClashes);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, isBinding, checkClashes);\n        break;\n\n      default:\n        this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  }; // A recursive descent parser operates by defining functions for all\n  // syntactic elements, and recursively calling those, each function\n  // advancing the input stream and returning an AST node. Precedence\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n  // instead of `(!x)[1]` is handled by the fact that the parser\n  // function that parses unary prefix operators is called first, and\n  // in turn calls the function that parses `[]` subscripts — that\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\n  // *that* in the unary operator node.\n  //\n  // Acorn uses an [operator precedence parser][opp] to handle binary\n  // operator precedence, because it is much more compact than using\n  // the technique outlined above, which uses different, nesting\n  // functions to specify precedence, for all of the ten binary\n  // precedence levels that JavaScript defines.\n  //\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\n  var pp$3 = Parser.prototype; // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash —\n  // either with each other or with an init property — and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$3.checkPropClash = function (prop, propHash) {\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;\n    var key = prop.key;\n    var name;\n\n    switch (key.type) {\n      case \"Identifier\":\n        name = key.name;\n        break;\n\n      case \"Literal\":\n        name = String(key.value);\n        break;\n\n      default:\n        return;\n    }\n\n    var kind = prop.kind;\n\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n        propHash.proto = true;\n      }\n\n      return;\n    }\n\n    name = \"$\" + name;\n    var other = propHash[name];\n\n    if (other) {\n      var isGetSet = kind !== \"init\";\n      if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raiseRecoverable(key.start, \"Redefinition of property\");\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n\n    other[kind] = true;\n  }; // ### Expression parsing\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n\n  pp$3.parseExpression = function (noIn, refDestructuringErrors) {\n    var this$1 = this;\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n\n    if (this.type === tt.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));\n\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }; // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n\n  pp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {\n    if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield();\n    var ownDestructuringErrors = false,\n        oldParenAssign = -1;\n\n    if (refDestructuringErrors) {\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n      refDestructuringErrors.parenthesizedAssign = -1;\n    } else {\n      refDestructuringErrors = new DestructuringErrors();\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    if (this.type == tt.parenL || this.type == tt.name) this.potentialArrowAt = this.start;\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);\n\n    if (this.type.isAssign) {\n      this.checkPatternErrors(refDestructuringErrors, true);\n      if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors);\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      node.left = this.type === tt.eq ? this.toAssignable(left) : left;\n      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n\n      this.checkLVal(left);\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else {\n      if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n\n    if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n    return left;\n  }; // Parse a ternary conditional (`?:`) operator.\n\n\n  pp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n\n    if (this.eat(tt.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(tt.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }; // Start the precedence parser.\n\n\n  pp$3.parseExprOps = function (noIn, refDestructuringErrors) {\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  }; // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n\n  pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.type.binop;\n\n    if (prec != null && (!noIn || this.type !== tt._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === tt.logicalOR || this.type === tt.logicalAND;\n        var op = this.value;\n        this.next();\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n      }\n    }\n\n    return left;\n  };\n\n  pp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n  }; // Parse unary operators, both prefix and postfix.\n\n\n  pp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {\n    var this$1 = this;\n    var startPos = this.start,\n        startLoc = this.startLoc,\n        expr;\n\n    if (this.inAsync && this.isContextual(\"await\")) {\n      expr = this.parseAwait(refDestructuringErrors);\n      sawUnary = true;\n    } else if (this.type.prefix) {\n      var node = this.startNode(),\n          update = this.type === tt.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");else sawUnary = true;\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors);\n      if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\n        node$1.operator = this$1.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this$1.checkLVal(expr);\n        this$1.next();\n        expr = this$1.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(tt.starstar)) return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false);else return expr;\n  }; // Parse call, dot, and `[]`-subscript expressions.\n\n\n  pp$3.parseExprSubscripts = function (refDestructuringErrors) {\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors);\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;\n    var result = this.parseSubscripts(expr, startPos, startLoc);\n\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;\n      if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;\n    }\n\n    return result;\n  };\n\n  pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n    var this$1 = this;\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd == base.end && !this.canInsertSemicolon();\n\n    for (var computed;;) {\n      if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {\n        var node = this$1.startNodeAt(startPos, startLoc);\n        node.object = base;\n        node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n        node.computed = !!computed;\n        if (computed) this$1.expect(tt.bracketR);\n        base = this$1.finishNode(node, \"MemberExpression\");\n      } else if (!noCalls && this$1.eat(tt.parenL)) {\n        var refDestructuringErrors = new DestructuringErrors(),\n            oldYieldPos = this$1.yieldPos,\n            oldAwaitPos = this$1.awaitPos;\n        this$1.yieldPos = 0;\n        this$1.awaitPos = 0;\n        var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n\n        if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(tt.arrow)) {\n          this$1.checkPatternErrors(refDestructuringErrors, false);\n          this$1.checkYieldAwaitInDefaultParams();\n          this$1.yieldPos = oldYieldPos;\n          this$1.awaitPos = oldAwaitPos;\n          return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true);\n        }\n\n        this$1.checkExpressionErrors(refDestructuringErrors, true);\n        this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n        this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\n        node$1.callee = base;\n        node$1.arguments = exprList;\n        base = this$1.finishNode(node$1, \"CallExpression\");\n      } else if (this$1.type === tt.backQuote) {\n        var node$2 = this$1.startNodeAt(startPos, startLoc);\n        node$2.tag = base;\n        node$2.quasi = this$1.parseTemplate();\n        base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n      } else {\n        return base;\n      }\n    }\n  }; // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n\n  pp$3.parseExprAtom = function (refDestructuringErrors) {\n    var node,\n        canBeArrow = this.potentialArrowAt == this.start;\n\n    switch (this.type) {\n      case tt._super:\n        if (!this.inFunction) this.raise(this.start, \"'super' outside of function or class\");\n\n      case tt._this:\n        var type = this.type === tt._this ? \"ThisExpression\" : \"Super\";\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, type);\n\n      case tt.name:\n        var startPos = this.start,\n            startLoc = this.startLoc;\n        var id = this.parseIdent(this.type !== tt.name);\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(tt._function)) return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true);\n\n        if (canBeArrow && !this.canInsertSemicolon()) {\n          if (this.eat(tt.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);\n\n          if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === tt.name) {\n            id = this.parseIdent();\n            if (this.canInsertSemicolon() || !this.eat(tt.arrow)) this.unexpected();\n            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);\n          }\n        }\n\n        return id;\n\n      case tt.regexp:\n        var value = this.value;\n        node = this.parseLiteral(value.value);\n        node.regex = {\n          pattern: value.pattern,\n          flags: value.flags\n        };\n        return node;\n\n      case tt.num:\n      case tt.string:\n        return this.parseLiteral(this.value);\n\n      case tt._null:\n      case tt._true:\n      case tt._false:\n        node = this.startNode();\n        node.value = this.type === tt._null ? null : this.type === tt._true;\n        node.raw = this.type.keyword;\n        this.next();\n        return this.finishNode(node, \"Literal\");\n\n      case tt.parenL:\n        var start = this.start,\n            expr = this.parseParenAndDistinguishExpression(canBeArrow);\n\n        if (refDestructuringErrors) {\n          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;\n          if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;\n        }\n\n        return expr;\n\n      case tt.bracketL:\n        node = this.startNode();\n        this.next();\n        node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors);\n        return this.finishNode(node, \"ArrayExpression\");\n\n      case tt.braceL:\n        return this.parseObj(false, refDestructuringErrors);\n\n      case tt._function:\n        node = this.startNode();\n        this.next();\n        return this.parseFunction(node, false);\n\n      case tt._class:\n        return this.parseClass(this.startNode(), false);\n\n      case tt._new:\n        return this.parseNew();\n\n      case tt.backQuote:\n        return this.parseTemplate();\n\n      default:\n        this.unexpected();\n    }\n  };\n\n  pp$3.parseLiteral = function (value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    this.next();\n    return this.finishNode(node, \"Literal\");\n  };\n\n  pp$3.parseParenExpression = function () {\n    this.expect(tt.parenL);\n    var val = this.parseExpression();\n    this.expect(tt.parenR);\n    return val;\n  };\n\n  pp$3.parseParenAndDistinguishExpression = function (canBeArrow) {\n    var this$1 = this;\n    var startPos = this.start,\n        startLoc = this.startLoc,\n        val,\n        allowTrailingComma = this.options.ecmaVersion >= 8;\n\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n      var innerStartPos = this.start,\n          innerStartLoc = this.startLoc;\n      var exprList = [],\n          first = true,\n          lastIsComma = false;\n      var refDestructuringErrors = new DestructuringErrors(),\n          oldYieldPos = this.yieldPos,\n          oldAwaitPos = this.awaitPos,\n          spreadStart,\n          innerParenStart;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n\n      while (this.type !== tt.parenR) {\n        first ? first = false : this$1.expect(tt.comma);\n\n        if (allowTrailingComma && this$1.afterTrailingComma(tt.parenR, true)) {\n          lastIsComma = true;\n          break;\n        } else if (this$1.type === tt.ellipsis) {\n          spreadStart = this$1.start;\n          exprList.push(this$1.parseParenItem(this$1.parseRest()));\n          if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\");\n          break;\n        } else {\n          if (this$1.type === tt.parenL && !innerParenStart) {\n            innerParenStart = this$1.start;\n          }\n\n          exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n        }\n      }\n\n      var innerEndPos = this.start,\n          innerEndLoc = this.startLoc;\n      this.expect(tt.parenR);\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        if (innerParenStart) this.unexpected(innerParenStart);\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        return this.parseParenArrowList(startPos, startLoc, exprList);\n      }\n\n      if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);\n      if (spreadStart) this.unexpected(spreadStart);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\");\n    } else {\n      return val;\n    }\n  };\n\n  pp$3.parseParenItem = function (item) {\n    return item;\n  };\n\n  pp$3.parseParenArrowList = function (startPos, startLoc, exprList) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);\n  }; // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n\n  var empty$1 = [];\n\n  pp$3.parseNew = function () {\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n\n    if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n      node.meta = meta;\n      node.property = this.parseIdent(true);\n      if (node.property.name !== \"target\") this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\");\n      if (!this.inFunction) this.raiseRecoverable(node.start, \"new.target can only be used in functions\");\n      return this.finishNode(node, \"MetaProperty\");\n    }\n\n    var startPos = this.start,\n        startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n    if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false);else node.arguments = empty$1;\n    return this.finishNode(node, \"NewExpression\");\n  }; // Parse template expression.\n\n\n  pp$3.parseTemplateElement = function () {\n    var elem = this.startNode();\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n      cooked: this.value\n    };\n    this.next();\n    elem.tail = this.type === tt.backQuote;\n    return this.finishNode(elem, \"TemplateElement\");\n  };\n\n  pp$3.parseTemplate = function () {\n    var this$1 = this;\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement();\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this$1.expect(tt.dollarBraceL);\n      node.expressions.push(this$1.parseExpression());\n      this$1.expect(tt.braceR);\n      node.quasis.push(curElt = this$1.parseTemplateElement());\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }; // Parse an object literal or binding pattern.\n\n\n  pp$3.parseObj = function (isPattern, refDestructuringErrors) {\n    var this$1 = this;\n    var node = this.startNode(),\n        first = true,\n        propHash = {};\n    node.properties = [];\n    this.next();\n\n    while (!this.eat(tt.braceR)) {\n      if (!first) {\n        this$1.expect(tt.comma);\n        if (this$1.afterTrailingComma(tt.braceR)) break;\n      } else first = false;\n\n      var prop = this$1.startNode(),\n          isGenerator,\n          isAsync,\n          startPos,\n          startLoc;\n\n      if (this$1.options.ecmaVersion >= 6) {\n        prop.method = false;\n        prop.shorthand = false;\n\n        if (isPattern || refDestructuringErrors) {\n          startPos = this$1.start;\n          startLoc = this$1.startLoc;\n        }\n\n        if (!isPattern) isGenerator = this$1.eat(tt.star);\n      }\n\n      this$1.parsePropertyName(prop);\n\n      if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && this$1.type !== tt.parenL && this$1.type !== tt.colon && !this$1.canInsertSemicolon()) {\n        isAsync = true;\n        this$1.parsePropertyName(prop, refDestructuringErrors);\n      } else {\n        isAsync = false;\n      }\n\n      this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors);\n      this$1.checkPropClash(prop, propHash);\n      node.properties.push(this$1.finishNode(prop, \"Property\"));\n    }\n\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n  };\n\n  pp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n    if ((isGenerator || isAsync) && this.type === tt.colon) this.unexpected();\n\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type != tt.comma && this.type != tt.braceR) {\n      if (isGenerator || isAsync || isPattern) this.unexpected();\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\") this.raiseRecoverable(start, \"getter should have no params\");else this.raiseRecoverable(start, \"setter should have exactly one param\");\n      } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n      }\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) || this.inGenerator && prop.key.name == \"yield\" || this.inAsync && prop.key.name == \"await\") this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\");\n      prop.kind = \"init\";\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else if (this.type === tt.eq && refDestructuringErrors) {\n        if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else {\n        prop.value = prop.key;\n      }\n\n      prop.shorthand = true;\n    } else this.unexpected();\n  };\n\n  pp$3.parsePropertyName = function (prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(tt.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(tt.bracketR);\n        return prop.key;\n      } else {\n        prop.computed = false;\n      }\n    }\n\n    return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true);\n  }; // Initialize empty function node.\n\n\n  pp$3.initFunction = function (node) {\n    node.id = null;\n\n    if (this.options.ecmaVersion >= 6) {\n      node.generator = false;\n      node.expression = false;\n    }\n\n    if (this.options.ecmaVersion >= 8) node.async = false;\n  }; // Parse object or class method.\n\n\n  pp$3.parseMethod = function (isGenerator, isAsync) {\n    var node = this.startNode(),\n        oldInGen = this.inGenerator,\n        oldInAsync = this.inAsync,\n        oldYieldPos = this.yieldPos,\n        oldAwaitPos = this.awaitPos,\n        oldInFunc = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) node.generator = isGenerator;\n    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;\n    this.inGenerator = node.generator;\n    this.inAsync = node.async;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.inFunction = true;\n    this.expect(tt.parenL);\n    node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false);\n    this.inGenerator = oldInGen;\n    this.inAsync = oldInAsync;\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.inFunction = oldInFunc;\n    return this.finishNode(node, \"FunctionExpression\");\n  }; // Parse arrow function expression with given parameters.\n\n\n  pp$3.parseArrowExpression = function (node, params, isAsync) {\n    var oldInGen = this.inGenerator,\n        oldInAsync = this.inAsync,\n        oldYieldPos = this.yieldPos,\n        oldAwaitPos = this.awaitPos,\n        oldInFunc = this.inFunction;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;\n    this.inGenerator = false;\n    this.inAsync = node.async;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.inFunction = true;\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true);\n    this.inGenerator = oldInGen;\n    this.inAsync = oldInAsync;\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.inFunction = oldInFunc;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }; // Parse function body and check parameters.\n\n\n  pp$3.parseFunctionBody = function (node, isArrowFunction) {\n    var isExpression = isArrowFunction && this.type !== tt.braceL;\n    var oldStrict = this.strict,\n        useStrict = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      node.expression = true;\n    } else {\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.end); // If this is a strict mode function, verify that argument names\n        // are not repeated, and it does not try to bind the words `eval`\n        // or `arguments`.\n\n        if (useStrict && nonSimple) this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n      } // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n\n\n      var oldLabels = this.labels;\n      this.labels = [];\n      if (useStrict) this.strict = true;\n      node.body = this.parseBlock(true);\n      node.expression = false;\n      this.labels = oldLabels;\n    }\n\n    if (oldStrict || useStrict) {\n      this.strict = true;\n      if (node.id) this.checkLVal(node.id, true);\n      this.checkParams(node);\n      this.strict = oldStrict;\n    } else if (isArrowFunction || !this.isSimpleParamList(node.params)) {\n      this.checkParams(node);\n    }\n  };\n\n  pp$3.isSimpleParamList = function (params) {\n    for (var i = 0; i < params.length; i++) if (params[i].type !== \"Identifier\") return false;\n\n    return true;\n  }; // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n\n  pp$3.checkParams = function (node) {\n    var this$1 = this;\n    var nameHash = {};\n\n    for (var i = 0; i < node.params.length; i++) this$1.checkLVal(node.params[i], true, nameHash);\n  }; // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n\n  pp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var this$1 = this;\n    var elts = [],\n        first = true;\n\n    while (!this.eat(close)) {\n      if (!first) {\n        this$1.expect(tt.comma);\n        if (allowTrailingComma && this$1.afterTrailingComma(close)) break;\n      } else first = false;\n\n      var elt;\n      if (allowEmpty && this$1.type === tt.comma) elt = null;else if (this$1.type === tt.ellipsis) {\n        elt = this$1.parseSpread(refDestructuringErrors);\n        if (refDestructuringErrors && this$1.type === tt.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this$1.start;\n      } else {\n        elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n      }\n      elts.push(elt);\n    }\n\n    return elts;\n  }; // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n\n  pp$3.parseIdent = function (liberal) {\n    var node = this.startNode();\n    if (liberal && this.options.allowReserved == \"never\") liberal = false;\n\n    if (this.type === tt.name) {\n      if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1)) this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\");\n      if (this.inGenerator && this.value === \"yield\") this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\");\n      if (this.inAsync && this.value === \"await\") this.raiseRecoverable(this.start, \"Can not use 'await' as identifier inside an async function\");\n      node.name = this.value;\n    } else if (liberal && this.type.keyword) {\n      node.name = this.type.keyword;\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"Identifier\");\n  }; // Parses yield expression inside generator.\n\n\n  pp$3.parseYield = function () {\n    if (!this.yieldPos) this.yieldPos = this.start;\n    var node = this.startNode();\n    this.next();\n\n    if (this.type == tt.semi || this.canInsertSemicolon() || this.type != tt.star && !this.type.startsExpr) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(tt.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  };\n\n  pp$3.parseAwait = function () {\n    if (!this.awaitPos) this.awaitPos = this.start;\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    return this.finishNode(node, \"AwaitExpression\");\n  };\n\n  var pp$4 = Parser.prototype; // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function (pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n    err.raisedAt = this.pos;\n    throw err;\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function () {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart);\n    }\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations) this.loc = new SourceLocation(parser, loc);\n    if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;\n    if (parser.options.ranges) this.range = [pos, 0];\n  }; // Start an AST node, attaching a start offset.\n\n\n  var pp$5 = Parser.prototype;\n\n  pp$5.startNode = function () {\n    return new Node(this, this.start, this.startLoc);\n  };\n\n  pp$5.startNodeAt = function (pos, loc) {\n    return new Node(this, pos, loc);\n  }; // Finish an AST node, adding `type` and `end` properties.\n\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations) node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    return node;\n  }\n\n  pp$5.finishNode = function (node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n  }; // Finish node at given position\n\n\n  pp$5.finishNodeAt = function (node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc);\n  }; // The algorithm used to determine whether a regexp can appear at a\n  // given point in the program is loosely based on sweet.js' approach.\n  // See https://github.com/mozilla/sweet.js/wiki/design\n\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n  };\n\n  var types = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", true),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) {\n      return p.readTmplToken();\n    }),\n    f_expr: new TokContext(\"function\", true)\n  };\n  var pp$6 = Parser.prototype;\n\n  pp$6.initialContext = function () {\n    return [types.b_stat];\n  };\n\n  pp$6.braceIsBlock = function (prevType) {\n    if (prevType === tt.colon) {\n      var parent = this.curContext();\n      if (parent === types.b_stat || parent === types.b_expr) return !parent.isExpr;\n    }\n\n    if (prevType === tt._return) return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n    if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR) return true;\n    if (prevType == tt.braceL) return this.curContext() === types.b_stat;\n    return !this.exprAllowed;\n  };\n\n  pp$6.updateContext = function (prevType) {\n    var update,\n        type = this.type;\n    if (type.keyword && prevType == tt.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;\n  }; // Token-specific context update code\n\n\n  tt.parenR.updateContext = tt.braceR.updateContext = function () {\n    if (this.context.length == 1) {\n      this.exprAllowed = true;\n      return;\n    }\n\n    var out = this.context.pop();\n\n    if (out === types.b_stat && this.curContext() === types.f_expr) {\n      this.context.pop();\n      this.exprAllowed = false;\n    } else if (out === types.b_tmpl) {\n      this.exprAllowed = true;\n    } else {\n      this.exprAllowed = !out.isExpr;\n    }\n  };\n\n  tt.braceL.updateContext = function (prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n    this.exprAllowed = true;\n  };\n\n  tt.dollarBraceL.updateContext = function () {\n    this.context.push(types.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  tt.parenL.updateContext = function (prevType) {\n    var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while;\n    this.context.push(statementParens ? types.p_stat : types.p_expr);\n    this.exprAllowed = true;\n  };\n\n  tt.incDec.updateContext = function () {// tokExprAllowed stays unchanged\n  };\n\n  tt._function.updateContext = function (prevType) {\n    if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else && !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat)) this.context.push(types.f_expr);\n    this.exprAllowed = false;\n  };\n\n  tt.backQuote.updateContext = function () {\n    if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);\n    this.exprAllowed = false;\n  }; // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations) this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n    if (p.options.ranges) this.range = [p.start, p.end];\n  }; // ## Tokenizer\n\n\n  var pp$7 = Parser.prototype; // Are we running under Rhino?\n\n  var isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\"; // Move to the next token\n\n  pp$7.next = function () {\n    if (this.options.onToken) this.options.onToken(new Token(this));\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp$7.getToken = function () {\n    this.next();\n    return new Token(this);\n  }; // If we're in an ES6 environment, make parsers iterable\n\n\n  if (typeof Symbol !== \"undefined\") pp$7[Symbol.iterator] = function () {\n    var self = this;\n    return {\n      next: function () {\n        var token = self.getToken();\n        return {\n          done: token.type === tt.eof,\n          value: token\n        };\n      }\n    };\n  }; // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  pp$7.curContext = function () {\n    return this.context[this.context.length - 1];\n  }; // Read a single token, updating the parser object's token-related\n  // properties.\n\n\n  pp$7.nextToken = function () {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n    this.start = this.pos;\n    if (this.options.locations) this.startLoc = this.curPosition();\n    if (this.pos >= this.input.length) return this.finishToken(tt.eof);\n    if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());\n  };\n\n  pp$7.readToken = function (code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92\n    /* '\\' */\n    ) return this.readWord();\n    return this.getTokenFromCode(code);\n  };\n\n  pp$7.fullCharCodeAtPos = function () {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xe000) return code;\n    var next = this.input.charCodeAt(this.pos + 1);\n    return (code << 10) + next - 0x35fdc00;\n  };\n\n  pp$7.skipBlockComment = function () {\n    var this$1 = this;\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos,\n        end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\");\n    this.pos = end + 2;\n\n    if (this.options.locations) {\n      lineBreakG.lastIndex = start;\n      var match;\n\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n        ++this$1.curLine;\n        this$1.lineStart = match.index + match[0].length;\n      }\n    }\n\n    if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n  };\n\n  pp$7.skipLineComment = function (startSkip) {\n    var this$1 = this;\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n\n    while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++this$1.pos;\n      ch = this$1.input.charCodeAt(this$1.pos);\n    }\n\n    if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n  }; // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n\n  pp$7.skipSpace = function () {\n    var this$1 = this;\n\n    loop: while (this.pos < this.input.length) {\n      var ch = this$1.input.charCodeAt(this$1.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n          // ' '\n          ++this$1.pos;\n          break;\n\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n            ++this$1.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this$1.pos;\n\n          if (this$1.options.locations) {\n            ++this$1.curLine;\n            this$1.lineStart = this$1.pos;\n          }\n\n          break;\n\n        case 47:\n          // '/'\n          switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n            case 42:\n              // '*'\n              this$1.skipBlockComment();\n              break;\n\n            case 47:\n              this$1.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n            ++this$1.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }; // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n\n  pp$7.finishToken = function (type, val) {\n    this.end = this.pos;\n    if (this.options.locations) this.endLoc = this.curPosition();\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n    this.updateContext(prevType);\n  }; // ### Token reading\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n\n\n  pp$7.readToken_dot = function () {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) return this.readNumber(true);\n    var next2 = this.input.charCodeAt(this.pos + 2);\n\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n      // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(tt.ellipsis);\n    } else {\n      ++this.pos;\n      return this.finishToken(tt.dot);\n    }\n  };\n\n  pp$7.readToken_slash = function () {\n    // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (this.exprAllowed) {\n      ++this.pos;\n      return this.readRegexp();\n    }\n\n    if (next === 61) return this.finishOp(tt.assign, 2);\n    return this.finishOp(tt.slash, 1);\n  };\n\n  pp$7.readToken_mult_modulo_exp = function (code) {\n    // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? tt.star : tt.modulo; // exponentiation operator ** and **=\n\n    if (this.options.ecmaVersion >= 7 && next === 42) {\n      ++size;\n      tokentype = tt.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) return this.finishOp(tt.assign, size + 1);\n    return this.finishOp(tokentype, size);\n  };\n\n  pp$7.readToken_pipe_amp = function (code) {\n    // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2);\n    if (next === 61) return this.finishOp(tt.assign, 2);\n    return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1);\n  };\n\n  pp$7.readToken_caret = function () {\n    // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) return this.finishOp(tt.assign, 2);\n    return this.finishOp(tt.bitwiseXOR, 1);\n  };\n\n  pp$7.readToken_plus_min = function (code) {\n    // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n\n    if (next === code) {\n      if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken();\n      }\n\n      return this.finishOp(tt.incDec, 2);\n    }\n\n    if (next === 61) return this.finishOp(tt.assign, 2);\n    return this.finishOp(tt.plusMin, 1);\n  };\n\n  pp$7.readToken_lt_gt = function (code) {\n    // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1);\n      return this.finishOp(tt.bitShift, size);\n    }\n\n    if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {\n      if (this.inModule) this.unexpected(); // `<!--`, an XML-style comment that should be interpreted as a line comment\n\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken();\n    }\n\n    if (next === 61) size = 2;\n    return this.finishOp(tt.relational, size);\n  };\n\n  pp$7.readToken_eq_excl = function (code) {\n    // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n      // '=>'\n      this.pos += 2;\n      return this.finishToken(tt.arrow);\n    }\n\n    return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1);\n  };\n\n  pp$7.getTokenFromCode = function (code) {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n      case 46:\n        // '.'\n        return this.readToken_dot();\n      // Punctuation tokens.\n\n      case 40:\n        ++this.pos;\n        return this.finishToken(tt.parenL);\n\n      case 41:\n        ++this.pos;\n        return this.finishToken(tt.parenR);\n\n      case 59:\n        ++this.pos;\n        return this.finishToken(tt.semi);\n\n      case 44:\n        ++this.pos;\n        return this.finishToken(tt.comma);\n\n      case 91:\n        ++this.pos;\n        return this.finishToken(tt.bracketL);\n\n      case 93:\n        ++this.pos;\n        return this.finishToken(tt.bracketR);\n\n      case 123:\n        ++this.pos;\n        return this.finishToken(tt.braceL);\n\n      case 125:\n        ++this.pos;\n        return this.finishToken(tt.braceR);\n\n      case 58:\n        ++this.pos;\n        return this.finishToken(tt.colon);\n\n      case 63:\n        ++this.pos;\n        return this.finishToken(tt.question);\n\n      case 96:\n        // '`'\n        if (this.options.ecmaVersion < 6) break;\n        ++this.pos;\n        return this.finishToken(tt.backQuote);\n\n      case 48:\n        // '0'\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number\n\n        if (this.options.ecmaVersion >= 6) {\n          if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number\n\n          if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number\n        }\n\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        // 1-9\n        return this.readNumber(false);\n      // Quotes produce strings.\n\n      case 34:\n      case 39:\n        // '\"', \"'\"\n        return this.readString(code);\n      // Operators are parsed inline in tiny state machines. '=' (61) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case 47:\n        // '/'\n        return this.readToken_slash();\n\n      case 37:\n      case 42:\n        // '%*'\n        return this.readToken_mult_modulo_exp(code);\n\n      case 124:\n      case 38:\n        // '|&'\n        return this.readToken_pipe_amp(code);\n\n      case 94:\n        // '^'\n        return this.readToken_caret();\n\n      case 43:\n      case 45:\n        // '+-'\n        return this.readToken_plus_min(code);\n\n      case 60:\n      case 62:\n        // '<>'\n        return this.readToken_lt_gt(code);\n\n      case 61:\n      case 33:\n        // '=!'\n        return this.readToken_eq_excl(code);\n\n      case 126:\n        // '~'\n        return this.finishOp(tt.prefix, 1);\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  pp$7.finishOp = function (type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str);\n  }; // Parse a regular expression. Some context-awareness is necessary,\n  // since a '/' inside a '[]' set does not end the expression.\n\n\n  function tryCreateRegexp(src, flags, throwErrorAt, parser) {\n    try {\n      return new RegExp(src, flags);\n    } catch (e) {\n      if (throwErrorAt !== undefined) {\n        if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message);\n        throw e;\n      }\n    }\n  }\n\n  var regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\");\n\n  pp$7.readRegexp = function () {\n    var this$1 = this;\n    var escaped,\n        inClass,\n        start = this.pos;\n\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) this$1.raise(start, \"Unterminated regular expression\");\n      var ch = this$1.input.charAt(this$1.pos);\n      if (lineBreak.test(ch)) this$1.raise(start, \"Unterminated regular expression\");\n\n      if (!escaped) {\n        if (ch === \"[\") inClass = true;else if (ch === \"]\" && inClass) inClass = false;else if (ch === \"/\" && !inClass) break;\n        escaped = ch === \"\\\\\";\n      } else escaped = false;\n\n      ++this$1.pos;\n    }\n\n    var content = this.input.slice(start, this.pos);\n    ++this.pos; // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n\n    var mods = this.readWord1();\n    var tmp = content,\n        tmpFlags = \"\";\n\n    if (mods) {\n      var validFlags = /^[gim]*$/;\n      if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/;\n      if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\");\n\n      if (mods.indexOf(\"u\") >= 0) {\n        if (regexpUnicodeSupport) {\n          tmpFlags = \"u\";\n        } else {\n          // Replace each astral symbol and every Unicode escape sequence that\n          // possibly represents an astral symbol or a paired surrogate with a\n          // single ASCII symbol to avoid throwing on regular expressions that\n          // are only valid in combination with the `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n          // be replaced by `[x-b]` which throws an error.\n          tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n            code = Number(\"0x\" + code);\n            if (code > 0x10FFFF) this$1.raise(start + offset + 3, \"Code point out of bounds\");\n            return \"x\";\n          });\n          tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\");\n          tmpFlags = tmpFlags.replace(\"u\", \"\");\n        }\n      }\n    } // Detect invalid regular expressions.\n\n\n    var value = null; // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n    // so don't do detection if we are running under Rhino\n\n    if (!isRhino) {\n      tryCreateRegexp(tmp, tmpFlags, start, this); // Get a regular expression object for this pattern-flag pair, or `null` in\n      // case the current environment doesn't support the flags it uses.\n\n      value = tryCreateRegexp(content, mods);\n    }\n\n    return this.finishToken(tt.regexp, {\n      pattern: content,\n      flags: mods,\n      value: value\n    });\n  }; // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n\n  pp$7.readInt = function (radix, len) {\n    var this$1 = this;\n    var start = this.pos,\n        total = 0;\n\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this$1.input.charCodeAt(this$1.pos),\n          val;\n      if (code >= 97) val = code - 97 + 10; // a\n      else if (code >= 65) val = code - 65 + 10; // A\n      else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n      else val = Infinity;\n      if (val >= radix) break;\n      ++this$1.pos;\n      total = total * radix + val;\n    }\n\n    if (this.pos === start || len != null && this.pos - start !== len) return null;\n    return total;\n  };\n\n  pp$7.readRadixNumber = function (radix) {\n    this.pos += 2; // 0x\n\n    var val = this.readInt(radix);\n    if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix);\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n    return this.finishToken(tt.num, val);\n  }; // Read an integer, octal integer, or floating-point number.\n\n\n  pp$7.readNumber = function (startsWithDot) {\n    var start = this.pos,\n        isFloat = false,\n        octal = this.input.charCodeAt(this.pos) === 48;\n    if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\");\n    if (octal && this.pos == start + 1) octal = false;\n    var next = this.input.charCodeAt(this.pos);\n\n    if (next === 46 && !octal) {\n      // '.'\n      ++this.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.pos);\n    }\n\n    if ((next === 69 || next === 101) && !octal) {\n      // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n      if (next === 43 || next === 45) ++this.pos; // '+-'\n\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n    var str = this.input.slice(start, this.pos),\n        val;\n    if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\");else val = parseInt(str, 8);\n    return this.finishToken(tt.num, val);\n  }; // Read a string value, interpreting backslash-escapes.\n\n\n  pp$7.readCodePoint = function () {\n    var ch = this.input.charCodeAt(this.pos),\n        code;\n\n    if (ch === 123) {\n      if (this.options.ecmaVersion < 6) this.unexpected();\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);\n      ++this.pos;\n      if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\");\n    } else {\n      code = this.readHexChar(4);\n    }\n\n    return code;\n  };\n\n  function codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n  }\n\n  pp$7.readString = function (quote) {\n    var this$1 = this;\n    var out = \"\",\n        chunkStart = ++this.pos;\n\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated string constant\");\n      var ch = this$1.input.charCodeAt(this$1.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        // '\\'\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        out += this$1.readEscapedChar(false);\n        chunkStart = this$1.pos;\n      } else {\n        if (isNewLine(ch)) this$1.raise(this$1.start, \"Unterminated string constant\");\n        ++this$1.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(tt.string, out);\n  }; // Reads template string tokens.\n\n\n  pp$7.readTmplToken = function () {\n    var this$1 = this;\n    var out = \"\",\n        chunkStart = this.pos;\n\n    for (;;) {\n      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated template\");\n      var ch = this$1.input.charCodeAt(this$1.pos);\n\n      if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {\n        // '`', '${'\n        if (this$1.pos === this$1.start && this$1.type === tt.template) {\n          if (ch === 36) {\n            this$1.pos += 2;\n            return this$1.finishToken(tt.dollarBraceL);\n          } else {\n            ++this$1.pos;\n            return this$1.finishToken(tt.backQuote);\n          }\n        }\n\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        return this$1.finishToken(tt.template, out);\n      }\n\n      if (ch === 92) {\n        // '\\'\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        out += this$1.readEscapedChar(true);\n        chunkStart = this$1.pos;\n      } else if (isNewLine(ch)) {\n        out += this$1.input.slice(chunkStart, this$1.pos);\n        ++this$1.pos;\n\n        switch (ch) {\n          case 13:\n            if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos;\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        if (this$1.options.locations) {\n          ++this$1.curLine;\n          this$1.lineStart = this$1.pos;\n        }\n\n        chunkStart = this$1.pos;\n      } else {\n        ++this$1.pos;\n      }\n    }\n  }; // Used to read escaped characters\n\n\n  pp$7.readEscapedChar = function (inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n      // 'n' -> '\\n'\n\n      case 114:\n        return \"\\r\";\n      // 'r' -> '\\r'\n\n      case 120:\n        return String.fromCharCode(this.readHexChar(2));\n      // 'x'\n\n      case 117:\n        return codePointToString(this.readCodePoint());\n      // 'u'\n\n      case 116:\n        return \"\\t\";\n      // 't' -> '\\t'\n\n      case 98:\n        return \"\\b\";\n      // 'b' -> '\\b'\n\n      case 118:\n        return \"\\u000b\";\n      // 'v' -> '\\u000b'\n\n      case 102:\n        return \"\\f\";\n      // 'f' -> '\\f'\n\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) ++this.pos;\n      // '\\r\\n'\n\n      case 10:\n        // ' \\n'\n        if (this.options.locations) {\n          this.lineStart = this.pos;\n          ++this.curLine;\n        }\n\n        return \"\";\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n          var octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n            this.raise(this.pos - 2, \"Octal literal in strict mode\");\n          }\n\n          this.pos += octalStr.length - 1;\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }; // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n\n  pp$7.readHexChar = function (len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) this.raise(codePos, \"Bad character escape sequence\");\n    return n;\n  }; // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n\n  pp$7.readWord1 = function () {\n    var this$1 = this;\n    this.containsEsc = false;\n    var word = \"\",\n        first = true,\n        chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n\n    while (this.pos < this.input.length) {\n      var ch = this$1.fullCharCodeAtPos();\n\n      if (isIdentifierChar(ch, astral)) {\n        this$1.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        // \"\\\"\n        this$1.containsEsc = true;\n        word += this$1.input.slice(chunkStart, this$1.pos);\n        var escStart = this$1.pos;\n        if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n          this$1.raise(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        ++this$1.pos;\n        var esc = this$1.readCodePoint();\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) this$1.raise(escStart, \"Invalid Unicode escape\");\n        word += codePointToString(esc);\n        chunkStart = this$1.pos;\n      } else {\n        break;\n      }\n\n      first = false;\n    }\n\n    return word + this.input.slice(chunkStart, this.pos);\n  }; // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n\n  pp$7.readWord = function () {\n    var word = this.readWord1();\n    var type = tt.name;\n\n    if (this.keywords.test(word)) {\n      if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word);\n      type = keywordTypes[word];\n    }\n\n    return this.finishToken(type, word);\n  }; // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n  //\n  // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n  // various contributors and released under an MIT license.\n  //\n  // Git repositories for Acorn are available at\n  //\n  //     http://marijnhaverbeke.nl/git/acorn\n  //     https://github.com/ternjs/acorn.git\n  //\n  // Please use the [github bug tracker][ghbt] to report issues.\n  //\n  // [ghbt]: https://github.com/ternjs/acorn/issues\n  //\n  // This file defines the main parser interface. The library also comes\n  // with a [error-tolerant parser][dammit] and an\n  // [abstract syntax tree walker][walk], defined in other files.\n  //\n  // [dammit]: acorn_loose.js\n  // [walk]: util/walk.js\n\n\n  var version = \"4.0.11\"; // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return new Parser(options, input).parse();\n  } // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n\n  function parseExpressionAt(input, pos, options) {\n    var p = new Parser(options, input, pos);\n    p.nextToken();\n    return p.parseExpression();\n  } // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n\n  function tokenizer(input, options) {\n    return new Parser(options, input);\n  } // This is a terrible kludge to support the existing, pre-ES6\n  // interface where the loose parser module retroactively adds exports\n  // to this module.\n\n\n  function addLooseExports(parse, Parser, plugins) {\n    exports.parse_dammit = parse;\n    exports.LooseParser = Parser;\n    exports.pluginsLoose = plugins;\n  }\n\n  exports.version = version;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokenizer = tokenizer;\n  exports.addLooseExports = addLooseExports;\n  exports.Parser = Parser;\n  exports.plugins = plugins;\n  exports.defaultOptions = defaultOptions;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.getLineInfo = getLineInfo;\n  exports.Node = Node;\n  exports.TokenType = TokenType;\n  exports.tokTypes = tt;\n  exports.keywordTypes = keywordTypes;\n  exports.TokContext = TokContext;\n  exports.tokContexts = types;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.Token = Token;\n  exports.isNewLine = isNewLine;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/acorn/dist/acorn.js"],"names":["global","factory","exports","module","define","amd","acorn","reservedWords","strict","strictBind","ecma5AndLessKeywords","keywords","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","code","set","pos","i","length","isIdentifierStart","astral","test","String","fromCharCode","isIdentifierChar","TokenType","label","conf","keyword","beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","binop","updateContext","name","prec","keywordTypes","kw","options","tt","num","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","arrow","template","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","source","isNewLine","nonASCIIwhitespace","skipWhiteSpace","isArray","obj","Object","prototype","toString","call","has","propName","hasOwnProperty","Position","line","col","column","offset","n","SourceLocation","p","start","end","sourceFile","getLineInfo","input","cur","lastIndex","match","exec","index","defaultOptions","ecmaVersion","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowHashBang","locations","onToken","onComment","ranges","program","directSourceFile","preserveParens","plugins","getOptions","opts","opt","tokens","token","push","pushComment","array","block","text","startLoc","endLoc","comment","type","value","loc","range","keywordRegexp","words","replace","Parser","startPos","reserved","v","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","lineStart","lastIndexOf","curLine","slice","split","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","isKeyword","word","isReservedWord","extend","f","pluginConfigs","this$1","plugin","Error","parse","node","startNode","nextToken","parseTopLevel","pp","literal","eat","next","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","raise","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","expression","pp$1","body","stmt","parseStatement","finishNode","loopLabel","kind","switchLabel","isLet","skip","nextCh","charCodeAt","ident","isAsyncFunction","charAt","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseExpression","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","pop","parseParenExpression","parseFor","init$1","parseVar","declarations","init","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","isFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","empty","handler","clause","param","parseBindingAtom","finalizer","object","i$1","statementStart","generator","update","left","right","isFor","decl","parseVarId","parseMaybeAssign","id","isStatement","allowExpressionBody","initFunction","async","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","method","isGenerator","isMaybeStatic","parsePropertyName","static","computed","key","isGetSet","parseClassMethod","paramCount","parseMethod","superClass","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","local","checkPatternExport","pat","properties","elements","elt","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","pp$2","isBinding","prop","toAssignableList","operator","exprList","last","arg","parseSpread","parseRest","allowNonIdent","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","startNodeAt","checkClashes","pp$3","checkPropClash","propHash","shorthand","proto","other","get","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","op","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","result","parseSubscripts","base","noCalls","maybeAsyncArrow","property","parseExprList","parseArrowExpression","callee","arguments","tag","quasi","parseTemplate","canBeArrow","parseLiteral","regex","pattern","flags","raw","parseParenAndDistinguishExpression","parseNew","val","innerStartPos","innerStartLoc","lastIsComma","spreadStart","innerParenStart","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isPattern","parsePropertyValue","isArrowFunction","isExpression","oldStrict","useStrict","nonSimple","isSimpleParamList","oldLabels","checkParams","nameHash","liberal","indexOf","delegate","pp$4","message","err","SyntaxError","raisedAt","Node","parser","pp$5","TokContext","isExpr","preserveSpace","override","types","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","readTmplToken","f_expr","pp$6","braceIsBlock","prevType","parent","curContext","out","statementParens","Token","pp$7","isRhino","Packages","getToken","Symbol","iterator","self","done","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","ch","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","size","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","codePointToString","str","tryCreateRegexp","src","throwErrorAt","e","undefined","regexpUnicodeSupport","escaped","inClass","content","mods","readWord1","tmp","tmpFlags","validFlags","_match","Number","readInt","radix","len","total","Infinity","startsWithDot","isFloat","octal","parseFloat","parseInt","readCodePoint","codePos","readHexChar","quote","chunkStart","readEscapedChar","inTemplate","octalStr","substr","escStart","esc","version","parseExpressionAt","tokenizer","addLooseExports","parse_dammit","LooseParser","pluginsLoose","tokTypes","tokContexts","defineProperty"],"mappings":"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","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.acorn = global.acorn || {})));\n}(this, (function (exports) { 'use strict';\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n}\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n}\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\"\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\"\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\")\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\")\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i]\n    if (pos > code) return false\n    pos += set[i + 1]\n    if (pos >= code) return true\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) return code === 36\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) return code === 36\n  if (code < 58) return true\n  if (code < 65) return false\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label\n  this.keyword = conf.keyword\n  this.beforeExpr = !!conf.beforeExpr\n  this.startsExpr = !!conf.startsExpr\n  this.isLoop = !!conf.isLoop\n  this.isAssign = !!conf.isAssign\n  this.prefix = !!conf.prefix\n  this.postfix = !!conf.postfix\n  this.binop = conf.binop || null\n  this.updateContext = null\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n// Map keyword names to token types.\n\nvar keywordTypes = {}\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name\n  return keywordTypes[name] = new TokenType(name, options)\n}\n\nvar tt = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\"),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n}\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/\nvar lineBreakG = new RegExp(lineBreak.source, \"g\")\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Array]\"\n}\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName)\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line\n  this.column = col\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start\n  this.end = end\n  if (p.sourceFile !== null) this.source = p.sourceFile\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur\n    var match = lineBreakG.exec(input)\n    if (match && match.index < offset) {\n      ++line\n      cur = match.index + match[0].length\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n}\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {}\n\n  for (var opt in defaultOptions)\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]\n\n  if (options.ecmaVersion >= 2015)\n    options.ecmaVersion -= 2009\n\n  if (options.allowReserved == null)\n    options.allowReserved = options.ecmaVersion < 5\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken\n    options.onToken = function (token) { return tokens.push(token); }\n  }\n  if (isArray(options.onComment))\n    options.onComment = pushComment(options, options.onComment)\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? 'Block' : 'Line',\n      value: text,\n      start: start,\n      end: end\n    }\n    if (options.locations)\n      comment.loc = new SourceLocation(this, startLoc, endLoc)\n    if (options.ranges)\n      comment.range = [start, end]\n    array.push(comment)\n  }\n}\n\n// Registered plugins\nvar plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options)\n  this.sourceFile = options.sourceFile\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n  var reserved = \"\"\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      if (reserved = reservedWords[v]) break\n    if (options.sourceType == \"module\") reserved += \" await\"\n  }\n  this.reservedWords = keywordRegexp(reserved)\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n  this.reservedWordsStrict = keywordRegexp(reservedStrict)\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n  this.input = String(input)\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false\n\n  // Load plugins\n  this.loadPlugins(options.plugins)\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n  } else {\n    this.pos = this.lineStart = 0\n    this.curLine = 1\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = tt.eof\n  // For tokens that include more information than their type, the value\n  this.value = null\n  // Its start and end offset\n  this.start = this.end = this.pos\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition()\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null\n  this.lastTokStart = this.lastTokEnd = this.pos\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext()\n  this.exprAllowed = true\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\"\n  this.strict = this.inModule || this.strictDirective(this.pos)\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0\n  // Labels in scope.\n  this.labels = []\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')\n    this.skipLineComment(2)\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name])\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name]\n    if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n    plugin(this$1, pluginConfigs[name])\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode()\n  this.nextToken()\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:[^\\']|\\.)*)'|\"((?:[^\\\"]|\\.)*)\"|;)/\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start\n    start += skipWhiteSpace.exec(this$1.input)[0].length\n    var match = literal.exec(this$1.input.slice(start))\n    if (!match) return false\n    if ((match[1] || match[2]) == \"use strict\") return true\n    start += match[0].length\n  }\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    if (!notNext)\n      this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n\nvar DestructuringErrors = function DestructuringErrors() {\n  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1\n};\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) return\n  if (refDestructuringErrors.trailingComma > -1)\n    this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\")\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind\n  if (parens > -1) this.raiseRecoverable(parens, \"Parenthesized pattern\")\n}\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1\n  if (!andThrow) return pos >= 0\n  if (pos > -1) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n}\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    this.raise(this.yieldPos, \"Yield expression cannot be a default value\")\n  if (this.awaitPos)\n    this.raise(this.awaitPos, \"Await expression cannot be a default value\")\n}\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    return this.isSimpleAssignTarget(expr.expression)\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n}\n\nvar pp$1 = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {}\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    var stmt = this$1.parseStatement(true, true, exports)\n    node.body.push(stmt)\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\npp$1.isLet = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)\n  if (nextCh === 91 || nextCh == 123) return true // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}\n    var ident = this.input.slice(next, pos)\n    if (!this.isKeyword(ident)) return true\n  }\n  return false\n}\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    return false\n\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind\n\n  if (this.isLet()) {\n    starttype = tt._var\n    kind = \"let\"\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node, false)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._const: case tt._var:\n    kind = kind || this.value\n    if (!declaration && kind != \"var\") this.unexpected()\n    return this.parseVarStatement(node, kind)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next()\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp$1.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  var isLet = this.isLet()\n  if (this.type === tt._var || this.type === tt._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value\n    this.next()\n    this.parseVar(init$1, true, kind)\n    this.finishNode(init$1, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init))\n      return this.parseForIn(node, init$1)\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors\n  var init = this.parseExpression(true, refDestructuringErrors)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init)\n    this.checkLVal(init)\n    this.checkPatternErrors(refDestructuringErrors, true)\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return this.parseFor(node, init)\n}\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next()\n  return this.parseFunction(node, true, false, isAsync)\n}\n\npp$1.isFunction = function() {\n  return this.type === tt._function || this.isAsyncFunction()\n}\n\npp$1.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction())\n  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault = false; this.type != tt.braceR;) {\n    if (this$1.type === tt._case || this$1.type === tt._default) {\n      var isCase = this$1.type === tt._case\n      if (cur) this$1.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this$1.startNode())\n      cur.consequent = []\n      this$1.next()\n      if (isCase) {\n        cur.test = this$1.parseExpression()\n      } else {\n        if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this$1.expect(tt.colon)\n    } else {\n      if (!cur) this$1.unexpected()\n      cur.consequent.push(this$1.parseStatement(true))\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp$1.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = []\n\npp$1.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    var clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.checkLVal(clause.param, true)\n    this.expect(tt.parenR)\n    clause.body = this.parseBlock()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp$1.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp$1.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i = 0; i < this.labels.length; ++i)\n    if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  var kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {\n    var label = this$1.labels[i$1]\n    if (label.statementStart == node.start) {\n      label.statementStart = this$1.start\n      label.kind = kind\n    } else break\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n  node.body = this.parseStatement(true)\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && (this.strict || node.body.kind != \"var\") ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\")\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  node.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    var stmt = this$1.parseStatement(true)\n    node.body.push(stmt)\n  }\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = []\n  node.kind = kind\n  for (;;) {\n    var decl = this$1.startNode()\n    this$1.parseVarId(decl)\n    if (this$1.eat(tt.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor)\n    } else if (kind === \"const\" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === tt._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"))\n    if (!this$1.eat(tt.comma)) break\n  }\n  return node\n}\n\npp$1.parseVarId = function(decl) {\n  decl.id = this.parseBindingAtom()\n  this.checkLVal(decl.id, true)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    node.generator = this.eat(tt.star)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  if (isStatement == null)\n    isStatement = this.type == tt.name\n  if (isStatement)\n    node.id = this.parseIdent()\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  if (!isStatement && this.type === tt.name)\n    node.id = this.parseIdent()\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true)\n  this.checkYieldAwaitInDefaultParams()\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next()\n  if (isStatement == null) isStatement = this.type === tt.name\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  var classBody = this.startNode()\n  var hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this$1.eat(tt.semi)) continue\n    var method = this$1.startNode()\n    var isGenerator = this$1.eat(tt.star)\n    var isAsync = false\n    var isMaybeStatic = this$1.type === tt.name && this$1.value === \"static\"\n    this$1.parsePropertyName(method)\n    method.static = isMaybeStatic && this$1.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this$1.unexpected()\n      isGenerator = this$1.eat(tt.star)\n      this$1.parsePropertyName(method)\n    }\n    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== tt.parenL &&\n        !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    var isGetSet = false\n    if (!method.computed) {\n      var key = method.key;\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this$1.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this$1.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this$1.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this$1.raise(key.start, \"Constructor can't be a generator\")\n        if (isAsync) this$1.raise(key.start, \"Constructor can't be an async method\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this$1.parseClassMethod(classBody, method, isGenerator, isAsync)\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start\n        if (method.kind === \"get\")\n          this$1.raiseRecoverable(start, \"getter should have no params\")\n        else\n          this$1.raiseRecoverable(start, \"setter should have exactly one param\")\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\")\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null\n}\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart)\n    var isAsync\n    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode()\n      this.next()\n      if (isAsync) this.next()\n      node.declaration = this.parseFunction(fNode, null, false, isAsync)\n    } else if (this.type === tt._class) {\n      var cNode = this.startNode()\n      node.declaration = this.parseClass(cNode, null)\n    } else {\n      node.declaration = this.parseMaybeAssign()\n      this.semicolon()\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    if (node.declaration.type === \"VariableDeclaration\")\n      this.checkVariableExport(exports, node.declaration.declarations)\n    else\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers(exports)\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      // check for keywords used as local names\n      for (var i = 0; i < node.specifiers.length; i++) {\n        if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {\n          this$1.unexpected(node.specifiers[i].local.start)\n        }\n      }\n\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) return\n  if (Object.prototype.hasOwnProperty.call(exports, name))\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\")\n  exports[name] = true\n}\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type\n  if (type == \"Identifier\")\n    this.checkExport(exports, pat.name, pat.start)\n  else if (type == \"ObjectPattern\")\n    for (var i = 0; i < pat.properties.length; ++i)\n      this$1.checkPatternExport(exports, pat.properties[i].value)\n  else if (type == \"ArrayPattern\")\n    for (var i$1 = 0; i$1 < pat.elements.length; ++i$1) {\n      var elt = pat.elements[i$1]\n      if (elt) this$1.checkPatternExport(exports, elt)\n    }\n  else if (type == \"AssignmentPattern\")\n    this.checkPatternExport(exports, pat.left)\n  else if (type == \"ParenthesizedExpression\")\n    this.checkPatternExport(exports, pat.expression)\n}\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) return\n  for (var i = 0; i < decls.length; i++)\n    this$1.checkPatternExport(exports, decls[i].id)\n}\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\"\n    || this.type.keyword === \"const\"\n    || this.type.keyword === \"class\"\n    || this.type.keyword === \"function\"\n    || this.isLet()\n    || this.isAsyncFunction()\n}\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node = this$1.startNode()\n    node.local = this$1.parseIdent(true)\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local\n    this$1.checkExport(exports, node.exported.name, node.exported.start)\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    var node$1 = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node$1.local = this.parseIdent()\n    this.checkLVal(node$1.local, true)\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node$2 = this$1.startNode()\n    node$2.imported = this$1.parseIdent(true)\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent()\n    } else {\n      node$2.local = node$2.imported\n      if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)\n      if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, \"The keyword '\" + node$2.local.name + \"' is reserved\")\n    }\n    this$1.checkLVal(node$2.local, true)\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n\nvar pp$2 = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n      case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        this.raise(node.start, \"Can not use 'await' as identifier inside an async function\")\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (var i = 0; i < node.properties.length; i++) {\n        var prop = node.properties[i]\n        if (prop.kind !== \"init\") this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this$1.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        this.toAssignable(node.left, isBinding)\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length\n  if (end) {\n    var last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      var arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i]\n    if (elt) this$1.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp$2.parseRest = function(allowNonIdent) {\n  var node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    var node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this$1.expect(tt.comma)\n    if (allowEmpty && this$1.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === tt.ellipsis) {\n      var rest = this$1.parseRest(allowNonIdent)\n      this$1.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n      this$1.expect(close)\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)\n      this$1.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp$2.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n\npp$2.checkLVal = function(expr, isBinding, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    break\n\n  case \"MemberExpression\":\n    if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0; i < expr.properties.length; i++)\n      this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {\n      var elem = expr.elements[i$1]\n      if (elem) this$1.checkLVal(elem, isBinding, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, isBinding, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, isBinding, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, isBinding, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  var key = prop.key;\n  var name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  var other = propHash[name]\n  if (other) {\n    var isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  var ownDestructuringErrors = false, oldParenAssign = -1\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign\n    refDestructuringErrors.parenthesizedAssign = -1\n  } else {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n\n  var startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    var node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = -1 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      var op = this.value\n      this.next()\n      var startPos = this.start, startLoc = this.startLoc\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors)\n    sawUnary = true\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.operator = this$1.value\n      node$1.prefix = false\n      node$1.argument = expr\n      this$1.checkLVal(expr)\n      this$1.next()\n      expr = this$1.finishNode(node$1, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprAtom(refDestructuringErrors)\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  var result = this.parseSubscripts(expr, startPos, startLoc)\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1\n    if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1\n  }\n  return result\n}\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon()\n  for (var computed;;) {\n    if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true)\n      node.computed = !!computed\n      if (computed) this$1.expect(tt.bracketR)\n      base = this$1.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this$1.eat(tt.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos\n      this$1.yieldPos = 0\n      this$1.awaitPos = 0\n      var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors)\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(tt.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false)\n        this$1.checkYieldAwaitInDefaultParams()\n        this$1.yieldPos = oldYieldPos\n        this$1.awaitPos = oldAwaitPos\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true)\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.callee = base\n      node$1.arguments = exprList\n      base = this$1.finishNode(node$1, \"CallExpression\")\n    } else if (this$1.type === tt.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc)\n      node$2.tag = base\n      node$2.quasi = this$1.parseTemplate()\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    var type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    var startPos = this.start, startLoc = this.startLoc\n    var id = this.parseIdent(this.type !== tt.name)\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(tt._function))\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(tt.arrow))\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === tt.name) {\n        id = this.parseIdent()\n        if (this.canInsertSemicolon() || !this.eat(tt.arrow))\n          this.unexpected()\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case tt.regexp:\n    var value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow)\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        refDestructuringErrors.parenthesizedAssign = start\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        refDestructuringErrors.parenthesizedBind = start\n    }\n    return expr\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp$3.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  var val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc\n    var exprList = [], first = true, lastIsComma = false\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart\n    this.yieldPos = 0\n    this.awaitPos = 0\n    while (this.type !== tt.parenR) {\n      first ? first = false : this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(tt.parenR, true)) {\n        lastIsComma = true\n        break\n      } else if (this$1.type === tt.ellipsis) {\n        spreadStart = this$1.start\n        exprList.push(this$1.parseParenItem(this$1.parseRest()))\n        if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n        break\n      } else {\n        if (this$1.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this$1.start\n        }\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false)\n      this.checkYieldAwaitInDefaultParams()\n      if (innerParenStart) this.unexpected(innerParenStart)\n      this.yieldPos = oldYieldPos\n      this.awaitPos = oldAwaitPos\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    this.yieldPos = oldYieldPos || this.yieldPos\n    this.awaitPos = oldAwaitPos || this.awaitPos\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp$3.parseParenItem = function(item) {\n  return item\n}\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = []\n\npp$3.parseNew = function() {\n  var node = this.startNode()\n  var meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false)\n  else node.arguments = empty$1\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function() {\n  var elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp$3.parseTemplate = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  this.next()\n  node.expressions = []\n  var curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this$1.expect(tt.dollarBraceL)\n    node.expressions.push(this$1.parseExpression())\n    this$1.expect(tt.braceR)\n    node.quasis.push(curElt = this$1.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc\n    if (this$1.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this$1.start\n        startLoc = this$1.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this$1.eat(tt.star)\n    }\n    this$1.parsePropertyName(prop)\n    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && !prop.computed &&\n        prop.key.type === \"Identifier\" && prop.key.name === \"async\" && this$1.type !== tt.parenL &&\n        this$1.type !== tt.colon && !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(prop, refDestructuringErrors)\n    } else {\n      isAsync = false\n    }\n    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)\n    this$1.checkPropClash(prop, propHash)\n    node.properties.push(this$1.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === tt.colon)\n    this.unexpected()\n\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator, isAsync)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isAsync || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    var paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\") ||\n        (this.inAsync && prop.key.name == \"await\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n  if (this.options.ecmaVersion >= 8)\n    node.async = false\n}\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8)\n  this.checkYieldAwaitInDefaultParams()\n  this.parseFunctionBody(node, false)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = false\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== tt.braceL\n  var oldStrict = this.strict, useStrict = false\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params)\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end)\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\")\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels\n    this.labels = []\n    if (useStrict) this.strict = true\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.labels = oldLabels\n  }\n\n  if (oldStrict || useStrict) {\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    this.checkParams(node)\n    this.strict = oldStrict\n  } else if (isArrowFunction || !this.isSimpleParamList(node.params)) {\n    this.checkParams(node)\n  }\n}\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0; i < params.length; i++)\n    if (params[i].type !== \"Identifier\") return false\n  return true\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node) {\n  var this$1 = this;\n\n  var nameHash = {}\n  for (var i = 0; i < node.params.length; i++) this$1.checkLVal(node.params[i], true, nameHash)\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) break\n    } else first = false\n\n    var elt\n    if (allowEmpty && this$1.type === tt.comma)\n      elt = null\n    else if (this$1.type === tt.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors)\n      if (refDestructuringErrors && this$1.type === tt.comma && refDestructuringErrors.trailingComma < 0)\n        refDestructuringErrors.trailingComma = this$1.start\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors)\n    }\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal) {\n  var node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    if (this.inAsync && this.value === \"await\")\n      this.raiseRecoverable(this.start, \"Can not use 'await' as identifier inside an async function\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) this.yieldPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) this.awaitPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeUnary(null, true)\n  return this.finishNode(node, \"AwaitExpression\")\n}\n\nvar pp$4 = Parser.prototype\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos)\n  message += \" (\" + loc.line + \":\" + loc.column + \")\"\n  var err = new SyntaxError(message)\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos\n  throw err\n}\n\npp$4.raiseRecoverable = pp$4.raise\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n}\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\"\n  this.start = pos\n  this.end = 0\n  if (parser.options.locations)\n    this.loc = new SourceLocation(parser, loc)\n  if (parser.options.directSourceFile)\n    this.sourceFile = parser.options.directSourceFile\n  if (parser.options.ranges)\n    this.range = [pos, 0]\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$5 = Parser.prototype\n\npp$5.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n}\n\npp$5.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n}\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type\n  node.end = pos\n  if (this.options.locations)\n    node.loc.end = loc\n  if (this.options.ranges)\n    node.range[1] = pos\n  return node\n}\n\npp$5.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n}\n\n// Finish node at given position\n\npp$5.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n}\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n  this.token = token\n  this.isExpr = !!isExpr\n  this.preserveSpace = !!preserveSpace\n  this.override = override\n};\n\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", true),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.readTmplToken(); }),\n  f_expr: new TokContext(\"function\", true)\n}\n\nvar pp$6 = Parser.prototype\n\npp$6.initialContext = function() {\n  return [types.b_stat]\n}\n\npp$6.braceIsBlock = function(prevType) {\n  if (prevType === tt.colon) {\n    var parent = this.curContext()\n    if (parent === types.b_stat || parent === types.b_expr)\n      return !parent.isExpr\n  }\n  if (prevType === tt._return)\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR)\n    return true\n  if (prevType == tt.braceL)\n    return this.curContext() === types.b_stat\n  return !this.exprAllowed\n}\n\npp$6.updateContext = function(prevType) {\n  var update, type = this.type\n  if (type.keyword && prevType == tt.dot)\n    this.exprAllowed = false\n  else if (update = type.updateContext)\n    update.call(this, prevType)\n  else\n    this.exprAllowed = type.beforeExpr\n}\n\n// Token-specific context update code\n\ntt.parenR.updateContext = tt.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true\n    return\n  }\n  var out = this.context.pop()\n  if (out === types.b_stat && this.curContext() === types.f_expr) {\n    this.context.pop()\n    this.exprAllowed = false\n  } else if (out === types.b_tmpl) {\n    this.exprAllowed = true\n  } else {\n    this.exprAllowed = !out.isExpr\n  }\n}\n\ntt.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)\n  this.exprAllowed = true\n}\n\ntt.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl)\n  this.exprAllowed = true\n}\n\ntt.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while\n  this.context.push(statementParens ? types.p_stat : types.p_expr)\n  this.exprAllowed = true\n}\n\ntt.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n}\n\ntt._function.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&\n      !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))\n    this.context.push(types.f_expr)\n  this.exprAllowed = false\n}\n\ntt.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    this.context.pop()\n  else\n    this.context.push(types.q_tmpl)\n  this.exprAllowed = false\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type\n  this.value = p.value\n  this.start = p.start\n  this.end = p.end\n  if (p.options.locations)\n    this.loc = new SourceLocation(p, p.startLoc, p.endLoc)\n  if (p.options.ranges)\n    this.range = [p.start, p.end]\n};\n\n// ## Tokenizer\n\nvar pp$7 = Parser.prototype\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\"\n\n// Move to the next token\n\npp$7.next = function() {\n  if (this.options.onToken)\n    this.options.onToken(new Token(this))\n\n  this.lastTokEnd = this.end\n  this.lastTokStart = this.start\n  this.lastTokEndLoc = this.endLoc\n  this.lastTokStartLoc = this.startLoc\n  this.nextToken()\n}\n\npp$7.getToken = function() {\n  this.next()\n  return new Token(this)\n}\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  pp$7[Symbol.iterator] = function () {\n    var self = this\n    return {next: function () {\n      var token = self.getToken()\n      return {\n        done: token.type === tt.eof,\n        value: token\n      }\n    }}\n  }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$7.curContext = function() {\n  return this.context[this.context.length - 1]\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$7.nextToken = function() {\n  var curContext = this.curContext()\n  if (!curContext || !curContext.preserveSpace) this.skipSpace()\n\n  this.start = this.pos\n  if (this.options.locations) this.startLoc = this.curPosition()\n  if (this.pos >= this.input.length) return this.finishToken(tt.eof)\n\n  if (curContext.override) return curContext.override(this)\n  else this.readToken(this.fullCharCodeAtPos())\n}\n\npp$7.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    return this.readWord()\n\n  return this.getTokenFromCode(code)\n}\n\npp$7.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n  var next = this.input.charCodeAt(this.pos + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n\npp$7.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition()\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2)\n  if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\")\n  this.pos = end + 2\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start\n    var match\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine\n      this$1.lineStart = match.index + match[0].length\n    }\n  }\n  if (this.options.onComment)\n    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\npp$7.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos\n  var startLoc = this.options.onComment && this.curPosition()\n  var ch = this.input.charCodeAt(this.pos+=startSkip)\n  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n    ++this$1.pos\n    ch = this$1.input.charCodeAt(this$1.pos)\n  }\n  if (this.options.onComment)\n    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$7.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    switch (ch) {\n      case 32: case 160: // ' '\n        ++this$1.pos\n        break\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n          ++this$1.pos\n        }\n      case 10: case 8232: case 8233:\n        ++this$1.pos\n        if (this$1.options.locations) {\n          ++this$1.curLine\n          this$1.lineStart = this$1.pos\n        }\n        break\n      case 47: // '/'\n        switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n          case 42: // '*'\n            this$1.skipBlockComment()\n            break\n          case 47:\n            this$1.skipLineComment(2)\n            break\n          default:\n            break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this$1.pos\n        } else {\n          break loop\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$7.finishToken = function(type, val) {\n  this.end = this.pos\n  if (this.options.locations) this.endLoc = this.curPosition()\n  var prevType = this.type\n  this.type = type\n  this.value = val\n\n  this.updateContext(prevType)\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$7.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next >= 48 && next <= 57) return this.readNumber(true)\n  var next2 = this.input.charCodeAt(this.pos + 2)\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3\n    return this.finishToken(tt.ellipsis)\n  } else {\n    ++this.pos\n    return this.finishToken(tt.dot)\n  }\n}\n\npp$7.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (this.exprAllowed) {++this.pos; return this.readRegexp()}\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.slash, 1)\n}\n\npp$7.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  var tokentype = code === 42 ? tt.star : tt.modulo\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && next === 42) {\n    ++size\n    tokentype = tt.starstar\n    next = this.input.charCodeAt(this.pos + 2)\n  }\n\n  if (next === 61) return this.finishOp(tt.assign, size + 1)\n  return this.finishOp(tokentype, size)\n}\n\npp$7.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)\n}\n\npp$7.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.bitwiseXOR, 1)\n}\n\npp$7.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n      // A `-->` line comment\n      this.skipLineComment(3)\n      this.skipSpace()\n      return this.nextToken()\n    }\n    return this.finishOp(tt.incDec, 2)\n  }\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.plusMin, 1)\n}\n\npp$7.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2\n    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)\n    return this.finishOp(tt.bitShift, size)\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) this.unexpected()\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4)\n    this.skipSpace()\n    return this.nextToken()\n  }\n  if (next === 61) size = 2\n  return this.finishOp(tt.relational, size)\n}\n\npp$7.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2\n    return this.finishToken(tt.arrow)\n  }\n  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)\n}\n\npp$7.getTokenFromCode = function(code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n    // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(tt.parenL)\n  case 41: ++this.pos; return this.finishToken(tt.parenR)\n  case 59: ++this.pos; return this.finishToken(tt.semi)\n  case 44: ++this.pos; return this.finishToken(tt.comma)\n  case 91: ++this.pos; return this.finishToken(tt.bracketL)\n  case 93: ++this.pos; return this.finishToken(tt.bracketR)\n  case 123: ++this.pos; return this.finishToken(tt.braceL)\n  case 125: ++this.pos; return this.finishToken(tt.braceR)\n  case 58: ++this.pos; return this.finishToken(tt.colon)\n  case 63: ++this.pos; return this.finishToken(tt.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) break\n    ++this.pos\n    return this.finishToken(tt.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number\n      if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n    // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(tt.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\")\n}\n\npp$7.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size)\n  this.pos += size\n  return this.finishToken(type, str)\n}\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags)\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message)\n      throw e\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\")\n\npp$7.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(start, \"Unterminated regular expression\")\n    var ch = this$1.input.charAt(this$1.pos)\n    if (lineBreak.test(ch)) this$1.raise(start, \"Unterminated regular expression\")\n    if (!escaped) {\n      if (ch === \"[\") inClass = true\n      else if (ch === \"]\" && inClass) inClass = false\n      else if (ch === \"/\" && !inClass) break\n      escaped = ch === \"\\\\\"\n    } else escaped = false\n    ++this$1.pos\n  }\n  var content = this.input.slice(start, this.pos)\n  ++this.pos\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1()\n  var tmp = content, tmpFlags = \"\"\n  if (mods) {\n    var validFlags = /^[gim]*$/\n    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/\n    if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\")\n    if (mods.indexOf(\"u\") >= 0) {\n      if (regexpUnicodeSupport) {\n        tmpFlags = \"u\"\n      } else {\n        // Replace each astral symbol and every Unicode escape sequence that\n        // possibly represents an astral symbol or a paired surrogate with a\n        // single ASCII symbol to avoid throwing on regular expressions that\n        // are only valid in combination with the `/u` flag.\n        // Note: replacing with the ASCII symbol `x` might cause false\n        // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n        // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n        // be replaced by `[x-b]` which throws an error.\n        tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n          code = Number(\"0x\" + code)\n          if (code > 0x10FFFF) this$1.raise(start + offset + 3, \"Code point out of bounds\")\n          return \"x\"\n        })\n        tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\")\n        tmpFlags = tmpFlags.replace(\"u\", \"\")\n      }\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, tmpFlags, start, this)\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods)\n  }\n  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})\n}\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$7.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val\n    if (code >= 97) val = code - 97 + 10 // a\n    else if (code >= 65) val = code - 65 + 10 // A\n    else if (code >= 48 && code <= 57) val = code - 48 // 0-9\n    else val = Infinity\n    if (val >= radix) break\n    ++this$1.pos\n    total = total * radix + val\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) return null\n\n  return total\n}\n\npp$7.readRadixNumber = function(radix) {\n  this.pos += 2 // 0x\n  var val = this.readInt(radix)\n  if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix)\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n  return this.finishToken(tt.num, val)\n}\n\n// Read an integer, octal integer, or floating-point number.\n\npp$7.readNumber = function(startsWithDot) {\n  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48\n  if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\")\n  if (octal && this.pos == start + 1) octal = false\n  var next = this.input.charCodeAt(this.pos)\n  if (next === 46 && !octal) { // '.'\n    ++this.pos\n    this.readInt(10)\n    isFloat = true\n    next = this.input.charCodeAt(this.pos)\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos)\n    if (next === 43 || next === 45) ++this.pos // '+-'\n    if (this.readInt(10) === null) this.raise(start, \"Invalid number\")\n    isFloat = true\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n\n  var str = this.input.slice(start, this.pos), val\n  if (isFloat) val = parseFloat(str)\n  else if (!octal || str.length === 1) val = parseInt(str, 10)\n  else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\")\n  else val = parseInt(str, 8)\n  return this.finishToken(tt.num, val)\n}\n\n// Read a string value, interpreting backslash-escapes.\n\npp$7.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code\n\n  if (ch === 123) {\n    if (this.options.ecmaVersion < 6) this.unexpected()\n    var codePos = ++this.pos\n    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)\n    ++this.pos\n    if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\")\n  } else {\n    code = this.readHexChar(4)\n  }\n  return code\n}\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) return String.fromCharCode(code)\n  code -= 0x10000\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$7.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated string constant\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === quote) break\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(false)\n      chunkStart = this$1.pos\n    } else {\n      if (isNewLine(ch)) this$1.raise(this$1.start, \"Unterminated string constant\")\n      ++this$1.pos\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++)\n  return this.finishToken(tt.string, out)\n}\n\n// Reads template string tokens.\n\npp$7.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated template\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && this$1.type === tt.template) {\n        if (ch === 36) {\n          this$1.pos += 2\n          return this$1.finishToken(tt.dollarBraceL)\n        } else {\n          ++this$1.pos\n          return this$1.finishToken(tt.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      return this$1.finishToken(tt.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(true)\n      chunkStart = this$1.pos\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      ++this$1.pos\n      switch (ch) {\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos\n        case 10:\n          out += \"\\n\"\n          break\n        default:\n          out += String.fromCharCode(ch)\n          break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine\n        this$1.lineStart = this$1.pos\n      }\n      chunkStart = this$1.pos\n    } else {\n      ++this$1.pos\n    }\n  }\n}\n\n// Used to read escaped characters\n\npp$7.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos)\n  ++this.pos\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]\n      var octal = parseInt(octalStr, 8)\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1)\n        octal = parseInt(octalStr, 8)\n      }\n      if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n        this.raise(this.pos - 2, \"Octal literal in strict mode\")\n      }\n      this.pos += octalStr.length - 1\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n}\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$7.readHexChar = function(len) {\n  var codePos = this.pos\n  var n = this.readInt(16, len)\n  if (n === null) this.raise(codePos, \"Bad character escape sequence\")\n  return n\n}\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$7.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false\n  var word = \"\", first = true, chunkStart = this.pos\n  var astral = this.options.ecmaVersion >= 6\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos()\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true\n      word += this$1.input.slice(chunkStart, this$1.pos)\n      var escStart = this$1.pos\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        this$1.raise(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\")\n      ++this$1.pos\n      var esc = this$1.readCodePoint()\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        this$1.raise(escStart, \"Invalid Unicode escape\")\n      word += codePointToString(esc)\n      chunkStart = this$1.pos\n    } else {\n      break\n    }\n    first = false\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n}\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$7.readWord = function() {\n  var word = this.readWord1()\n  var type = tt.name\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word)\n    type = keywordTypes[word]\n  }\n  return this.finishToken(type, word)\n}\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"4.0.11\"\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos)\n  p.nextToken()\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nfunction addLooseExports(parse, Parser, plugins) {\n  exports.parse_dammit = parse\n  exports.LooseParser = Parser\n  exports.pluginsLoose = plugins\n}\n\nexports.version = version;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\nexports.addLooseExports = addLooseExports;\nexports.Parser = Parser;\nexports.plugins = plugins;\nexports.defaultOptions = defaultOptions;\nexports.Position = Position;\nexports.SourceLocation = SourceLocation;\nexports.getLineInfo = getLineInfo;\nexports.Node = Node;\nexports.TokenType = TokenType;\nexports.tokTypes = tt;\nexports.keywordTypes = keywordTypes;\nexports.TokContext = TokContext;\nexports.tokContexts = types;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierStart = isIdentifierStart;\nexports.Token = Token;\nexports.isNewLine = isNewLine;\nexports.lineBreak = lineBreak;\nexports.lineBreakG = lineBreakG;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));"]},"metadata":{},"sourceType":"script"}