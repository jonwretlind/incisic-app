{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _babelTypes = _interopRequireDefault(require(\"../lib/babel-types\"));\n\nvar _sanitizeText = _interopRequireDefault(require(\"../utils/sanitize-text\"));\n\nvar _interpolation = require(\"../utils/interpolation\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Find interpolation references in the text\n * and interweave the text with interpolations.\n * @param {string} value - The value to interpolate\n * @param {Array<string>} refs - The array of references\n * @param {Context} context - The context of the expression.\n * @returns {Expression} The interpolation or an array containing\n * text and interpolations.\n */\n\n\nfunction buildInterpolation(value, refs, context) {\n  const splitText = value.split(_interpolation.INTERPOLATION_REFERENCE_REGEX);\n\n  if (refs.length === 1 && splitText.every(text => text === '')) {\n    const ref = context.getInterpolationByRef(refs[0]);\n    return ref || _babelTypes.default.nullLiteral();\n  }\n\n  const textArr = splitText.reduce((arr, value, index) => {\n    const valueArr = value ? [_babelTypes.default.stringLiteral(value)] : [];\n    const interpolation = refs[index] ? context.getInterpolationByRef(refs[index]) : null;\n\n    if (interpolation) {\n      valueArr.push(interpolation);\n    }\n\n    return arr.concat(valueArr);\n  }, []);\n  return _babelTypes.default.callExpression(_babelTypes.default.memberExpression(_babelTypes.default.arrayExpression(textArr), _babelTypes.default.identifier('join')), [_babelTypes.default.stringLiteral('')]);\n}\n\nconst TextVisitor = {\n  jsx(_ref, context) {\n    let {\n      val\n    } = _ref;\n    const refs = (0, _interpolation.getInterpolationRefs)(val);\n\n    if (refs) {\n      const expr = buildInterpolation(val, refs, context);\n      return _babelTypes.default.jSXExpressionContainer(expr);\n    }\n\n    if (/^\\s/.test(val) || /\\s$/.test(val)) {\n      return _babelTypes.default.jSXExpressionContainer(_babelTypes.default.stringLiteral(val));\n    }\n\n    const content = (0, _sanitizeText.default)(val);\n    return _babelTypes.default.jSXText(content);\n  },\n\n  expression(_ref2, context) {\n    let {\n      val\n    } = _ref2;\n    const refs = (0, _interpolation.getInterpolationRefs)(val);\n\n    if (refs) {\n      return buildInterpolation(val, refs, context);\n    }\n\n    return _babelTypes.default.stringLiteral(val);\n  }\n\n};\nvar _default = TextVisitor;\nexports.default = _default;","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/babel-plugin-transform-react-pug/dist/visitors/Text.js"],"names":["Object","defineProperty","exports","value","default","_babelTypes","_interopRequireDefault","require","_sanitizeText","_interpolation","obj","__esModule","buildInterpolation","refs","context","splitText","split","INTERPOLATION_REFERENCE_REGEX","length","every","text","ref","getInterpolationByRef","nullLiteral","textArr","reduce","arr","index","valueArr","stringLiteral","interpolation","push","concat","callExpression","memberExpression","arrayExpression","identifier","TextVisitor","jsx","val","getInterpolationRefs","expr","jSXExpressionContainer","test","content","jSXText","expression","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _babelTypes = _interopRequireDefault(require(\"../lib/babel-types\"));\n\nvar _sanitizeText = _interopRequireDefault(require(\"../utils/sanitize-text\"));\n\nvar _interpolation = require(\"../utils/interpolation\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Find interpolation references in the text\n * and interweave the text with interpolations.\n * @param {string} value - The value to interpolate\n * @param {Array<string>} refs - The array of references\n * @param {Context} context - The context of the expression.\n * @returns {Expression} The interpolation or an array containing\n * text and interpolations.\n */\nfunction buildInterpolation(value, refs, context) {\n  const splitText = value.split(_interpolation.INTERPOLATION_REFERENCE_REGEX);\n\n  if (refs.length === 1 && splitText.every(text => text === '')) {\n    const ref = context.getInterpolationByRef(refs[0]);\n    return ref || _babelTypes.default.nullLiteral();\n  }\n\n  const textArr = splitText.reduce((arr, value, index) => {\n    const valueArr = value ? [_babelTypes.default.stringLiteral(value)] : [];\n    const interpolation = refs[index] ? context.getInterpolationByRef(refs[index]) : null;\n\n    if (interpolation) {\n      valueArr.push(interpolation);\n    }\n\n    return arr.concat(valueArr);\n  }, []);\n  return _babelTypes.default.callExpression(_babelTypes.default.memberExpression(_babelTypes.default.arrayExpression(textArr), _babelTypes.default.identifier('join')), [_babelTypes.default.stringLiteral('')]);\n}\n\nconst TextVisitor = {\n  jsx({\n    val\n  }, context) {\n    const refs = (0, _interpolation.getInterpolationRefs)(val);\n\n    if (refs) {\n      const expr = buildInterpolation(val, refs, context);\n      return _babelTypes.default.jSXExpressionContainer(expr);\n    }\n\n    if (/^\\s/.test(val) || /\\s$/.test(val)) {\n      return _babelTypes.default.jSXExpressionContainer(_babelTypes.default.stringLiteral(val));\n    }\n\n    const content = (0, _sanitizeText.default)(val);\n    return _babelTypes.default.jSXText(content);\n  },\n\n  expression({\n    val\n  }, context) {\n    const refs = (0, _interpolation.getInterpolationRefs)(val);\n\n    if (refs) {\n      return buildInterpolation(val, refs, context);\n    }\n\n    return _babelTypes.default.stringLiteral(val);\n  }\n\n};\nvar _default = TextVisitor;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}