{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DynamicBlock = exports.StaticBlock = exports.BaseKey = void 0;\n\nvar _pugError = _interopRequireDefault(require(\"pug-error\"));\n\nvar _babelTypes = _interopRequireDefault(require(\"./lib/babel-types\"));\n\nvar _addString = _interopRequireDefault(require(\"./utils/add-string\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction toJsxValue(e) {\n  return _babelTypes.default.asStringLiteral(e) || _babelTypes.default.jSXExpressionContainer(e);\n}\n\nclass BaseKey {\n  getKey(fn) {\n    fn(_babelTypes.default.stringLiteral('pug'));\n  }\n\n  handleAttributes(attrs) {}\n\n  end() {}\n\n}\n/*\n * Static blocks are used for things like if statements, that may become arrays\n * behind the sceens, but that do not actually involve iteration, and therefore\n * do not require the user to manually supply a key.\n */\n\n\nexports.BaseKey = BaseKey;\n\nclass StaticBlock {\n  constructor(parent, staticBlockID) {\n    _defineProperty(this, \"_ended\", false);\n\n    _defineProperty(this, \"_parentEnded\", false);\n\n    _defineProperty(this, \"_key\", null);\n\n    _defineProperty(this, \"_pending\", []);\n\n    _defineProperty(this, \"_index\", 0);\n\n    parent.getKey(parentKey => {\n      this._parentEnded = true;\n      this._key = (0, _addString.default)(parentKey, _babelTypes.default.stringLiteral(':' + staticBlockID));\n\n      this._update();\n    });\n  }\n\n  _update() {\n    if (this._ended && this._parentEnded) {\n      const key = this._key;\n\n      if (!key) {\n        throw new Error('Expected key to be an expression');\n      }\n\n      while (this._pending.length) {\n        this._pending.shift()(key);\n      }\n    }\n  }\n\n  getKey(fn) {\n    if (this._pending.indexOf(fn) === -1) {\n      const index = this._index++;\n\n      this._pending.push(key => fn((0, _addString.default)(key, _babelTypes.default.stringLiteral(':' + index))));\n    }\n\n    this._update();\n  }\n\n  handleAttributes(attrs) {}\n\n  end() {\n    this._ended = true;\n\n    this._update();\n  }\n\n}\n/*\n * Dynamic blocks are used for real iteration, we require the user to add a key to\n * at least one element within the array, and then we build keys for all the other\n * elements from that one intial key.\n */\n\n\nexports.StaticBlock = StaticBlock;\n\nclass DynamicBlock {\n  constructor(parent, srcForError, lineNumberForError) {\n    _defineProperty(this, \"_ended\", false);\n\n    _defineProperty(this, \"_localKey\", null);\n\n    _defineProperty(this, \"_parentEnded\", false);\n\n    _defineProperty(this, \"_parentKey\", null);\n\n    _defineProperty(this, \"_pending\", []);\n\n    _defineProperty(this, \"_index\", 0);\n\n    _defineProperty(this, \"_srcForError\", void 0);\n\n    _defineProperty(this, \"_lineNumberForError\", void 0);\n\n    this._srcForError = srcForError;\n    this._lineNumberForError = lineNumberForError;\n    parent.getKey(parentKey => {\n      this._parentEnded = true;\n      this._parentKey = parentKey;\n\n      this._update();\n    });\n  }\n\n  _update() {}\n\n  getKey(fn) {\n    if (this._pending.indexOf(fn) === -1) {\n      const index = this._index++;\n\n      this._pending.push(key => {\n        return fn(key);\n      });\n    }\n\n    this._update();\n  }\n\n  handleAttributes() {}\n\n  end() {\n    this._ended = true;\n\n    this._update();\n  }\n\n}\n\nexports.DynamicBlock = DynamicBlock;","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/babel-plugin-transform-react-pug/dist/block-key.js"],"names":["Object","defineProperty","exports","value","DynamicBlock","StaticBlock","BaseKey","_pugError","_interopRequireDefault","require","_babelTypes","_addString","obj","__esModule","default","_defineProperty","key","enumerable","configurable","writable","toJsxValue","e","asStringLiteral","jSXExpressionContainer","getKey","fn","stringLiteral","handleAttributes","attrs","end","constructor","parent","staticBlockID","parentKey","_parentEnded","_key","_update","_ended","Error","_pending","length","shift","indexOf","index","_index","push","srcForError","lineNumberForError","_srcForError","_lineNumberForError","_parentKey"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DynamicBlock = exports.StaticBlock = exports.BaseKey = void 0;\n\nvar _pugError = _interopRequireDefault(require(\"pug-error\"));\n\nvar _babelTypes = _interopRequireDefault(require(\"./lib/babel-types\"));\n\nvar _addString = _interopRequireDefault(require(\"./utils/add-string\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction toJsxValue(e) {\n  return _babelTypes.default.asStringLiteral(e) || _babelTypes.default.jSXExpressionContainer(e);\n}\n\nclass BaseKey {\n  getKey(fn) {\n    fn(_babelTypes.default.stringLiteral('pug'));\n  }\n\n  handleAttributes(attrs) {}\n\n  end() {}\n\n}\n/*\n * Static blocks are used for things like if statements, that may become arrays\n * behind the sceens, but that do not actually involve iteration, and therefore\n * do not require the user to manually supply a key.\n */\n\n\nexports.BaseKey = BaseKey;\n\nclass StaticBlock {\n  constructor(parent, staticBlockID) {\n    _defineProperty(this, \"_ended\", false);\n\n    _defineProperty(this, \"_parentEnded\", false);\n\n    _defineProperty(this, \"_key\", null);\n\n    _defineProperty(this, \"_pending\", []);\n\n    _defineProperty(this, \"_index\", 0);\n\n    parent.getKey(parentKey => {\n      this._parentEnded = true;\n      this._key = (0, _addString.default)(parentKey, _babelTypes.default.stringLiteral(':' + staticBlockID));\n\n      this._update();\n    });\n  }\n\n  _update() {\n    if (this._ended && this._parentEnded) {\n      const key = this._key;\n\n      if (!key) {\n        throw new Error('Expected key to be an expression');\n      }\n\n      while (this._pending.length) {\n        this._pending.shift()(key);\n      }\n    }\n  }\n\n  getKey(fn) {\n    if (this._pending.indexOf(fn) === -1) {\n      const index = this._index++;\n\n      this._pending.push(key => fn((0, _addString.default)(key, _babelTypes.default.stringLiteral(':' + index))));\n    }\n\n    this._update();\n  }\n\n  handleAttributes(attrs) {}\n\n  end() {\n    this._ended = true;\n\n    this._update();\n  }\n\n}\n/*\n * Dynamic blocks are used for real iteration, we require the user to add a key to\n * at least one element within the array, and then we build keys for all the other\n * elements from that one intial key.\n */\n\n\nexports.StaticBlock = StaticBlock;\n\nclass DynamicBlock {\n  constructor(parent, srcForError, lineNumberForError) {\n    _defineProperty(this, \"_ended\", false);\n\n    _defineProperty(this, \"_localKey\", null);\n\n    _defineProperty(this, \"_parentEnded\", false);\n\n    _defineProperty(this, \"_parentKey\", null);\n\n    _defineProperty(this, \"_pending\", []);\n\n    _defineProperty(this, \"_index\", 0);\n\n    _defineProperty(this, \"_srcForError\", void 0);\n\n    _defineProperty(this, \"_lineNumberForError\", void 0);\n\n    this._srcForError = srcForError;\n    this._lineNumberForError = lineNumberForError;\n    parent.getKey(parentKey => {\n      this._parentEnded = true;\n      this._parentKey = parentKey;\n\n      this._update();\n    });\n  }\n\n  _update() {}\n\n  getKey(fn) {\n    if (this._pending.indexOf(fn) === -1) {\n      const index = this._index++;\n\n      this._pending.push(key => {\n        return fn(key);\n      });\n    }\n\n    this._update();\n  }\n\n  handleAttributes() {}\n\n  end() {\n    this._ended = true;\n\n    this._update();\n  }\n\n}\n\nexports.DynamicBlock = DynamicBlock;"]},"metadata":{},"sourceType":"script"}