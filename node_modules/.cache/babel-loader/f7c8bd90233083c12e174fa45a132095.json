{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseExpression;\n\nvar _parse = _interopRequireDefault(require(\"./parse\"));\n\nvar _addLocToAst = _interopRequireDefault(require(\"./add-loc-to-ast\"));\n\nvar _babelTypes = _interopRequireDefault(require(\"../lib/babel-types\"));\n\nvar _interpolation = require(\"./interpolation\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction parseExpression(src, context) {\n  if ((0, _interpolation.getInterpolationRefs)(src)) {\n    const matched = src.split(_interpolation.INTERPOLATION_REFERENCE_REGEX);\n    const isInterpolation = matched.every(text => text === '');\n\n    if (!isInterpolation) {\n      const errMsg = matched.length === 1 ? `Interpolation does not exist` : `Only an interpolation can be specified. You may want to remove ${matched.join(' ')}.`;\n      throw context.error('INVALID_EXPRESSION', errMsg);\n    }\n\n    const interpolation = context.getInterpolationByRef(src);\n\n    if (interpolation == null) {\n      throw context.error('INVALID_EXPRESSION', `Interpolation does not exist for ${src}`);\n    }\n\n    return interpolation;\n  }\n\n  const val = (0, _parse.default)('x = (' + src + ');', context);\n\n  if (val.length !== 1) {\n    const err = context.error('INVALID_EXPRESSION', `There was an error parsing the expression ${src}.`);\n    throw err;\n  }\n\n  const expressionStatement = _babelTypes.default.asExpressionStatement(val[0]);\n\n  const assignmentExpression = expressionStatement && _babelTypes.default.asAssignmentExpression(expressionStatement.expression);\n\n  if (!assignmentExpression) {\n    const err = context.error('INVALID_EXPRESSION', `There was an error parsing the expression ${src}.`);\n    throw err;\n  }\n\n  (0, _addLocToAst.default)(assignmentExpression);\n  return assignmentExpression.right;\n}","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/babel-plugin-transform-react-pug/dist/utils/parse-expression.js"],"names":["Object","defineProperty","exports","value","default","parseExpression","_parse","_interopRequireDefault","require","_addLocToAst","_babelTypes","_interpolation","obj","__esModule","src","context","getInterpolationRefs","matched","split","INTERPOLATION_REFERENCE_REGEX","isInterpolation","every","text","errMsg","length","join","error","interpolation","getInterpolationByRef","val","err","expressionStatement","asExpressionStatement","assignmentExpression","asAssignmentExpression","expression","right"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,eAAlB;;AAEA,IAAIC,MAAM,GAAGC,sBAAsB,CAACC,OAAO,CAAC,SAAD,CAAR,CAAnC;;AAEA,IAAIC,YAAY,GAAGF,sBAAsB,CAACC,OAAO,CAAC,kBAAD,CAAR,CAAzC;;AAEA,IAAIE,WAAW,GAAGH,sBAAsB,CAACC,OAAO,CAAC,oBAAD,CAAR,CAAxC;;AAEA,IAAIG,cAAc,GAAGH,OAAO,CAAC,iBAAD,CAA5B;;AAEA,SAASD,sBAAT,CAAgCK,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAER,IAAAA,OAAO,EAAEQ;AAAX,GAArC;AAAwD;;AAE/F,SAASP,eAAT,CAAyBS,GAAzB,EAA8BC,OAA9B,EAAuC;AACrC,MAAI,CAAC,GAAGJ,cAAc,CAACK,oBAAnB,EAAyCF,GAAzC,CAAJ,EAAmD;AACjD,UAAMG,OAAO,GAAGH,GAAG,CAACI,KAAJ,CAAUP,cAAc,CAACQ,6BAAzB,CAAhB;AACA,UAAMC,eAAe,GAAGH,OAAO,CAACI,KAAR,CAAcC,IAAI,IAAIA,IAAI,KAAK,EAA/B,CAAxB;;AAEA,QAAI,CAACF,eAAL,EAAsB;AACpB,YAAMG,MAAM,GAAGN,OAAO,CAACO,MAAR,KAAmB,CAAnB,GAAwB,8BAAxB,GAAyD,kEAAiEP,OAAO,CAACQ,IAAR,CAAa,GAAb,CAAkB,GAA3J;AACA,YAAMV,OAAO,CAACW,KAAR,CAAc,oBAAd,EAAoCH,MAApC,CAAN;AACD;;AAED,UAAMI,aAAa,GAAGZ,OAAO,CAACa,qBAAR,CAA8Bd,GAA9B,CAAtB;;AAEA,QAAIa,aAAa,IAAI,IAArB,EAA2B;AACzB,YAAMZ,OAAO,CAACW,KAAR,CAAc,oBAAd,EAAqC,oCAAmCZ,GAAI,EAA5E,CAAN;AACD;;AAED,WAAOa,aAAP;AACD;;AAED,QAAME,GAAG,GAAG,CAAC,GAAGvB,MAAM,CAACF,OAAX,EAAoB,UAAUU,GAAV,GAAgB,IAApC,EAA0CC,OAA1C,CAAZ;;AAEA,MAAIc,GAAG,CAACL,MAAJ,KAAe,CAAnB,EAAsB;AACpB,UAAMM,GAAG,GAAGf,OAAO,CAACW,KAAR,CAAc,oBAAd,EAAqC,6CAA4CZ,GAAI,GAArF,CAAZ;AACA,UAAMgB,GAAN;AACD;;AAED,QAAMC,mBAAmB,GAAGrB,WAAW,CAACN,OAAZ,CAAoB4B,qBAApB,CAA0CH,GAAG,CAAC,CAAD,CAA7C,CAA5B;;AAEA,QAAMI,oBAAoB,GAAGF,mBAAmB,IAAIrB,WAAW,CAACN,OAAZ,CAAoB8B,sBAApB,CAA2CH,mBAAmB,CAACI,UAA/D,CAApD;;AAEA,MAAI,CAACF,oBAAL,EAA2B;AACzB,UAAMH,GAAG,GAAGf,OAAO,CAACW,KAAR,CAAc,oBAAd,EAAqC,6CAA4CZ,GAAI,GAArF,CAAZ;AACA,UAAMgB,GAAN;AACD;;AAED,GAAC,GAAGrB,YAAY,CAACL,OAAjB,EAA0B6B,oBAA1B;AACA,SAAOA,oBAAoB,CAACG,KAA5B;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseExpression;\n\nvar _parse = _interopRequireDefault(require(\"./parse\"));\n\nvar _addLocToAst = _interopRequireDefault(require(\"./add-loc-to-ast\"));\n\nvar _babelTypes = _interopRequireDefault(require(\"../lib/babel-types\"));\n\nvar _interpolation = require(\"./interpolation\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parseExpression(src, context) {\n  if ((0, _interpolation.getInterpolationRefs)(src)) {\n    const matched = src.split(_interpolation.INTERPOLATION_REFERENCE_REGEX);\n    const isInterpolation = matched.every(text => text === '');\n\n    if (!isInterpolation) {\n      const errMsg = matched.length === 1 ? `Interpolation does not exist` : `Only an interpolation can be specified. You may want to remove ${matched.join(' ')}.`;\n      throw context.error('INVALID_EXPRESSION', errMsg);\n    }\n\n    const interpolation = context.getInterpolationByRef(src);\n\n    if (interpolation == null) {\n      throw context.error('INVALID_EXPRESSION', `Interpolation does not exist for ${src}`);\n    }\n\n    return interpolation;\n  }\n\n  const val = (0, _parse.default)('x = (' + src + ');', context);\n\n  if (val.length !== 1) {\n    const err = context.error('INVALID_EXPRESSION', `There was an error parsing the expression ${src}.`);\n    throw err;\n  }\n\n  const expressionStatement = _babelTypes.default.asExpressionStatement(val[0]);\n\n  const assignmentExpression = expressionStatement && _babelTypes.default.asAssignmentExpression(expressionStatement.expression);\n\n  if (!assignmentExpression) {\n    const err = context.error('INVALID_EXPRESSION', `There was an error parsing the expression ${src}.`);\n    throw err;\n  }\n\n  (0, _addLocToAst.default)(assignmentExpression);\n  return assignmentExpression.right;\n}"]},"metadata":{},"sourceType":"script"}