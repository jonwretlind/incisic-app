{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _parseExpression = _interopRequireDefault(require(\"../utils/parse-expression\"));\n\nvar _babelTypes = _interopRequireDefault(require(\"../lib/babel-types\"));\n\nvar _visitors = require(\"../visitors\");\n\nvar _interpolation = require(\"../utils/interpolation\");\n\nvar _jsx = require(\"../utils/jsx\");\n\nvar _getClassNameValue = _interopRequireDefault(require(\"../utils/get-class-name-value\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Get children nodes from the node, passing the node's\n * context to the children and generating JSX values.\n * @param {Object} node - The node\n * @param {Context} context - The context to apply to the children\n * nodes\n * @returns {Array<JSXValue>}\n */\n\n\nfunction getChildren(node, context) {\n  return context.noKey(childContext => (node.code ? [(0, _visitors.visitJsx)(node.code, childContext)] : []).concat((0, _visitors.visitJsxExpressions)(node.block.nodes, childContext)));\n}\n/**\n * Iterate through the node's attributes and convert\n * them into JSX attributes.\n * @param {Object} node - The node\n * @param {Context} context - The context\n * @returns {Array<Attribute>}\n */\n\n\nfunction getAttributes(node, context) {\n  const classesViaAttribute = [];\n  const classesViaShorthand = [];\n  const attrs = node.attrs.map(_ref => {\n    let {\n      name,\n      val,\n      mustEscape\n    } = _ref;\n\n    if (/\\.\\.\\./.test(name) && val === true) {\n      return _babelTypes.default.jSXSpreadAttribute((0, _parseExpression.default)(name.substr(3), context));\n    } // TODO: Need to drop all aliases for attributes\n\n\n    switch (name) {\n      case 'for':\n        name = 'htmlFor';\n        break;\n\n      case 'maxlength':\n        name = 'maxLength';\n        break;\n    }\n\n    const expr = (0, _parseExpression.default)(String(val), context);\n\n    if (!mustEscape) {\n      const canSkipEscaping = (name === 'class' || name === 'id') && _babelTypes.default.isStringLiteral(expr);\n\n      if (!canSkipEscaping) {\n        throw context.error('INVALID_EXPRESSION', 'Unescaped attributes are not supported in react-pug');\n      }\n    }\n\n    if (expr == null) {\n      return null;\n    }\n\n    if (name === 'class') {\n      if (!_babelTypes.default.isStringLiteral(expr)) {\n        throw context.error('INVALID_EXPRESSION', `We can't use expressions in shorthands, use \"${context._options.classAttribute}\" instead of \"class\"`);\n      }\n\n      classesViaShorthand.push(expr);\n      return null;\n    }\n\n    if (name === context._options.classAttribute) {\n      classesViaAttribute.push(expr);\n      return null;\n    }\n\n    const jsxValue = _babelTypes.default.asStringLiteral(expr) || _babelTypes.default.asJSXElement(expr) || _babelTypes.default.jSXExpressionContainer(expr);\n\n    if (/\\.\\.\\./.test(name)) {\n      throw new Error('spread attributes must not have a value');\n    }\n\n    return _babelTypes.default.jSXAttribute(_babelTypes.default.jSXIdentifier(name), jsxValue);\n  }).filter(Boolean);\n\n  if (classesViaShorthand.length || classesViaAttribute.length) {\n    const value = (0, _getClassNameValue.default)(classesViaShorthand, classesViaAttribute);\n    attrs.push(_babelTypes.default.jSXAttribute(_babelTypes.default.jSXIdentifier(context._options.classAttribute), value));\n  }\n\n  return attrs;\n}\n/**\n * Retrieve attributes and children of the passed node.\n * @param {Object} node - The node\n * @param {Context} context - The context\n * @returns {Object} Contains the attributes and children\n * of the node.\n */\n\n\nfunction getAttributesAndChildren(node, context) {\n  const children = getChildren(node, context);\n\n  if (node.attributeBlocks.length) {\n    throw new Error('Attribute blocks are not yet supported in react-pug');\n  }\n\n  const attrs = getAttributes(node, context);\n  context.key.handleAttributes(attrs);\n  return {\n    attrs,\n    children\n  };\n}\n/**\n * Check whether an interpolation exists, if so, check whether\n * the interpolation is a react component and return either\n * the component as a JSX element or the interpolation.\n * @param {string} name - The interpolation reference\n * @param {Context} context - The current context to retrieve\n * the interpolation from\n * @param {Array<JSXValue>} children - Whether the element has\n * attributes or children\n * @returns {?Object} The context's interpolation or a JSX element.\n */\n\n\nfunction getInterpolationByContext(name, context, attrs, children) {\n  if (!(0, _interpolation.getInterpolationRefs)(name)) {\n    return null;\n  }\n\n  const interpolation = context.getInterpolationByRef(name);\n  const isReactComponent = _babelTypes.default.isIdentifier(interpolation) && interpolation.name.charAt(0) === interpolation.name.charAt(0).toUpperCase();\n\n  if (attrs.length || children.length) {\n    if (isReactComponent) {\n      return (0, _jsx.buildJSXElement)(_babelTypes.default.jSXIdentifier(interpolation.name), attrs, children);\n    } else {\n      throw context.error('INVALID_EXPRESSION', `Only components can have children and attributes`);\n    }\n  }\n\n  return interpolation;\n}\n\nconst TagVisitor = {\n  jsx(node, context) {\n    const _getAttributesAndChil = getAttributesAndChildren(node, context),\n          attrs = _getAttributesAndChil.attrs,\n          children = _getAttributesAndChil.children;\n\n    const interpolation = getInterpolationByContext(node.name, context, attrs, children);\n\n    if (interpolation != null) {\n      return _babelTypes.default.asJSXElement(interpolation) || _babelTypes.default.jSXExpressionContainer(interpolation);\n    }\n\n    return (0, _jsx.buildJSXElement)(_babelTypes.default.jSXIdentifier(node.name), attrs, children);\n  },\n\n  expression(node, context) {\n    const _getAttributesAndChil2 = getAttributesAndChildren(node, context),\n          attrs = _getAttributesAndChil2.attrs,\n          children = _getAttributesAndChil2.children;\n\n    const interpolation = getInterpolationByContext(node.name, context, attrs, children);\n\n    if (interpolation != null) {\n      return interpolation;\n    }\n\n    return (0, _jsx.buildJSXElement)(_babelTypes.default.jSXIdentifier(node.name), attrs, children);\n  }\n\n};\nvar _default = TagVisitor;\nexports.default = _default;","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/babel-plugin-transform-react-pug/dist/visitors/Tag.js"],"names":["Object","defineProperty","exports","value","default","_parseExpression","_interopRequireDefault","require","_babelTypes","_visitors","_interpolation","_jsx","_getClassNameValue","obj","__esModule","getChildren","node","context","noKey","childContext","code","visitJsx","concat","visitJsxExpressions","block","nodes","getAttributes","classesViaAttribute","classesViaShorthand","attrs","map","name","val","mustEscape","test","jSXSpreadAttribute","substr","expr","String","canSkipEscaping","isStringLiteral","error","_options","classAttribute","push","jsxValue","asStringLiteral","asJSXElement","jSXExpressionContainer","Error","jSXAttribute","jSXIdentifier","filter","Boolean","length","getAttributesAndChildren","children","attributeBlocks","key","handleAttributes","getInterpolationByContext","getInterpolationRefs","interpolation","getInterpolationByRef","isReactComponent","isIdentifier","charAt","toUpperCase","buildJSXElement","TagVisitor","jsx","_getAttributesAndChil","expression","_getAttributesAndChil2","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _parseExpression = _interopRequireDefault(require(\"../utils/parse-expression\"));\n\nvar _babelTypes = _interopRequireDefault(require(\"../lib/babel-types\"));\n\nvar _visitors = require(\"../visitors\");\n\nvar _interpolation = require(\"../utils/interpolation\");\n\nvar _jsx = require(\"../utils/jsx\");\n\nvar _getClassNameValue = _interopRequireDefault(require(\"../utils/get-class-name-value\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Get children nodes from the node, passing the node's\n * context to the children and generating JSX values.\n * @param {Object} node - The node\n * @param {Context} context - The context to apply to the children\n * nodes\n * @returns {Array<JSXValue>}\n */\nfunction getChildren(node, context) {\n  return context.noKey(childContext => (node.code ? [(0, _visitors.visitJsx)(node.code, childContext)] : []).concat((0, _visitors.visitJsxExpressions)(node.block.nodes, childContext)));\n}\n/**\n * Iterate through the node's attributes and convert\n * them into JSX attributes.\n * @param {Object} node - The node\n * @param {Context} context - The context\n * @returns {Array<Attribute>}\n */\n\n\nfunction getAttributes(node, context) {\n  const classesViaAttribute = [];\n  const classesViaShorthand = [];\n  const attrs = node.attrs.map(({\n    name,\n    val,\n    mustEscape\n  }) => {\n    if (/\\.\\.\\./.test(name) && val === true) {\n      return _babelTypes.default.jSXSpreadAttribute((0, _parseExpression.default)(name.substr(3), context));\n    } // TODO: Need to drop all aliases for attributes\n\n\n    switch (name) {\n      case 'for':\n        name = 'htmlFor';\n        break;\n\n      case 'maxlength':\n        name = 'maxLength';\n        break;\n    }\n\n    const expr = (0, _parseExpression.default)(String(val), context);\n\n    if (!mustEscape) {\n      const canSkipEscaping = (name === 'class' || name === 'id') && _babelTypes.default.isStringLiteral(expr);\n\n      if (!canSkipEscaping) {\n        throw context.error('INVALID_EXPRESSION', 'Unescaped attributes are not supported in react-pug');\n      }\n    }\n\n    if (expr == null) {\n      return null;\n    }\n\n    if (name === 'class') {\n      if (!_babelTypes.default.isStringLiteral(expr)) {\n        throw context.error('INVALID_EXPRESSION', `We can't use expressions in shorthands, use \"${context._options.classAttribute}\" instead of \"class\"`);\n      }\n\n      classesViaShorthand.push(expr);\n      return null;\n    }\n\n    if (name === context._options.classAttribute) {\n      classesViaAttribute.push(expr);\n      return null;\n    }\n\n    const jsxValue = _babelTypes.default.asStringLiteral(expr) || _babelTypes.default.asJSXElement(expr) || _babelTypes.default.jSXExpressionContainer(expr);\n\n    if (/\\.\\.\\./.test(name)) {\n      throw new Error('spread attributes must not have a value');\n    }\n\n    return _babelTypes.default.jSXAttribute(_babelTypes.default.jSXIdentifier(name), jsxValue);\n  }).filter(Boolean);\n\n  if (classesViaShorthand.length || classesViaAttribute.length) {\n    const value = (0, _getClassNameValue.default)(classesViaShorthand, classesViaAttribute);\n    attrs.push(_babelTypes.default.jSXAttribute(_babelTypes.default.jSXIdentifier(context._options.classAttribute), value));\n  }\n\n  return attrs;\n}\n/**\n * Retrieve attributes and children of the passed node.\n * @param {Object} node - The node\n * @param {Context} context - The context\n * @returns {Object} Contains the attributes and children\n * of the node.\n */\n\n\nfunction getAttributesAndChildren(node, context) {\n  const children = getChildren(node, context);\n\n  if (node.attributeBlocks.length) {\n    throw new Error('Attribute blocks are not yet supported in react-pug');\n  }\n\n  const attrs = getAttributes(node, context);\n  context.key.handleAttributes(attrs);\n  return {\n    attrs,\n    children\n  };\n}\n/**\n * Check whether an interpolation exists, if so, check whether\n * the interpolation is a react component and return either\n * the component as a JSX element or the interpolation.\n * @param {string} name - The interpolation reference\n * @param {Context} context - The current context to retrieve\n * the interpolation from\n * @param {Array<JSXValue>} children - Whether the element has\n * attributes or children\n * @returns {?Object} The context's interpolation or a JSX element.\n */\n\n\nfunction getInterpolationByContext(name, context, attrs, children) {\n  if (!(0, _interpolation.getInterpolationRefs)(name)) {\n    return null;\n  }\n\n  const interpolation = context.getInterpolationByRef(name);\n  const isReactComponent = _babelTypes.default.isIdentifier(interpolation) && interpolation.name.charAt(0) === interpolation.name.charAt(0).toUpperCase();\n\n  if (attrs.length || children.length) {\n    if (isReactComponent) {\n      return (0, _jsx.buildJSXElement)(_babelTypes.default.jSXIdentifier(interpolation.name), attrs, children);\n    } else {\n      throw context.error('INVALID_EXPRESSION', `Only components can have children and attributes`);\n    }\n  }\n\n  return interpolation;\n}\n\nconst TagVisitor = {\n  jsx(node, context) {\n    const _getAttributesAndChil = getAttributesAndChildren(node, context),\n          attrs = _getAttributesAndChil.attrs,\n          children = _getAttributesAndChil.children;\n\n    const interpolation = getInterpolationByContext(node.name, context, attrs, children);\n\n    if (interpolation != null) {\n      return _babelTypes.default.asJSXElement(interpolation) || _babelTypes.default.jSXExpressionContainer(interpolation);\n    }\n\n    return (0, _jsx.buildJSXElement)(_babelTypes.default.jSXIdentifier(node.name), attrs, children);\n  },\n\n  expression(node, context) {\n    const _getAttributesAndChil2 = getAttributesAndChildren(node, context),\n          attrs = _getAttributesAndChil2.attrs,\n          children = _getAttributesAndChil2.children;\n\n    const interpolation = getInterpolationByContext(node.name, context, attrs, children);\n\n    if (interpolation != null) {\n      return interpolation;\n    }\n\n    return (0, _jsx.buildJSXElement)(_babelTypes.default.jSXIdentifier(node.name), attrs, children);\n  }\n\n};\nvar _default = TagVisitor;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}