{"ast":null,"code":"'use strict';\n\nvar error = require('pug-error');\n\nmodule.exports = stripComments;\n\nfunction unexpectedToken(type, occasion, filename, line) {\n  var msg = '`' + type + '` encountered when ' + occasion;\n  throw error('UNEXPECTED_TOKEN', msg, {\n    filename: filename,\n    line: line\n  });\n}\n\nfunction stripComments(input, options) {\n  options = options || {}; // Default: strip unbuffered comments and leave buffered ones alone\n\n  var stripUnbuffered = options.stripUnbuffered !== false;\n  var stripBuffered = options.stripBuffered === true;\n  var filename = options.filename;\n  var out = []; // If we have encountered a comment token and are not sure if we have gotten\n  // out of the comment or not\n\n  var inComment = false; // If we are sure that we are in a block comment and all tokens except\n  // `end-pipeless-text` should be ignored\n\n  var inPipelessText = false;\n  return input.filter(function (tok) {\n    switch (tok.type) {\n      case 'comment':\n        if (inComment) {\n          unexpectedToken('comment', 'already in a comment', filename, tok.line);\n        } else {\n          inComment = tok.buffer ? stripBuffered : stripUnbuffered;\n          return !inComment;\n        }\n\n      case 'start-pipeless-text':\n        if (!inComment) return true;\n\n        if (inPipelessText) {\n          unexpectedToken('start-pipeless-text', 'already in pipeless text mode', filename, tok.line);\n        }\n\n        inPipelessText = true;\n        return false;\n\n      case 'end-pipeless-text':\n        if (!inComment) return true;\n\n        if (!inPipelessText) {\n          unexpectedToken('end-pipeless-text', 'not in pipeless text mode', filename, tok.line);\n        }\n\n        inPipelessText = false;\n        inComment = false;\n        return false;\n      // There might be a `text` right after `comment` but before\n      // `start-pipeless-text`. Treat it accordingly.\n\n      case 'text':\n        return !inComment;\n\n      default:\n        if (inPipelessText) return false;\n        inComment = false;\n        return true;\n    }\n  });\n}","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/node_modules/babel-plugin-transform-react-pug/node_modules/pug-strip-comments/index.js"],"names":["error","require","module","exports","stripComments","unexpectedToken","type","occasion","filename","line","msg","input","options","stripUnbuffered","stripBuffered","out","inComment","inPipelessText","filter","tok","buffer"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,WAAD,CAAnB;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,aAAjB;;AAEA,SAASC,eAAT,CAA0BC,IAA1B,EAAgCC,QAAhC,EAA0CC,QAA1C,EAAoDC,IAApD,EAA0D;AACxD,MAAIC,GAAG,GAAG,MAAMJ,IAAN,GAAa,qBAAb,GAAqCC,QAA/C;AACA,QAAMP,KAAK,CAAC,kBAAD,EAAqBU,GAArB,EAA0B;AAAEF,IAAAA,QAAQ,EAAEA,QAAZ;AAAsBC,IAAAA,IAAI,EAAEA;AAA5B,GAA1B,CAAX;AACD;;AAED,SAASL,aAAT,CAAwBO,KAAxB,EAA+BC,OAA/B,EAAwC;AACtCA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CADsC,CAGtC;;AACA,MAAIC,eAAe,GAAGD,OAAO,CAACC,eAAR,KAA4B,KAAlD;AACA,MAAIC,aAAa,GAAKF,OAAO,CAACE,aAAR,KAA4B,IAAlD;AACA,MAAIN,QAAQ,GAAUI,OAAO,CAACJ,QAA9B;AAEA,MAAIO,GAAG,GAAG,EAAV,CARsC,CAStC;AACA;;AACA,MAAIC,SAAS,GAAG,KAAhB,CAXsC,CAYtC;AACA;;AACA,MAAIC,cAAc,GAAG,KAArB;AAEA,SAAON,KAAK,CAACO,MAAN,CAAa,UAAUC,GAAV,EAAe;AACjC,YAAQA,GAAG,CAACb,IAAZ;AACE,WAAK,SAAL;AACE,YAAIU,SAAJ,EAAe;AACbX,UAAAA,eAAe,CACb,SADa,EACF,sBADE,EACsBG,QADtB,EACgCW,GAAG,CAACV,IADpC,CAAf;AAGD,SAJD,MAIO;AACLO,UAAAA,SAAS,GAAGG,GAAG,CAACC,MAAJ,GAAaN,aAAb,GAA6BD,eAAzC;AACA,iBAAO,CAACG,SAAR;AACD;;AACH,WAAK,qBAAL;AACE,YAAI,CAACA,SAAL,EAAgB,OAAO,IAAP;;AAChB,YAAIC,cAAJ,EAAoB;AAClBZ,UAAAA,eAAe,CACb,qBADa,EACU,+BADV,EAEbG,QAFa,EAEHW,GAAG,CAACV,IAFD,CAAf;AAID;;AACDQ,QAAAA,cAAc,GAAG,IAAjB;AACA,eAAO,KAAP;;AACF,WAAK,mBAAL;AACE,YAAI,CAACD,SAAL,EAAgB,OAAO,IAAP;;AAChB,YAAI,CAACC,cAAL,EAAqB;AACnBZ,UAAAA,eAAe,CACb,mBADa,EACQ,2BADR,EAEbG,QAFa,EAEHW,GAAG,CAACV,IAFD,CAAf;AAID;;AACDQ,QAAAA,cAAc,GAAG,KAAjB;AACAD,QAAAA,SAAS,GAAG,KAAZ;AACA,eAAO,KAAP;AACF;AACA;;AACA,WAAK,MAAL;AACE,eAAO,CAACA,SAAR;;AACF;AACE,YAAIC,cAAJ,EAAoB,OAAO,KAAP;AACpBD,QAAAA,SAAS,GAAG,KAAZ;AACA,eAAO,IAAP;AAtCJ;AAwCD,GAzCM,CAAP;AA0CD","sourcesContent":["'use strict';\n\nvar error = require('pug-error');\n\nmodule.exports = stripComments;\n\nfunction unexpectedToken (type, occasion, filename, line) {\n  var msg = '`' + type + '` encountered when ' + occasion;\n  throw error('UNEXPECTED_TOKEN', msg, { filename: filename, line: line });\n}\n\nfunction stripComments (input, options) {\n  options = options || {};\n\n  // Default: strip unbuffered comments and leave buffered ones alone\n  var stripUnbuffered = options.stripUnbuffered !== false;\n  var stripBuffered   = options.stripBuffered   === true;\n  var filename        = options.filename;\n\n  var out = [];\n  // If we have encountered a comment token and are not sure if we have gotten\n  // out of the comment or not\n  var inComment = false;\n  // If we are sure that we are in a block comment and all tokens except\n  // `end-pipeless-text` should be ignored\n  var inPipelessText = false;\n\n  return input.filter(function (tok) {\n    switch (tok.type) {\n      case 'comment':\n        if (inComment) {\n          unexpectedToken(\n            'comment', 'already in a comment', filename, tok.line\n          );\n        } else {\n          inComment = tok.buffer ? stripBuffered : stripUnbuffered;\n          return !inComment;\n        }\n      case 'start-pipeless-text':\n        if (!inComment) return true;\n        if (inPipelessText) {\n          unexpectedToken(\n            'start-pipeless-text', 'already in pipeless text mode',\n            filename, tok.line\n          );\n        }\n        inPipelessText = true;\n        return false;\n      case 'end-pipeless-text':\n        if (!inComment) return true;\n        if (!inPipelessText) {\n          unexpectedToken(\n            'end-pipeless-text', 'not in pipeless text mode',\n            filename, tok.line\n          );\n        }\n        inPipelessText = false;\n        inComment = false;\n        return false;\n      // There might be a `text` right after `comment` but before\n      // `start-pipeless-text`. Treat it accordingly.\n      case 'text':\n        return !inComment;\n      default:\n        if (inPipelessText) return false;\n        inComment = false;\n        return true;\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"script"}