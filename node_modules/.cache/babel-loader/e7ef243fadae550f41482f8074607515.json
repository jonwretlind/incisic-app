{"ast":null,"code":"import React, { Component } from 'react';\nimport Finance from 'financejs';\n\nclass GoalSeek extends React.Component {\n  constructor() {\n    //\n    super();\n  }\n\n  seek(initialValue, dataTable, targetValue) {\n    const finance = new Finance();\n    const n = dataTable.length; // number of periods\n\n    let rate = .1; // initial guess for the rate of return\n    // calculate the net present value of the investments at the initial guess for the rate of return\n\n    let npv = initialValue;\n\n    for (var i = 0; i < n; i++) {\n      console.log(dataTable[i].intRate, dataTable[i].annPay);\n      npv += finance.FV(dataTable[i].intRate, dataTable[i].annPay, 1);\n    }\n\n    console.log(\"initialValue:\", initialValue, \" npv:\", npv, \" targetValue:\", targetValue);\n    /*\n    // iterate until the net present value is close enough to the target value, or until the maximum number of iterations is reached\n    const tolerance = 1e-2;  // tolerance for the error between the net present value and the target value\n    const maxIterations = 1e+5;  // maximum number of iterations\n    let iterations = 0;  // current number of iterations\n    while (Math.abs(npv - targetValue) > tolerance && iterations < maxIterations) {\n      // adjust the rate of return based on the error between the net present value and the target value\n      rate -= (targetValue - npv) / npv;\n       // recalculate the net present value at the new rate of return\n      npv = finance.PV(rate, dataTable[n - 1].balEOY)\n      console.log(npv, Math.abs(npv - targetValue), rate);\n      iterations++;\n    }\n     if (iterations === maxIterations) {\n      throw new Error('Could not find a solution within the maximum number of iterations');\n    }\n    return rate;\n    */\n  }\n\n}\n\nexport default GoalSeek;","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/src/helpers/goalseek.js"],"names":["React","Component","Finance","GoalSeek","constructor","seek","initialValue","dataTable","targetValue","finance","n","length","rate","npv","i","console","log","intRate","annPay","FV"],"mappings":"AACA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,OAAP,MAAoB,WAApB;;AAEA,MAAMC,QAAN,SAAuBH,KAAK,CAACC,SAA7B,CAAuC;AACrCG,EAAAA,WAAW,GAAG;AACZ;AACA;AACD;;AACDC,EAAAA,IAAI,CAACC,YAAD,EAAeC,SAAf,EAA0BC,WAA1B,EAAuC;AACzC,UAAMC,OAAO,GAAG,IAAIP,OAAJ,EAAhB;AACA,UAAMQ,CAAC,GAAGH,SAAS,CAACI,MAApB,CAFyC,CAEZ;;AAC7B,QAAIC,IAAI,GAAG,EAAX,CAHyC,CAGzB;AAEhB;;AACA,QAAIC,GAAG,GAAGP,YAAV;;AACA,SAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAApB,EAAuBI,CAAC,EAAxB,EAA4B;AAC1BC,MAAAA,OAAO,CAACC,GAAR,CAAYT,SAAS,CAACO,CAAD,CAAT,CAAaG,OAAzB,EAAkCV,SAAS,CAACO,CAAD,CAAT,CAAaI,MAA/C;AACAL,MAAAA,GAAG,IAAIJ,OAAO,CAACU,EAAR,CAAWZ,SAAS,CAACO,CAAD,CAAT,CAAaG,OAAxB,EAAiCV,SAAS,CAACO,CAAD,CAAT,CAAaI,MAA9C,EAAsD,CAAtD,CAAP;AACD;;AACDH,IAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ,EAA6BV,YAA7B,EAA2C,OAA3C,EAAoDO,GAApD,EAAyD,eAAzD,EAA0EL,WAA1E;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGG;;AArCoC;;AAwCvC,eAAeL,QAAf","sourcesContent":["\nimport React, { Component } from 'react';\nimport Finance from 'financejs';\n\nclass GoalSeek extends React.Component {\n  constructor() {\n    //\n    super();\n  }\n  seek(initialValue, dataTable, targetValue) {\n    const finance = new Finance();\n    const n = dataTable.length;  // number of periods\n    let rate = .1;  // initial guess for the rate of return\n\n    // calculate the net present value of the investments at the initial guess for the rate of return\n    let npv = initialValue;\n    for (var i = 0; i < n; i++) {\n      console.log(dataTable[i].intRate, dataTable[i].annPay);\n      npv += finance.FV(dataTable[i].intRate, dataTable[i].annPay, 1);\n    }\n    console.log(\"initialValue:\", initialValue, \" npv:\", npv, \" targetValue:\", targetValue);\n    /*\n    // iterate until the net present value is close enough to the target value, or until the maximum number of iterations is reached\n    const tolerance = 1e-2;  // tolerance for the error between the net present value and the target value\n    const maxIterations = 1e+5;  // maximum number of iterations\n    let iterations = 0;  // current number of iterations\n    while (Math.abs(npv - targetValue) > tolerance && iterations < maxIterations) {\n      // adjust the rate of return based on the error between the net present value and the target value\n      rate -= (targetValue - npv) / npv;\n\n      // recalculate the net present value at the new rate of return\n      npv = finance.PV(rate, dataTable[n - 1].balEOY)\n      console.log(npv, Math.abs(npv - targetValue), rate);\n      iterations++;\n    }\n\n    if (iterations === maxIterations) {\n      throw new Error('Could not find a solution within the maximum number of iterations');\n    }\n    return rate;\n    */\n  }\n}\n\nexport default GoalSeek;\n"]},"metadata":{},"sourceType":"module"}