{"ast":null,"code":"import React, { Component } from 'react';\nimport Finance from 'financejs';\nimport Mathfuncts from './mathfuncts';\nimport MathFuncts from './mathfuncts';\n\nclass GoalSeek extends React.Component {\n  constructor() {\n    //\n    super();\n    this.mf = new MathFuncts();\n  }\n\n  seek(initialValue, dataTable, targetValue) {\n    const finance = new Finance();\n    const n = dataTable.length; // number of periods\n\n    let rate = .1; // initial guess for the rate of return\n    // calculate the net present value of the investments at the initial guess for the rate of return\n\n    let npv = finance.PV(rate, dataTable[n - 1].balBOY); // iterate until the net present value is close enough to the target value, or until the maximum number of iterations is reached\n\n    const tolerance = 1e-3; // tolerance for the error between the net present value and the target value\n\n    const maxIterations = 1e+4; // maximum number of iterations\n\n    let iterations = 0; // current number of iterations\n\n    while (Math.abs(npv - targetValue) > tolerance && iterations < maxIterations) {\n      // adjust the rate of return based on the error between the net present value and the target value\n      rate += this.mf.calcROR(npv, targetValue); // recalculate the net present value at the new rate of return\n\n      npv = npv = finance.PV(rate, dataTable[n - 1].balBOY);\n      console.log(npv, Math.abs(npv - targetValue), rate);\n      iterations++;\n    }\n\n    if (iterations === maxIterations) {\n      throw new Error('Could not find a solution within the maximum number of iterations');\n    }\n\n    console.log(finance.PV(-28, 1000));\n    return rate;\n  }\n\n}\n\nexport default GoalSeek;","map":{"version":3,"sources":["/Users/jonwretlind/Dropbox (1)/__Jon/__Jon Project Files/Code Projects/Incisic/incisic-app/src/helpers/goalseek.js"],"names":["React","Component","Finance","Mathfuncts","MathFuncts","GoalSeek","constructor","mf","seek","initialValue","dataTable","targetValue","finance","n","length","rate","npv","PV","balBOY","tolerance","maxIterations","iterations","Math","abs","calcROR","console","log","Error"],"mappings":"AACA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,UAAP,MAAuB,cAAvB;;AAEA,MAAMC,QAAN,SAAuBL,KAAK,CAACC,SAA7B,CAAuC;AACrCK,EAAAA,WAAW,GAAG;AACZ;AACA;AACA,SAAKC,EAAL,GAAU,IAAIH,UAAJ,EAAV;AACD;;AACDI,EAAAA,IAAI,CAACC,YAAD,EAAeC,SAAf,EAA0BC,WAA1B,EAAuC;AACzC,UAAMC,OAAO,GAAG,IAAIV,OAAJ,EAAhB;AACA,UAAMW,CAAC,GAAGH,SAAS,CAACI,MAApB,CAFyC,CAEZ;;AAC7B,QAAIC,IAAI,GAAG,EAAX,CAHyC,CAGzB;AAEhB;;AACA,QAAIC,GAAG,GAAGJ,OAAO,CAACK,EAAR,CAAWF,IAAX,EAAiBL,SAAS,CAACG,CAAC,GAAG,CAAL,CAAT,CAAiBK,MAAlC,CAAV,CANyC,CAQzC;;AACA,UAAMC,SAAS,GAAG,IAAlB,CATyC,CAShB;;AACzB,UAAMC,aAAa,GAAG,IAAtB,CAVyC,CAUZ;;AAC7B,QAAIC,UAAU,GAAG,CAAjB,CAXyC,CAWpB;;AACrB,WAAOC,IAAI,CAACC,GAAL,CAASP,GAAG,GAAGL,WAAf,IAA8BQ,SAA9B,IAA2CE,UAAU,GAAGD,aAA/D,EAA8E;AAC5E;AACAL,MAAAA,IAAI,IAAI,KAAKR,EAAL,CAAQiB,OAAR,CAAgBR,GAAhB,EAAqBL,WAArB,CAAR,CAF4E,CAI5E;;AACAK,MAAAA,GAAG,GAAGA,GAAG,GAAGJ,OAAO,CAACK,EAAR,CAAWF,IAAX,EAAiBL,SAAS,CAACG,CAAC,GAAG,CAAL,CAAT,CAAiBK,MAAlC,CAAZ;AACAO,MAAAA,OAAO,CAACC,GAAR,CAAYV,GAAZ,EAAiBM,IAAI,CAACC,GAAL,CAASP,GAAG,GAAGL,WAAf,CAAjB,EAA8CI,IAA9C;AACAM,MAAAA,UAAU;AACX;;AAED,QAAIA,UAAU,KAAKD,aAAnB,EAAkC;AAChC,YAAM,IAAIO,KAAJ,CAAU,mEAAV,CAAN;AACD;;AACDF,IAAAA,OAAO,CAACC,GAAR,CAAYd,OAAO,CAACK,EAAR,CAAW,CAAC,EAAZ,EAAgB,IAAhB,CAAZ;AACA,WAAOF,IAAP;AACD;;AAjCoC;;AAoCvC,eAAeV,QAAf","sourcesContent":["\nimport React, { Component } from 'react';\nimport Finance from 'financejs';\nimport Mathfuncts from './mathfuncts';\nimport MathFuncts from './mathfuncts';\n\nclass GoalSeek extends React.Component {\n  constructor() {\n    //\n    super();\n    this.mf = new MathFuncts();\n  }\n  seek(initialValue, dataTable, targetValue) {\n    const finance = new Finance();\n    const n = dataTable.length;  // number of periods\n    let rate = .1;  // initial guess for the rate of return\n\n    // calculate the net present value of the investments at the initial guess for the rate of return\n    let npv = finance.PV(rate, dataTable[n - 1].balBOY);\n\n    // iterate until the net present value is close enough to the target value, or until the maximum number of iterations is reached\n    const tolerance = 1e-3;  // tolerance for the error between the net present value and the target value\n    const maxIterations = 1e+4;  // maximum number of iterations\n    let iterations = 0;  // current number of iterations\n    while (Math.abs(npv - targetValue) > tolerance && iterations < maxIterations) {\n      // adjust the rate of return based on the error between the net present value and the target value\n      rate += this.mf.calcROR(npv, targetValue);\n\n      // recalculate the net present value at the new rate of return\n      npv = npv = finance.PV(rate, dataTable[n - 1].balBOY)\n      console.log(npv, Math.abs(npv - targetValue), rate);\n      iterations++;\n    }\n\n    if (iterations === maxIterations) {\n      throw new Error('Could not find a solution within the maximum number of iterations');\n    }\n    console.log(finance.PV(-28, 1000))\n    return rate;\n  }\n}\n\nexport default GoalSeek;\n"]},"metadata":{},"sourceType":"module"}